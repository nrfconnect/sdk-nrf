/*
 * Copyright (c) 2024 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/**
 * @file
 *   This file implements Remote Procedure Calls (RPC) for logging subsystem.
 *
 */

#include <nrf_rpc_cbor.h>
#include <nrf_rpc/nrf_rpc_uart.h>

#include <zephyr/device.h>
#include <zephyr/logging/log.h>
#include <zephyr/logging/log_backend.h>
#include <zephyr/logging/log_backend_std.h>
#include <zephyr/logging/log_output.h>

#include <string.h>

#ifdef CONFIG_NRF_RPC_IPC_SERVICE
NRF_RPC_IPC_TRANSPORT(log_rpc_tr, DEVICE_DT_GET(DT_NODELABEL(ipc0)), "log_rpc_ept");
#elif defined(CONFIG_NRF_RPC_UART_TRANSPORT)
#define log_rpc_tr NRF_RPC_UART_TRANSPORT(DT_NODELABEL(uart1))
#endif
NRF_RPC_GROUP_DEFINE(log_rpc_group, "log", &log_rpc_tr, NULL, NULL, NULL);

enum log_rpc_evt_forwarder {
	LOG_RPC_EVT_MSG = 0,
};

enum log_rpc_cmd_backend {
	LOG_RPC_CMD_GET_CRASH_LOG = 0,
};

#ifdef CONFIG_LOG_FORWARDER_RPC

LOG_MODULE_REGISTER(rpc);

static void log_rpc_msg_handler(const struct nrf_rpc_group *group, struct nrf_rpc_cbor_ctx *ctx,
				void *handler_data)
{
	uint8_t level;
	struct zcbor_string message;
	bool decoded_ok;

	decoded_ok = zcbor_uint_decode(ctx->zs, &level, sizeof(level));
	decoded_ok = decoded_ok && zcbor_bstr_decode(ctx->zs, &message);
	nrf_rpc_cbor_decoding_done(group, ctx);

	if (!decoded_ok) {
		goto out;
	}

	switch (level) {
	case LOG_LEVEL_ERR:
		LOG_ERR("%.*s", message.len, message.value);
		break;
	case LOG_LEVEL_WRN:
		LOG_WRN("%.*s", message.len, message.value);
		break;
	case LOG_LEVEL_INF:
		LOG_INF("%.*s", message.len, message.value);
		break;
	case LOG_LEVEL_DBG:
		LOG_DBG("%.*s", message.len, message.value);
		break;
	default:
		break;
	}

out:
	return;
}

NRF_RPC_CBOR_EVT_DECODER(log_rpc_group, log_rpc_msg_handler, LOG_RPC_EVT_MSG, log_rpc_msg_handler,
			 NULL);

#endif /* CONFIG_LOG_FORWARDER_RPC */

#ifdef CONFIG_LOG_BACKEND_RPC

/*
 * Drop messages coming from nRF RPC to avoid the avalanche of logs:
 * 1. log added
 * 2. log sent over nRF RPC
 * 3. more logs generated by nRF RPC
 * 4. more logs sent over nRF RPC
 * ...
 */
static const char *const filtered_out_sources[] = {
	"nrf_rpc",
	"NRF_RPC",
};

static bool panic_mode;
static uint32_t log_format = LOG_OUTPUT_TEXT;
static uint8_t current_level;
static uint8_t tx_buffer[CONFIG_LOG_BACKEND_RPC_BUFFER_SIZE];

extern struct k_thread logging_thread;

static int send(uint8_t *data, size_t length, void *context)
{
	struct nrf_rpc_cbor_ctx ctx;
	const struct zcbor_string data_string = {
		.value = data,
		.len = length,
	};

	NRF_RPC_CBOR_ALLOC(&log_rpc_group, ctx, 4 + length);

	if (!zcbor_uint_encode(ctx.zs, &current_level, sizeof(current_level)) ||
	    !zcbor_bstr_encode(ctx.zs, &data_string)) {
		/*
		 * Log output does not handle error codes gracefully, so pretend the buffer has been
		 * flushed to move on and not enter an infinite loop.
		 */
		NRF_RPC_CBOR_DISCARD(&log_rpc_group, ctx);
		return length;
	}

	nrf_rpc_cbor_evt_no_err(&log_rpc_group, LOG_RPC_EVT_MSG, &ctx);

	return length;
}

LOG_OUTPUT_DEFINE(log_output_rpc, send, tx_buffer, sizeof(tx_buffer));

static const char *log_msg_source_name_get(struct log_msg *msg)
{
	void *source;
	uint32_t source_id;

	if (log_msg_get_domain(msg) != Z_LOG_LOCAL_DOMAIN_ID) {
		return NULL;
	}

	source = (void *)log_msg_get_source(msg);

	if (source == NULL) {
		return NULL;
	}

	source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? log_dynamic_source_id(source)
							     : log_const_source_id(source);

	return TYPE_SECTION_START(log_const)[source_id].name;
}

static inline bool starts_with(const char *str, const char *prefix)
{
	return strncmp(str, prefix, strlen(prefix)) == 0;
}

static void process(const struct log_backend *const backend, union log_msg_generic *msg)
{
	const uint32_t flags = LOG_OUTPUT_FLAG_TIMESTAMP | LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP |
			       LOG_OUTPUT_FLAG_CRLF_NONE;
	const log_format_func_t log_formatter = log_format_func_t_get(log_format);
	const char *source_name = log_msg_source_name_get(&msg->log);

	if (!NRF_RPC_GROUP_STATUS(log_rpc_group)) {
		return;
	}

	if (source_name != NULL) {
		for (size_t i = 0; i < ARRAY_SIZE(filtered_out_sources); i++) {
			if (starts_with(source_name, filtered_out_sources[i])) {
				return;
			}
		}
	}

	if (panic_mode) {
		/* TODO: retain the crash log and make it available after reboot. */
		return;
	}

	current_level = log_msg_get_level(&msg->log);
	log_formatter(&log_output_rpc, &msg->log, flags);
}

static void panic(struct log_backend const *const backend)
{
	ARG_UNUSED(backend);

	panic_mode = true;
}

static void init(struct log_backend const *const backend)
{
	ARG_UNUSED(backend);
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output_rpc, cnt);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	ARG_UNUSED(backend);

	log_format = log_type;

	return 0;
}

static const struct log_backend_api log_backend_rpc_api = {
	.process = process,
	.panic = panic,
	.init = init,
	.dropped = dropped,
	.format_set = format_set,
};

LOG_BACKEND_DEFINE(log_backend_rpc, log_backend_rpc_api, true);

#endif /* CONFIG_LOG_BACKEND_RPC */
