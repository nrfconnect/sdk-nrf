/*
 * Copyright (c) 2026 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <internal/key_derivation/cracen_kdf_common.h>

#include <string.h>
#include <stdbool.h>
#include <cracen/statuscodes.h>
#include <cracen_psa.h>
#include <cracen/common.h>
#include <cracen_psa_primitives.h>

psa_status_t cracen_kdf_start_mac_operation(cracen_key_derivation_operation_t *operation,
					    const uint8_t *key_buffer, size_t key_buffer_size)
{
	psa_key_attributes_t attributes = {0};

	psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
	psa_set_key_bits(&attributes, PSA_BYTES_TO_BITS(key_buffer_size));

#if defined(PSA_NEED_CRACEN_SP800_108_COUNTER_CMAC)
	if (operation->alg == PSA_ALG_SP800_108_COUNTER_CMAC) {
		psa_set_key_id(&attributes, operation->mac_ctr.key_id);
		psa_set_key_lifetime(&attributes, operation->mac_ctr.key_lifetime);
	}
#endif /* PSA_NEED_CRACEN_SP800_108_COUNTER_CMAC */

	psa_algorithm_t mac_alg;

	if (operation->alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128 ||
	    operation->alg == PSA_ALG_SP800_108_COUNTER_CMAC) {
		psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
		mac_alg = PSA_ALG_CMAC;
	} else {
		psa_set_key_type(&attributes, PSA_KEY_TYPE_HMAC);
		mac_alg = PSA_ALG_HMAC(PSA_ALG_GET_HASH(operation->alg));
	}
	return cracen_mac_sign_setup(&operation->mac_op, &attributes, key_buffer, key_buffer_size,
				     mac_alg);
}

psa_status_t cracen_kdf_generate_output_bytes(cracen_key_derivation_operation_t *operation,
					      cracen_kdf_block_generator_t block_gen,
					      uint8_t *output, size_t output_length)
{
	if (block_gen == NULL) {
		return PSA_ERROR_NOT_SUPPORTED;
	}

	if (output_length > operation->capacity) {
		return PSA_ERROR_INSUFFICIENT_DATA;
	}

	operation->capacity -= output_length;

	/* Fill up the output buffer with generated bytes. */
	while (output_length) {
		if (operation->output_block_available_bytes) {
			/* Copy out buffered output. This may be a partial
			 * block.
			 */
			unsigned int out =
				MIN(output_length, operation->output_block_available_bytes);

			memcpy(output, operation->output_block, out);

			output += out;
			output_length -= out;
			operation->output_block_available_bytes -= out;

			if (operation->output_block_available_bytes) {
				memmove(operation->output_block, operation->output_block + out,
					operation->output_block_available_bytes);
			}
		} else {
			/* No data available, produce new block. */
			psa_status_t status = block_gen(operation);

			if (status != PSA_SUCCESS) {
				return status;
			}
		}
	}

	return PSA_SUCCESS;
}
