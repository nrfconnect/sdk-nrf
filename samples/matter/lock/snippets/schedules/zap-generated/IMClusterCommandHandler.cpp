/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <cinttypes>
#include <cstdint>

#include <app-common/zap-generated/callback.h>
#include <app-common/zap-generated/cluster-objects.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/CommandHandler.h>
#include <app/InteractionModelEngine.h>
#include <app/util/util.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/TypeTraits.h>

namespace chip
{
namespace app
{

	// Cluster specific command parsing

	namespace Clusters
	{

		namespace DoorLock
		{

			Protocols::InteractionModel::Status
			DispatchServerCommand(CommandHandler *apCommandObj, const ConcreteCommandPath &aCommandPath,
					      TLV::TLVReader &aDataTlv)
			{
				CHIP_ERROR TLVError = CHIP_NO_ERROR;
				bool wasHandled = false;
				{
					switch (aCommandPath.mCommandId) {
					case Commands::LockDoor::Id: {
						Commands::LockDoor::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterLockDoorCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::UnlockDoor::Id: {
						Commands::UnlockDoor::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterUnlockDoorCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::UnlockWithTimeout::Id: {
						Commands::UnlockWithTimeout::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterUnlockWithTimeoutCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetWeekDaySchedule::Id: {
						Commands::SetWeekDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterSetWeekDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::GetWeekDaySchedule::Id: {
						Commands::GetWeekDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterGetWeekDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::ClearWeekDaySchedule::Id: {
						Commands::ClearWeekDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterClearWeekDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetYearDaySchedule::Id: {
						Commands::SetYearDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterSetYearDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::GetYearDaySchedule::Id: {
						Commands::GetYearDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterGetYearDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::ClearYearDaySchedule::Id: {
						Commands::ClearYearDaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterClearYearDayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetHolidaySchedule::Id: {
						Commands::SetHolidaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterSetHolidayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::GetHolidaySchedule::Id: {
						Commands::GetHolidaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterGetHolidayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::ClearHolidaySchedule::Id: {
						Commands::ClearHolidaySchedule::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterClearHolidayScheduleCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetUser::Id: {
						Commands::SetUser::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterSetUserCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::GetUser::Id: {
						Commands::GetUser::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterGetUserCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::ClearUser::Id: {
						Commands::ClearUser::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterClearUserCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetCredential::Id: {
						Commands::SetCredential::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterSetCredentialCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::GetCredentialStatus::Id: {
						Commands::GetCredentialStatus::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterGetCredentialStatusCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::ClearCredential::Id: {
						Commands::ClearCredential::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled = emberAfDoorLockClusterClearCredentialCallback(
								apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					default: {
						// Unrecognized command ID, error status will apply.
						ChipLogError(Zcl,
							     "Unknown command " ChipLogFormatMEI
							     " for cluster " ChipLogFormatMEI,
							     ChipLogValueMEI(aCommandPath.mCommandId),
							     ChipLogValueMEI(aCommandPath.mClusterId));
						return Protocols::InteractionModel::Status::UnsupportedCommand;
					}
					}
				}

				if (CHIP_NO_ERROR != TLVError || !wasHandled) {
					ChipLogProgress(Zcl, "Failed to dispatch command, TLVError=%" CHIP_ERROR_FORMAT,
							TLVError.Format());
					return Protocols::InteractionModel::Status::InvalidCommand;
				}

				// We use success as a marker that no special handling is required
				// This is to avoid having a std::optional which uses slightly more code.
				return Protocols::InteractionModel::Status::Success;
			}

		} // namespace DoorLock

		namespace OtaSoftwareUpdateRequestor
		{

			Protocols::InteractionModel::Status
			DispatchServerCommand(CommandHandler *apCommandObj, const ConcreteCommandPath &aCommandPath,
					      TLV::TLVReader &aDataTlv)
			{
				CHIP_ERROR TLVError = CHIP_NO_ERROR;
				bool wasHandled = false;
				{
					switch (aCommandPath.mCommandId) {
					case Commands::AnnounceOTAProvider::Id: {
						Commands::AnnounceOTAProvider::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfOtaSoftwareUpdateRequestorClusterAnnounceOTAProviderCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					default: {
						// Unrecognized command ID, error status will apply.
						ChipLogError(Zcl,
							     "Unknown command " ChipLogFormatMEI
							     " for cluster " ChipLogFormatMEI,
							     ChipLogValueMEI(aCommandPath.mCommandId),
							     ChipLogValueMEI(aCommandPath.mClusterId));
						return Protocols::InteractionModel::Status::UnsupportedCommand;
					}
					}
				}

				if (CHIP_NO_ERROR != TLVError || !wasHandled) {
					ChipLogProgress(Zcl, "Failed to dispatch command, TLVError=%" CHIP_ERROR_FORMAT,
							TLVError.Format());
					return Protocols::InteractionModel::Status::InvalidCommand;
				}

				// We use success as a marker that no special handling is required
				// This is to avoid having a std::optional which uses slightly more code.
				return Protocols::InteractionModel::Status::Success;
			}

		} // namespace OtaSoftwareUpdateRequestor

		namespace ThreadNetworkDiagnostics
		{

			Protocols::InteractionModel::Status
			DispatchServerCommand(CommandHandler *apCommandObj, const ConcreteCommandPath &aCommandPath,
					      TLV::TLVReader &aDataTlv)
			{
				CHIP_ERROR TLVError = CHIP_NO_ERROR;
				bool wasHandled = false;
				{
					switch (aCommandPath.mCommandId) {
					case Commands::ResetCounts::Id: {
						Commands::ResetCounts::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfThreadNetworkDiagnosticsClusterResetCountsCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					default: {
						// Unrecognized command ID, error status will apply.
						ChipLogError(Zcl,
							     "Unknown command " ChipLogFormatMEI
							     " for cluster " ChipLogFormatMEI,
							     ChipLogValueMEI(aCommandPath.mCommandId),
							     ChipLogValueMEI(aCommandPath.mClusterId));
						return Protocols::InteractionModel::Status::UnsupportedCommand;
					}
					}
				}

				if (CHIP_NO_ERROR != TLVError || !wasHandled) {
					ChipLogProgress(Zcl, "Failed to dispatch command, TLVError=%" CHIP_ERROR_FORMAT,
							TLVError.Format());
					return Protocols::InteractionModel::Status::InvalidCommand;
				}

				// We use success as a marker that no special handling is required
				// This is to avoid having a std::optional which uses slightly more code.
				return Protocols::InteractionModel::Status::Success;
			}

		} // namespace ThreadNetworkDiagnostics

		namespace TimeSynchronization
		{

			Protocols::InteractionModel::Status
			DispatchServerCommand(CommandHandler *apCommandObj, const ConcreteCommandPath &aCommandPath,
					      TLV::TLVReader &aDataTlv)
			{
				CHIP_ERROR TLVError = CHIP_NO_ERROR;
				bool wasHandled = false;
				{
					switch (aCommandPath.mCommandId) {
					case Commands::SetUTCTime::Id: {
						Commands::SetUTCTime::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfTimeSynchronizationClusterSetUTCTimeCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetTrustedTimeSource::Id: {
						Commands::SetTrustedTimeSource::DecodableType commandData;
						TLVError = commandData.Decode(aDataTlv,
									      apCommandObj->GetAccessingFabricIndex());
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfTimeSynchronizationClusterSetTrustedTimeSourceCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetTimeZone::Id: {
						Commands::SetTimeZone::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfTimeSynchronizationClusterSetTimeZoneCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetDSTOffset::Id: {
						Commands::SetDSTOffset::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfTimeSynchronizationClusterSetDSTOffsetCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					case Commands::SetDefaultNTP::Id: {
						Commands::SetDefaultNTP::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfTimeSynchronizationClusterSetDefaultNTPCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					default: {
						// Unrecognized command ID, error status will apply.
						ChipLogError(Zcl,
							     "Unknown command " ChipLogFormatMEI
							     " for cluster " ChipLogFormatMEI,
							     ChipLogValueMEI(aCommandPath.mCommandId),
							     ChipLogValueMEI(aCommandPath.mClusterId));
						return Protocols::InteractionModel::Status::UnsupportedCommand;
					}
					}
				}

				if (CHIP_NO_ERROR != TLVError || !wasHandled) {
					ChipLogProgress(Zcl, "Failed to dispatch command, TLVError=%" CHIP_ERROR_FORMAT,
							TLVError.Format());
					return Protocols::InteractionModel::Status::InvalidCommand;
				}

				// We use success as a marker that no special handling is required
				// This is to avoid having a std::optional which uses slightly more code.
				return Protocols::InteractionModel::Status::Success;
			}

		} // namespace TimeSynchronization

	} // namespace Clusters

	void DispatchSingleClusterCommand(const ConcreteCommandPath &aCommandPath, TLV::TLVReader &aReader,
					  CommandHandler *apCommandObj)
	{
		Protocols::InteractionModel::Status errorStatus = Protocols::InteractionModel::Status::Success;

		switch (aCommandPath.mClusterId) {
		case Clusters::DoorLock::Id:
			errorStatus = Clusters::DoorLock::DispatchServerCommand(apCommandObj, aCommandPath, aReader);
			break;
		case Clusters::OtaSoftwareUpdateRequestor::Id:
			errorStatus = Clusters::OtaSoftwareUpdateRequestor::DispatchServerCommand(
				apCommandObj, aCommandPath, aReader);
			break;
		case Clusters::ThreadNetworkDiagnostics::Id:
			errorStatus = Clusters::ThreadNetworkDiagnostics::DispatchServerCommand(apCommandObj,
												aCommandPath, aReader);
			break;
		case Clusters::TimeSynchronization::Id:
			errorStatus = Clusters::TimeSynchronization::DispatchServerCommand(apCommandObj, aCommandPath,
											   aReader);
			break;
		default:
			ChipLogError(Zcl, "Unknown cluster " ChipLogFormatMEI,
				     ChipLogValueMEI(aCommandPath.mClusterId));
			errorStatus = Protocols::InteractionModel::Status::UnsupportedCluster;
			break;
		}

		if (errorStatus != Protocols::InteractionModel::Status::Success) {
			apCommandObj->AddStatus(aCommandPath, errorStatus);
		}
	}

} // namespace app
} // namespace chip
