/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <cinttypes>
#include <cstdint>

#include <app-common/zap-generated/callback.h>
#include <app-common/zap-generated/cluster-objects.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/CommandHandler.h>
#include <app/InteractionModelEngine.h>
#include <app/util/util.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/TypeTraits.h>

namespace chip
{
namespace app
{

	// Cluster specific command parsing

	namespace Clusters
	{

		namespace OtaSoftwareUpdateRequestor
		{

			Protocols::InteractionModel::Status
			DispatchServerCommand(CommandHandler *apCommandObj, const ConcreteCommandPath &aCommandPath,
					      TLV::TLVReader &aDataTlv)
			{
				CHIP_ERROR TLVError = CHIP_NO_ERROR;
				bool wasHandled = false;
				{
					switch (aCommandPath.mCommandId) {
					case Commands::AnnounceOTAProvider::Id: {
						Commands::AnnounceOTAProvider::DecodableType commandData;
						TLVError = DataModel::Decode(aDataTlv, commandData);
						if (TLVError == CHIP_NO_ERROR) {
							wasHandled =
								emberAfOtaSoftwareUpdateRequestorClusterAnnounceOTAProviderCallback(
									apCommandObj, aCommandPath, commandData);
						}
						break;
					}
					default: {
						// Unrecognized command ID, error status will apply.
						ChipLogError(Zcl,
							     "Unknown command " ChipLogFormatMEI
							     " for cluster " ChipLogFormatMEI,
							     ChipLogValueMEI(aCommandPath.mCommandId),
							     ChipLogValueMEI(aCommandPath.mClusterId));
						return Protocols::InteractionModel::Status::UnsupportedCommand;
					}
					}
				}

				if (CHIP_NO_ERROR != TLVError || !wasHandled) {
					ChipLogProgress(Zcl, "Failed to dispatch command, TLVError=%" CHIP_ERROR_FORMAT,
							TLVError.Format());
					return Protocols::InteractionModel::Status::InvalidCommand;
				}

				// We use success as a marker that no special handling is required
				// This is to avoid having a std::optional which uses slightly more code.
				return Protocols::InteractionModel::Status::Success;
			}

		} // namespace OtaSoftwareUpdateRequestor

	} // namespace Clusters

	void DispatchSingleClusterCommand(const ConcreteCommandPath &aCommandPath, TLV::TLVReader &aReader,
					  CommandHandler *apCommandObj)
	{
		Protocols::InteractionModel::Status errorStatus = Protocols::InteractionModel::Status::Success;

		switch (aCommandPath.mClusterId) {
		case Clusters::OtaSoftwareUpdateRequestor::Id:
			errorStatus = Clusters::OtaSoftwareUpdateRequestor::DispatchServerCommand(
				apCommandObj, aCommandPath, aReader);
			break;
		default:
			ChipLogError(Zcl, "Unknown cluster " ChipLogFormatMEI,
				     ChipLogValueMEI(aCommandPath.mClusterId));
			errorStatus = Protocols::InteractionModel::Status::UnsupportedCluster;
			break;
		}

		if (errorStatus != Protocols::InteractionModel::Status::Success) {
			apCommandObj->AddStatus(aCommandPath, errorStatus);
		}
	}

} // namespace app
} // namespace chip
