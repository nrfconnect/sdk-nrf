/*
 * Copyright (c) 2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "decrypt_test_utils.h"

/* This module holds common utilities for SUIT decrypt filter tests.
 * It defines default encryption key data, plaintext and ciphertext along with other
 * suit_encryption_info struct members that can be used while testing.
 *
 * WARNING: All of the const values defined in this module CAN be changed freely.
 * This also means that any test depending on them should expect it.
 */

/**
 * The master key used by these tests can be imported into the local KMS backend by running:
 *
 * nrfkms import_keyvalue -k TEST_AES_KEY -t aes -v aHWJdIkl5hdXw4SS1nTdVYE/q7ycMOZm2mR6qx/KvKw=
 *
 * The KEK below is derived from context "test"
 * To acquire it run:
 * nrfkms export_derived -k TEST_AES_KEY -c test --format native
 * hexdump -e '16/1 "0x%02x, " "\n"' kms_output/derived_key_native_test_from_TEST_AES_KEY.bin
 */
const uint8_t decrypt_test_key_data[] = {
	0xf8, 0xfa, 0x8e, 0x7b, 0xed, 0x32, 0xd0, 0xc7, 0x15, 0x1f, 0xd9, 0xab, 0x0d,
	0x8d, 0xed, 0x95, 0x26, 0xa8, 0x6a, 0x15, 0x34, 0x16, 0x01, 0xcf, 0x9c, 0x6b,
	0xba, 0x00, 0x6a, 0xab, 0xaa, 0x9a,
};

const uint8_t decrypt_test_plaintext[] = {
	"This is a sample plaintext for testing the decryption filter",
};

const uint8_t decrypt_test_aad[] = {
	"sample aad"
};

/**
 * Encryption and using wrapped CEK achieved by running:
 *
 * echo "This is a sample plaintext for testing the decryption filter" > plaintext.txt
 * nrfkms wrap -k TEST_AES_KEY -c test -f plaintext.txt --format native -t aes --aad "sample aad"
 *
 * Wrapped CEK stored in the resulting wrapped_aek-aes-... file
 *
 * Ciphertext and NONCE (IV) taken from the encrypted_asset-... file, which is in format
 * |nonce (12 bytes)|ciphertext|tag (16 bytes)|
 *
 */
const uint8_t decrypt_test_wrapped_cek[] = {
	0x7d, 0xd6, 0xf4, 0xd3, 0x52, 0x44, 0x5a, 0x3a, 0x67, 0xb8, 0xcc,
	0x74, 0x5b, 0x4b, 0x6f, 0x70, 0x62, 0xc3, 0xf2, 0x7b, 0x6b, 0x14,
	0xf1, 0x06, 0x57, 0xa3, 0x68, 0x32, 0x44, 0xc3, 0x85, 0x77, 0x86,
	0xe7, 0xda, 0x15, 0xbf, 0xf8, 0x9e, 0x63,
};

const uint8_t decrypt_test_ciphertext_aes_kw[] = {
	/* tag (16 bytes) */
	0xdc, 0xe6, 0x95, 0xac, 0x0f, 0x61, 0x87, 0x17, 0x51, 0x48, 0xb4, 0xa1,
	0x8e, 0x09, 0x89, 0xb4,
	/* ciphertext */
	0x8b, 0xfb, 0xd9, 0xe4, 0xcf, 0xde, 0xf8, 0xcf, 0xe5, 0x69, 0x9d, 0x6d,
	0x92, 0x8a, 0x04, 0xf8, 0x26, 0x22, 0xd5, 0xd8, 0xe8, 0x77, 0x18, 0x5a,
	0x01, 0x13, 0xba, 0xd5, 0x23, 0x72, 0xae, 0x80, 0x44, 0xed, 0xea, 0xdf,
	0x74, 0x79, 0x8a, 0x83, 0x52, 0x72, 0x2f, 0x43, 0x06, 0xe9, 0xd4, 0xbb,
	0x54, 0x8a, 0x0d, 0xea, 0x7f, 0xe6, 0x48, 0xf0, 0xfd, 0x0e, 0xbb, 0xaa,
	0xa3,
};

const uint8_t decrypt_test_iv_aes_kw[] = {
	0x61, 0xb4, 0x70, 0x53, 0xa5, 0xe2, 0x05, 0x68, 0xfe, 0x77, 0x12, 0x89,
};

/**
 * Encryption without wrapping CEK achieved by running:
 *
 * echo "This is a sample plaintext for testing the decryption filter" > plaintext.txt
 * nrfkms encrypt -k  TEST_AES_KEY -c test -f plaintext.txt --aad "sample aad" --format native
 *
 * Ciphertext and NONCE (IV) taken from the encrypted_data_using_TEST_AES_KEY-test.bin file,
 * which is in format |nonce (12 bytes)|tag (16 bytes)|ciphertext|
 */

const uint8_t decrypt_test_ciphertext_direct[] = {
	/* tag (16 bytes) */
	0x4d, 0x21, 0x30, 0xb7, 0xce, 0x8a, 0xd6, 0x00, 0xe4, 0x04, 0xbb, 0x32,
	0x72, 0x7a, 0xbb, 0x7c,
	/* ciphertext */
	0xf0, 0x72, 0xdb, 0x63, 0x03, 0xdd, 0x24, 0x69,
	0xd4, 0xbf, 0xd7, 0xa0, 0xec, 0xfa, 0x66, 0x58, 0x95, 0x2b, 0xc1, 0xc2,
	0x9d, 0x82, 0x02, 0x1a, 0xd7, 0x5b, 0xc0, 0x01, 0xce, 0x0b, 0x79, 0x53,
	0xe7, 0xdb, 0x0d, 0x35, 0xab, 0xef, 0x81, 0xc8, 0x68, 0xc5, 0xa7, 0x22,
	0x90, 0xea, 0xd0, 0x7f, 0x36, 0xed, 0x14, 0xbe, 0x30, 0xf2, 0x81, 0x56,
	0x7e, 0x2e, 0x5f, 0xd8, 0x7c,
};

const uint8_t decrypt_test_iv_direct[] = {
	0x60, 0x90, 0x6d, 0xb2, 0xfe, 0xc3, 0xc8, 0x5a, 0xf0, 0x28, 0xb1, 0xb6,
};

const suit_manifest_class_id_t decrypt_test_sample_class_id = {
	{0x5b, 0x46, 0x9f, 0xd1, 0x90, 0xee, 0x53, 0x9c, 0xa3, 0x18, 0x68, 0x1b, 0x03, 0x69, 0x5e,
	 0x36}};

psa_status_t decrypt_test_init_encryption_key(const uint8_t *data, size_t size,
		psa_key_id_t *key_id, psa_key_id_t alg, uint8_t *cbor_key_id)
{
	psa_status_t status;

	/* Configure the key attributes */
	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;

	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
	psa_set_key_algorithm(&key_attributes, alg);
	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
	psa_set_key_bits(&key_attributes, 256);

	status = psa_import_key(&key_attributes, data, size, key_id);

	/* Encode KEK key ID as CBOR unsigned int */
	cbor_key_id[0] = 0x1A;
	cbor_key_id[1] = ((*key_id >> 24) & 0xFF);
	cbor_key_id[2] = ((*key_id >> 16) & 0xFF);
	cbor_key_id[3] = ((*key_id >> 8) & 0xFF);
	cbor_key_id[4] = ((*key_id >> 0) & 0xFF);

	return status;
}
