
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

0000c200 <_vector_table>:
    c200:	20000a90 	.word	0x20000a90
    c204:	0000d4e9 	.word	0x0000d4e9
    c208:	0000fe39 	.word	0x0000fe39
    c20c:	0000d309 	.word	0x0000d309
    c210:	0000d309 	.word	0x0000d309
    c214:	0000d309 	.word	0x0000d309
    c218:	0000d309 	.word	0x0000d309
    c21c:	0000d309 	.word	0x0000d309
    c220:	0000d309 	.word	0x0000d309
    c224:	0000d309 	.word	0x0000d309
    c228:	0000d309 	.word	0x0000d309
    c22c:	0000d2d1 	.word	0x0000d2d1
    c230:	0000d309 	.word	0x0000d309
    c234:	0000d309 	.word	0x0000d309
    c238:	0000d27d 	.word	0x0000d27d
    c23c:	0000fd3b 	.word	0x0000fd3b

0000c240 <_irq_vector_table>:
    c240:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c250:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c260:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c270:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c280:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c290:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2a0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2b0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2c0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2d0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2e0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c2f0:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c300:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c310:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c320:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c330:	0000d335 0000d335 0000d335 0000d335     5...5...5...5...
    c340:	0000d335                                5...

0000c344 <_vector_end>:
	...

0000c400 <m_firmware_info>:
    c400:	281ee6de 8fcebb4c 00005b01 0000be00     ...(L....[......
    c410:	00000001 0000c200 200013d0 0000dc4d     ........... M...

Disassembly of section _TEXT_SECTION_NAME_2:

0000c420 <__aeabi_ldivmod>:
    c420:	b97b      	cbnz	r3, c442 <__aeabi_ldivmod+0x22>
    c422:	b972      	cbnz	r2, c442 <__aeabi_ldivmod+0x22>
    c424:	2900      	cmp	r1, #0
    c426:	bfbe      	ittt	lt
    c428:	2000      	movlt	r0, #0
    c42a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    c42e:	e006      	blt.n	c43e <__aeabi_ldivmod+0x1e>
    c430:	bf08      	it	eq
    c432:	2800      	cmpeq	r0, #0
    c434:	bf1c      	itt	ne
    c436:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    c43a:	f04f 30ff 	movne.w	r0, #4294967295
    c43e:	f000 b9af 	b.w	c7a0 <__aeabi_idiv0>
    c442:	f1ad 0c08 	sub.w	ip, sp, #8
    c446:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c44a:	2900      	cmp	r1, #0
    c44c:	db09      	blt.n	c462 <__aeabi_ldivmod+0x42>
    c44e:	2b00      	cmp	r3, #0
    c450:	db1a      	blt.n	c488 <__aeabi_ldivmod+0x68>
    c452:	f000 f835 	bl	c4c0 <__udivmoddi4>
    c456:	f8dd e004 	ldr.w	lr, [sp, #4]
    c45a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c45e:	b004      	add	sp, #16
    c460:	4770      	bx	lr
    c462:	4240      	negs	r0, r0
    c464:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c468:	2b00      	cmp	r3, #0
    c46a:	db1b      	blt.n	c4a4 <__aeabi_ldivmod+0x84>
    c46c:	f000 f828 	bl	c4c0 <__udivmoddi4>
    c470:	f8dd e004 	ldr.w	lr, [sp, #4]
    c474:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c478:	b004      	add	sp, #16
    c47a:	4240      	negs	r0, r0
    c47c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c480:	4252      	negs	r2, r2
    c482:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c486:	4770      	bx	lr
    c488:	4252      	negs	r2, r2
    c48a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c48e:	f000 f817 	bl	c4c0 <__udivmoddi4>
    c492:	f8dd e004 	ldr.w	lr, [sp, #4]
    c496:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c49a:	b004      	add	sp, #16
    c49c:	4240      	negs	r0, r0
    c49e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c4a2:	4770      	bx	lr
    c4a4:	4252      	negs	r2, r2
    c4a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c4aa:	f000 f809 	bl	c4c0 <__udivmoddi4>
    c4ae:	f8dd e004 	ldr.w	lr, [sp, #4]
    c4b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c4b6:	b004      	add	sp, #16
    c4b8:	4252      	negs	r2, r2
    c4ba:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c4be:	4770      	bx	lr

0000c4c0 <__udivmoddi4>:
    c4c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c4c4:	468c      	mov	ip, r1
    c4c6:	9d08      	ldr	r5, [sp, #32]
    c4c8:	4604      	mov	r4, r0
    c4ca:	468a      	mov	sl, r1
    c4cc:	2b00      	cmp	r3, #0
    c4ce:	d14a      	bne.n	c566 <__udivmoddi4+0xa6>
    c4d0:	428a      	cmp	r2, r1
    c4d2:	4617      	mov	r7, r2
    c4d4:	d962      	bls.n	c59c <__udivmoddi4+0xdc>
    c4d6:	fab2 f682 	clz	r6, r2
    c4da:	b14e      	cbz	r6, c4f0 <__udivmoddi4+0x30>
    c4dc:	f1c6 0e20 	rsb	lr, r6, #32
    c4e0:	fa01 f306 	lsl.w	r3, r1, r6
    c4e4:	40b7      	lsls	r7, r6
    c4e6:	40b4      	lsls	r4, r6
    c4e8:	fa20 fe0e 	lsr.w	lr, r0, lr
    c4ec:	ea4e 0a03 	orr.w	sl, lr, r3
    c4f0:	ea4f 4817 	mov.w	r8, r7, lsr #16
    c4f4:	0c23      	lsrs	r3, r4, #16
    c4f6:	fa1f f987 	uxth.w	r9, r7
    c4fa:	fbba fef8 	udiv	lr, sl, r8
    c4fe:	fb08 aa1e 	mls	sl, r8, lr, sl
    c502:	fb0e f209 	mul.w	r2, lr, r9
    c506:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
    c50a:	429a      	cmp	r2, r3
    c50c:	d90b      	bls.n	c526 <__udivmoddi4+0x66>
    c50e:	18fb      	adds	r3, r7, r3
    c510:	f10e 31ff 	add.w	r1, lr, #4294967295
    c514:	bf2c      	ite	cs
    c516:	2001      	movcs	r0, #1
    c518:	2000      	movcc	r0, #0
    c51a:	429a      	cmp	r2, r3
    c51c:	d902      	bls.n	c524 <__udivmoddi4+0x64>
    c51e:	2800      	cmp	r0, #0
    c520:	f000 812a 	beq.w	c778 <__udivmoddi4+0x2b8>
    c524:	468e      	mov	lr, r1
    c526:	1a9a      	subs	r2, r3, r2
    c528:	b2a3      	uxth	r3, r4
    c52a:	fbb2 f0f8 	udiv	r0, r2, r8
    c52e:	fb08 2210 	mls	r2, r8, r0, r2
    c532:	fb00 f909 	mul.w	r9, r0, r9
    c536:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
    c53a:	45a1      	cmp	r9, r4
    c53c:	d907      	bls.n	c54e <__udivmoddi4+0x8e>
    c53e:	193c      	adds	r4, r7, r4
    c540:	f100 33ff 	add.w	r3, r0, #4294967295
    c544:	d202      	bcs.n	c54c <__udivmoddi4+0x8c>
    c546:	45a1      	cmp	r9, r4
    c548:	f200 8110 	bhi.w	c76c <__udivmoddi4+0x2ac>
    c54c:	4618      	mov	r0, r3
    c54e:	eba4 0409 	sub.w	r4, r4, r9
    c552:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    c556:	2100      	movs	r1, #0
    c558:	b11d      	cbz	r5, c562 <__udivmoddi4+0xa2>
    c55a:	40f4      	lsrs	r4, r6
    c55c:	2300      	movs	r3, #0
    c55e:	e9c5 4300 	strd	r4, r3, [r5]
    c562:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c566:	428b      	cmp	r3, r1
    c568:	d908      	bls.n	c57c <__udivmoddi4+0xbc>
    c56a:	2d00      	cmp	r5, #0
    c56c:	f000 80f2 	beq.w	c754 <__udivmoddi4+0x294>
    c570:	2100      	movs	r1, #0
    c572:	e9c5 0c00 	strd	r0, ip, [r5]
    c576:	4608      	mov	r0, r1
    c578:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c57c:	fab3 f183 	clz	r1, r3
    c580:	2900      	cmp	r1, #0
    c582:	d14e      	bne.n	c622 <__udivmoddi4+0x162>
    c584:	4563      	cmp	r3, ip
    c586:	f0c0 80e8 	bcc.w	c75a <__udivmoddi4+0x29a>
    c58a:	4282      	cmp	r2, r0
    c58c:	f240 80e5 	bls.w	c75a <__udivmoddi4+0x29a>
    c590:	4608      	mov	r0, r1
    c592:	2d00      	cmp	r5, #0
    c594:	d0e5      	beq.n	c562 <__udivmoddi4+0xa2>
    c596:	e9c5 4a00 	strd	r4, sl, [r5]
    c59a:	e7e2      	b.n	c562 <__udivmoddi4+0xa2>
    c59c:	b902      	cbnz	r2, c5a0 <__udivmoddi4+0xe0>
    c59e:	deff      	udf	#255	; 0xff
    c5a0:	fab2 f682 	clz	r6, r2
    c5a4:	2e00      	cmp	r6, #0
    c5a6:	f040 8099 	bne.w	c6dc <__udivmoddi4+0x21c>
    c5aa:	1a8b      	subs	r3, r1, r2
    c5ac:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    c5b0:	fa1f f882 	uxth.w	r8, r2
    c5b4:	2101      	movs	r1, #1
    c5b6:	ea4f 4c14 	mov.w	ip, r4, lsr #16
    c5ba:	fbb3 f2fe 	udiv	r2, r3, lr
    c5be:	fb0e 3012 	mls	r0, lr, r2, r3
    c5c2:	fb08 f902 	mul.w	r9, r8, r2
    c5c6:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
    c5ca:	45e1      	cmp	r9, ip
    c5cc:	d908      	bls.n	c5e0 <__udivmoddi4+0x120>
    c5ce:	eb17 0c0c 	adds.w	ip, r7, ip
    c5d2:	f102 33ff 	add.w	r3, r2, #4294967295
    c5d6:	d202      	bcs.n	c5de <__udivmoddi4+0x11e>
    c5d8:	45e1      	cmp	r9, ip
    c5da:	f200 80ca 	bhi.w	c772 <__udivmoddi4+0x2b2>
    c5de:	461a      	mov	r2, r3
    c5e0:	ebac 0c09 	sub.w	ip, ip, r9
    c5e4:	b2a3      	uxth	r3, r4
    c5e6:	fbbc f0fe 	udiv	r0, ip, lr
    c5ea:	fb0e cc10 	mls	ip, lr, r0, ip
    c5ee:	fb08 f800 	mul.w	r8, r8, r0
    c5f2:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
    c5f6:	45a0      	cmp	r8, r4
    c5f8:	d90e      	bls.n	c618 <__udivmoddi4+0x158>
    c5fa:	193c      	adds	r4, r7, r4
    c5fc:	f100 33ff 	add.w	r3, r0, #4294967295
    c600:	bf2c      	ite	cs
    c602:	f04f 0c01 	movcs.w	ip, #1
    c606:	f04f 0c00 	movcc.w	ip, #0
    c60a:	45a0      	cmp	r8, r4
    c60c:	d903      	bls.n	c616 <__udivmoddi4+0x156>
    c60e:	f1bc 0f00 	cmp.w	ip, #0
    c612:	f000 80a8 	beq.w	c766 <__udivmoddi4+0x2a6>
    c616:	4618      	mov	r0, r3
    c618:	eba4 0408 	sub.w	r4, r4, r8
    c61c:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    c620:	e79a      	b.n	c558 <__udivmoddi4+0x98>
    c622:	f1c1 0420 	rsb	r4, r1, #32
    c626:	408b      	lsls	r3, r1
    c628:	fa02 fe01 	lsl.w	lr, r2, r1
    c62c:	fa0c f601 	lsl.w	r6, ip, r1
    c630:	40e2      	lsrs	r2, r4
    c632:	fa20 f704 	lsr.w	r7, r0, r4
    c636:	fa2c fc04 	lsr.w	ip, ip, r4
    c63a:	fa00 f801 	lsl.w	r8, r0, r1
    c63e:	4313      	orrs	r3, r2
    c640:	433e      	orrs	r6, r7
    c642:	0c1f      	lsrs	r7, r3, #16
    c644:	0c32      	lsrs	r2, r6, #16
    c646:	fa1f f983 	uxth.w	r9, r3
    c64a:	fbbc f0f7 	udiv	r0, ip, r7
    c64e:	fb07 cc10 	mls	ip, r7, r0, ip
    c652:	fb00 fa09 	mul.w	sl, r0, r9
    c656:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
    c65a:	45e2      	cmp	sl, ip
    c65c:	d908      	bls.n	c670 <__udivmoddi4+0x1b0>
    c65e:	eb13 0c0c 	adds.w	ip, r3, ip
    c662:	f100 32ff 	add.w	r2, r0, #4294967295
    c666:	d202      	bcs.n	c66e <__udivmoddi4+0x1ae>
    c668:	45e2      	cmp	sl, ip
    c66a:	f200 8089 	bhi.w	c780 <__udivmoddi4+0x2c0>
    c66e:	4610      	mov	r0, r2
    c670:	ebac 0c0a 	sub.w	ip, ip, sl
    c674:	b2b6      	uxth	r6, r6
    c676:	fbbc faf7 	udiv	sl, ip, r7
    c67a:	fb07 cc1a 	mls	ip, r7, sl, ip
    c67e:	fb0a f909 	mul.w	r9, sl, r9
    c682:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
    c686:	4591      	cmp	r9, r2
    c688:	d906      	bls.n	c698 <__udivmoddi4+0x1d8>
    c68a:	189a      	adds	r2, r3, r2
    c68c:	f10a 36ff 	add.w	r6, sl, #4294967295
    c690:	d201      	bcs.n	c696 <__udivmoddi4+0x1d6>
    c692:	4591      	cmp	r9, r2
    c694:	d87a      	bhi.n	c78c <__udivmoddi4+0x2cc>
    c696:	46b2      	mov	sl, r6
    c698:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
    c69c:	eba2 0209 	sub.w	r2, r2, r9
    c6a0:	fba0 670e 	umull	r6, r7, r0, lr
    c6a4:	42ba      	cmp	r2, r7
    c6a6:	46b4      	mov	ip, r6
    c6a8:	46b9      	mov	r9, r7
    c6aa:	d302      	bcc.n	c6b2 <__udivmoddi4+0x1f2>
    c6ac:	d107      	bne.n	c6be <__udivmoddi4+0x1fe>
    c6ae:	45b0      	cmp	r8, r6
    c6b0:	d205      	bcs.n	c6be <__udivmoddi4+0x1fe>
    c6b2:	ebb6 0c0e 	subs.w	ip, r6, lr
    c6b6:	eb67 0303 	sbc.w	r3, r7, r3
    c6ba:	3801      	subs	r0, #1
    c6bc:	4699      	mov	r9, r3
    c6be:	2d00      	cmp	r5, #0
    c6c0:	d06b      	beq.n	c79a <__udivmoddi4+0x2da>
    c6c2:	ebb8 030c 	subs.w	r3, r8, ip
    c6c6:	eb62 0209 	sbc.w	r2, r2, r9
    c6ca:	fa02 f404 	lsl.w	r4, r2, r4
    c6ce:	40cb      	lsrs	r3, r1
    c6d0:	40ca      	lsrs	r2, r1
    c6d2:	2100      	movs	r1, #0
    c6d4:	431c      	orrs	r4, r3
    c6d6:	e9c5 4200 	strd	r4, r2, [r5]
    c6da:	e742      	b.n	c562 <__udivmoddi4+0xa2>
    c6dc:	40b7      	lsls	r7, r6
    c6de:	f1c6 0220 	rsb	r2, r6, #32
    c6e2:	fa01 f306 	lsl.w	r3, r1, r6
    c6e6:	40b4      	lsls	r4, r6
    c6e8:	fa21 fc02 	lsr.w	ip, r1, r2
    c6ec:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    c6f0:	fa20 f202 	lsr.w	r2, r0, r2
    c6f4:	fa1f f887 	uxth.w	r8, r7
    c6f8:	fbbc f1fe 	udiv	r1, ip, lr
    c6fc:	431a      	orrs	r2, r3
    c6fe:	fb0e cc11 	mls	ip, lr, r1, ip
    c702:	fb01 f008 	mul.w	r0, r1, r8
    c706:	0c13      	lsrs	r3, r2, #16
    c708:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
    c70c:	4560      	cmp	r0, ip
    c70e:	d907      	bls.n	c720 <__udivmoddi4+0x260>
    c710:	eb17 0c0c 	adds.w	ip, r7, ip
    c714:	f101 33ff 	add.w	r3, r1, #4294967295
    c718:	d201      	bcs.n	c71e <__udivmoddi4+0x25e>
    c71a:	4560      	cmp	r0, ip
    c71c:	d833      	bhi.n	c786 <__udivmoddi4+0x2c6>
    c71e:	4619      	mov	r1, r3
    c720:	ebac 0c00 	sub.w	ip, ip, r0
    c724:	b292      	uxth	r2, r2
    c726:	fbbc f0fe 	udiv	r0, ip, lr
    c72a:	fb0e cc10 	mls	ip, lr, r0, ip
    c72e:	fb00 f308 	mul.w	r3, r0, r8
    c732:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
    c736:	4563      	cmp	r3, ip
    c738:	d907      	bls.n	c74a <__udivmoddi4+0x28a>
    c73a:	eb17 0c0c 	adds.w	ip, r7, ip
    c73e:	f100 32ff 	add.w	r2, r0, #4294967295
    c742:	d201      	bcs.n	c748 <__udivmoddi4+0x288>
    c744:	4563      	cmp	r3, ip
    c746:	d825      	bhi.n	c794 <__udivmoddi4+0x2d4>
    c748:	4610      	mov	r0, r2
    c74a:	ebac 0303 	sub.w	r3, ip, r3
    c74e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    c752:	e730      	b.n	c5b6 <__udivmoddi4+0xf6>
    c754:	4629      	mov	r1, r5
    c756:	4628      	mov	r0, r5
    c758:	e703      	b.n	c562 <__udivmoddi4+0xa2>
    c75a:	1a84      	subs	r4, r0, r2
    c75c:	eb6c 0303 	sbc.w	r3, ip, r3
    c760:	2001      	movs	r0, #1
    c762:	469a      	mov	sl, r3
    c764:	e715      	b.n	c592 <__udivmoddi4+0xd2>
    c766:	3802      	subs	r0, #2
    c768:	443c      	add	r4, r7
    c76a:	e755      	b.n	c618 <__udivmoddi4+0x158>
    c76c:	3802      	subs	r0, #2
    c76e:	443c      	add	r4, r7
    c770:	e6ed      	b.n	c54e <__udivmoddi4+0x8e>
    c772:	3a02      	subs	r2, #2
    c774:	44bc      	add	ip, r7
    c776:	e733      	b.n	c5e0 <__udivmoddi4+0x120>
    c778:	f1ae 0e02 	sub.w	lr, lr, #2
    c77c:	443b      	add	r3, r7
    c77e:	e6d2      	b.n	c526 <__udivmoddi4+0x66>
    c780:	3802      	subs	r0, #2
    c782:	449c      	add	ip, r3
    c784:	e774      	b.n	c670 <__udivmoddi4+0x1b0>
    c786:	3902      	subs	r1, #2
    c788:	44bc      	add	ip, r7
    c78a:	e7c9      	b.n	c720 <__udivmoddi4+0x260>
    c78c:	f1aa 0a02 	sub.w	sl, sl, #2
    c790:	441a      	add	r2, r3
    c792:	e781      	b.n	c698 <__udivmoddi4+0x1d8>
    c794:	3802      	subs	r0, #2
    c796:	44bc      	add	ip, r7
    c798:	e7d7      	b.n	c74a <__udivmoddi4+0x28a>
    c79a:	4629      	mov	r1, r5
    c79c:	e6e1      	b.n	c562 <__udivmoddi4+0xa2>
    c79e:	bf00      	nop

0000c7a0 <__aeabi_idiv0>:
    c7a0:	4770      	bx	lr
    c7a2:	bf00      	nop

0000c7a4 <__gnu_cmse_nonsecure_call>:
    c7a4:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
    c7a8:	4627      	mov	r7, r4
    c7aa:	46a0      	mov	r8, r4
    c7ac:	46a1      	mov	r9, r4
    c7ae:	46a2      	mov	sl, r4
    c7b0:	46a3      	mov	fp, r4
    c7b2:	46a4      	mov	ip, r4
    c7b4:	ed2d 8b10 	vpush	{d8-d15}
    c7b8:	f04f 0500 	mov.w	r5, #0
    c7bc:	ec45 5b18 	vmov	d8, r5, r5
    c7c0:	ec45 5a19 	vmov	s18, s19, r5, r5
    c7c4:	ec45 5a1a 	vmov	s20, s21, r5, r5
    c7c8:	ec45 5a1b 	vmov	s22, s23, r5, r5
    c7cc:	ec45 5a1c 	vmov	s24, s25, r5, r5
    c7d0:	ec45 5a1d 	vmov	s26, s27, r5, r5
    c7d4:	ec45 5a1e 	vmov	s28, s29, r5, r5
    c7d8:	ec45 5a1f 	vmov	s30, s31, r5, r5
    c7dc:	eef1 5a10 	vmrs	r5, fpscr
    c7e0:	f64f 7660 	movw	r6, #65376	; 0xff60
    c7e4:	f6c0 76ff 	movt	r6, #4095	; 0xfff
    c7e8:	4035      	ands	r5, r6
    c7ea:	eee1 5a10 	vmsr	fpscr, r5
    c7ee:	f384 8800 	msr	CPSR_f, r4
    c7f2:	4625      	mov	r5, r4
    c7f4:	4626      	mov	r6, r4
    c7f6:	47a4      	blxns	r4
    c7f8:	ecbd 8b10 	vpop	{d8-d15}
    c7fc:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0000c800 <tz_nonsecure_state_setup>:
}
#endif /* CONFIG_ARMV8_M_MAINLINE */

void tz_nonsecure_state_setup(const tz_nonsecure_setup_conf_t *p_ns_conf)
{
	configure_nonsecure_vtor_offset(p_ns_conf->vtor_ns);
    c800:	6882      	ldr	r2, [r0, #8]
	SCB_NS->VTOR = vtor_ns;
    c802:	4b0c      	ldr	r3, [pc, #48]	; (c834 <tz_nonsecure_state_setup+0x34>)
    c804:	609a      	str	r2, [r3, #8]
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
    c806:	6803      	ldr	r3, [r0, #0]
    c808:	f383 8888 	msr	MSP_NS, r3
  __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
    c80c:	6843      	ldr	r3, [r0, #4]
    c80e:	f383 8889 	msr	PSP_NS, r3
	configure_nonsecure_psp(p_ns_conf->psp_ns);
	/* Select which stack-pointer to use (MSP or PSP) and
	 * the privilege level for thread mode.
	 */
	configure_nonsecure_control(p_ns_conf->control_ns.spsel,
		p_ns_conf->control_ns.npriv);
    c812:	7b02      	ldrb	r2, [r0, #12]
    c814:	f002 0101 	and.w	r1, r2, #1
  __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
    c818:	f3ef 8394 	mrs	r3, CONTROL_NS
	control_ns &= ~(CONTROL_SPSEL_Msk | CONTROL_nPRIV_Msk);
    c81c:	f023 0303 	bic.w	r3, r3, #3
	if (spsel_ns) {
    c820:	0792      	lsls	r2, r2, #30
		control_ns |= CONTROL_SPSEL_Msk;
    c822:	bf48      	it	mi
    c824:	f043 0302 	orrmi.w	r3, r3, #2
	if (npriv_ns) {
    c828:	b109      	cbz	r1, c82e <tz_nonsecure_state_setup+0x2e>
		control_ns |= CONTROL_nPRIV_Msk;
    c82a:	f043 0301 	orr.w	r3, r3, #1
  __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
    c82e:	f383 8894 	msr	CONTROL_NS, r3
}
    c832:	4770      	bx	lr
    c834:	e002ed00 	.word	0xe002ed00

0000c838 <tz_nbanked_exception_target_state_set>:

void tz_nbanked_exception_target_state_set(int secure_state)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c838:	4a08      	ldr	r2, [pc, #32]	; (c85c <tz_nbanked_exception_target_state_set+0x24>)
    c83a:	68d3      	ldr	r3, [r2, #12]
	if (secure_state) {
    c83c:	b148      	cbz	r0, c852 <tz_nbanked_exception_target_state_set+0x1a>
		aircr_payload &= ~(SCB_AIRCR_BFHFNMINS_Msk);
    c83e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    c842:	041b      	lsls	r3, r3, #16
    c844:	0c1b      	lsrs	r3, r3, #16
	} else {
		aircr_payload |= SCB_AIRCR_BFHFNMINS_Msk;
	}
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c846:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c84a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
    c84e:	60d3      	str	r3, [r2, #12]
}
    c850:	4770      	bx	lr
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c852:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_BFHFNMINS_Msk;
    c854:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    c858:	e7f5      	b.n	c846 <tz_nbanked_exception_target_state_set+0xe>
    c85a:	bf00      	nop
    c85c:	e000ed00 	.word	0xe000ed00

0000c860 <tz_nonsecure_exception_prio_config>:

void tz_nonsecure_exception_prio_config(int secure_boost)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c860:	4a08      	ldr	r2, [pc, #32]	; (c884 <tz_nonsecure_exception_prio_config+0x24>)
    c862:	68d3      	ldr	r3, [r2, #12]
	if (secure_boost) {
    c864:	b140      	cbz	r0, c878 <tz_nonsecure_exception_prio_config+0x18>
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c866:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_PRIS_Msk;
    c868:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
	} else {
		aircr_payload &= ~(SCB_AIRCR_PRIS_Msk);
	}
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c86c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c870:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
    c874:	60d3      	str	r3, [r2, #12]
}
    c876:	4770      	bx	lr
		aircr_payload &= ~(SCB_AIRCR_PRIS_Msk);
    c878:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    c87c:	041b      	lsls	r3, r3, #16
    c87e:	0c1b      	lsrs	r3, r3, #16
    c880:	e7f4      	b.n	c86c <tz_nonsecure_exception_prio_config+0xc>
    c882:	bf00      	nop
    c884:	e000ed00 	.word	0xe000ed00

0000c888 <tz_nonsecure_system_reset_req_block>:

void tz_nonsecure_system_reset_req_block(int block)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c888:	4a08      	ldr	r2, [pc, #32]	; (c8ac <tz_nonsecure_system_reset_req_block+0x24>)
    c88a:	68d3      	ldr	r3, [r2, #12]
	if (block) {
    c88c:	b140      	cbz	r0, c8a0 <tz_nonsecure_system_reset_req_block+0x18>
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c88e:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_SYSRESETREQS_Msk;
    c890:	f043 0308 	orr.w	r3, r3, #8
	} else {
		aircr_payload &= ~(SCB_AIRCR_SYSRESETREQS_Msk);
	}
	SCB->AIRCR = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c894:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c898:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)
    c89c:	60d3      	str	r3, [r2, #12]
}
    c89e:	4770      	bx	lr
		aircr_payload &= ~(SCB_AIRCR_SYSRESETREQS_Msk);
    c8a0:	f023 0308 	bic.w	r3, r3, #8
    c8a4:	041b      	lsls	r3, r3, #16
    c8a6:	0c1b      	lsrs	r3, r3, #16
    c8a8:	e7f4      	b.n	c894 <tz_nonsecure_system_reset_req_block+0xc>
    c8aa:	bf00      	nop
    c8ac:	e000ed00 	.word	0xe000ed00

0000c8b0 <tz_nonsecure_fpu_access_enable>:

#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
void tz_nonsecure_fpu_access_enable(void)
{
	SCB->NSACR |=
    c8b0:	4a03      	ldr	r2, [pc, #12]	; (c8c0 <tz_nonsecure_fpu_access_enable+0x10>)
    c8b2:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    c8b6:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    c8ba:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
		(1UL << SCB_NSACR_CP10_Pos) | (1UL << SCB_NSACR_CP11_Pos);
}
    c8be:	4770      	bx	lr
    c8c0:	e000ed00 	.word	0xe000ed00

0000c8c4 <tz_sau_configure>:
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

void tz_sau_configure(int enable, int allns)
{
    c8c4:	4b08      	ldr	r3, [pc, #32]	; (c8e8 <tz_sau_configure+0x24>)
  \brief   Enable SAU
  \details Enables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Enable(void)
{
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
    c8c6:	681a      	ldr	r2, [r3, #0]
	if (enable) {
    c8c8:	b118      	cbz	r0, c8d2 <tz_sau_configure+0xe>
    c8ca:	f042 0201 	orr.w	r2, r2, #1
	} else {
		TZ_SAU_Disable();
		if (allns) {
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
		} else {
			SAU->CTRL &= ~(SAU_CTRL_ALLNS_Msk);
    c8ce:	601a      	str	r2, [r3, #0]
		}
	}
}
    c8d0:	4770      	bx	lr
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
    c8d2:	f022 0201 	bic.w	r2, r2, #1
    c8d6:	601a      	str	r2, [r3, #0]
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
    c8d8:	681a      	ldr	r2, [r3, #0]
		if (allns) {
    c8da:	b111      	cbz	r1, c8e2 <tz_sau_configure+0x1e>
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
    c8dc:	f042 0202 	orr.w	r2, r2, #2
    c8e0:	e7f5      	b.n	c8ce <tz_sau_configure+0xa>
			SAU->CTRL &= ~(SAU_CTRL_ALLNS_Msk);
    c8e2:	f022 0202 	bic.w	r2, r2, #2
    c8e6:	e7f2      	b.n	c8ce <tz_sau_configure+0xa>
    c8e8:	e000edd0 	.word	0xe000edd0

0000c8ec <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    c8ec:	680b      	ldr	r3, [r1, #0]
    c8ee:	3301      	adds	r3, #1
    c8f0:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    c8f2:	4b01      	ldr	r3, [pc, #4]	; (c8f8 <char_out+0xc>)
    c8f4:	681b      	ldr	r3, [r3, #0]
    c8f6:	4718      	bx	r3
    c8f8:	200013d4 	.word	0x200013d4

0000c8fc <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    c8fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c900:	b085      	sub	sp, #20
    c902:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    c904:	469b      	mov	fp, r3
    c906:	2c01      	cmp	r4, #1
    c908:	bfb8      	it	lt
    c90a:	2401      	movlt	r4, #1
    c90c:	2b01      	cmp	r3, #1
    c90e:	bf0c      	ite	eq
    c910:	2330      	moveq	r3, #48	; 0x30
    c912:	2320      	movne	r3, #32
    c914:	4616      	mov	r6, r2
    c916:	4682      	mov	sl, r0
    c918:	4688      	mov	r8, r1
    c91a:	2501      	movs	r5, #1
    c91c:	270a      	movs	r7, #10
    c91e:	2200      	movs	r2, #0
    c920:	f8df 906c 	ldr.w	r9, [pc, #108]	; c990 <_printk_dec_ulong+0x94>
    c924:	9302      	str	r3, [sp, #8]
    c926:	fbb6 f3f9 	udiv	r3, r6, r9
    c92a:	9301      	str	r3, [sp, #4]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    c92c:	b90a      	cbnz	r2, c932 <_printk_dec_ulong+0x36>
    c92e:	45b1      	cmp	r9, r6
    c930:	d81c      	bhi.n	c96c <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    c932:	9b01      	ldr	r3, [sp, #4]
    c934:	4641      	mov	r1, r8
    c936:	f103 0030 	add.w	r0, r3, #48	; 0x30
    c93a:	47d0      	blx	sl
			found_largest_digit = 1;
    c93c:	2201      	movs	r2, #1
			digits++;
    c93e:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    c940:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    c942:	3f01      	subs	r7, #1
		remainder %= pos;
    c944:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
    c948:	230a      	movs	r3, #10
	while (pos >= 10) {
    c94a:	2f01      	cmp	r7, #1
		pos /= 10;
    c94c:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    c950:	d1e9      	bne.n	c926 <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
    c952:	4641      	mov	r1, r8
    c954:	f106 0030 	add.w	r0, r6, #48	; 0x30
    c958:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
    c95a:	f1bb 0f03 	cmp.w	fp, #3
    c95e:	d102      	bne.n	c966 <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
    c960:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
    c962:	2c00      	cmp	r4, #0
    c964:	dc0e      	bgt.n	c984 <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
    c966:	b005      	add	sp, #20
    c968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    c96c:	42bc      	cmp	r4, r7
    c96e:	dbe7      	blt.n	c940 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    c970:	f1bb 0f02 	cmp.w	fp, #2
    c974:	d8e4      	bhi.n	c940 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c976:	4641      	mov	r1, r8
    c978:	9802      	ldr	r0, [sp, #8]
    c97a:	9203      	str	r2, [sp, #12]
			digits++;
    c97c:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c97e:	47d0      	blx	sl
			digits++;
    c980:	9a03      	ldr	r2, [sp, #12]
    c982:	e7dd      	b.n	c940 <_printk_dec_ulong+0x44>
			out(' ', ctx);
    c984:	4641      	mov	r1, r8
    c986:	2020      	movs	r0, #32
    c988:	47d0      	blx	sl
    c98a:	3c01      	subs	r4, #1
    c98c:	e7e9      	b.n	c962 <_printk_dec_ulong+0x66>
    c98e:	bf00      	nop
    c990:	3b9aca00 	.word	0x3b9aca00

0000c994 <__printk_hook_install>:
	_char_out = fn;
    c994:	4b01      	ldr	r3, [pc, #4]	; (c99c <__printk_hook_install+0x8>)
    c996:	6018      	str	r0, [r3, #0]
}
    c998:	4770      	bx	lr
    c99a:	bf00      	nop
    c99c:	200013d4 	.word	0x200013d4

0000c9a0 <vprintk>:
	struct out_context ctx = { 0 };
    c9a0:	2300      	movs	r3, #0
{
    c9a2:	b513      	push	{r0, r1, r4, lr}
	struct out_context ctx = { 0 };
    c9a4:	ac02      	add	r4, sp, #8
    c9a6:	f844 3d04 	str.w	r3, [r4, #-4]!
	z_vprintk(char_out, &ctx, fmt, ap);
    c9aa:	4602      	mov	r2, r0
    c9ac:	460b      	mov	r3, r1
    c9ae:	4803      	ldr	r0, [pc, #12]	; (c9bc <vprintk+0x1c>)
    c9b0:	4621      	mov	r1, r4
    c9b2:	f002 ff7b 	bl	f8ac <z_vprintk>
}
    c9b6:	b002      	add	sp, #8
    c9b8:	bd10      	pop	{r4, pc}
    c9ba:	bf00      	nop
    c9bc:	0000c8ed 	.word	0x0000c8ed

0000c9c0 <nordicsemi_nrf91_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    c9c0:	f04f 0220 	mov.w	r2, #32
    c9c4:	f3ef 8311 	mrs	r3, BASEPRI
    c9c8:	f382 8811 	msr	BASEPRI, r2
    c9cc:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    c9d0:	2101      	movs	r1, #1
    c9d2:	4a04      	ldr	r2, [pc, #16]	; (c9e4 <nordicsemi_nrf91_init+0x24>)
    c9d4:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    c9d8:	f383 8811 	msr	BASEPRI, r3
    c9dc:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    c9e0:	2000      	movs	r0, #0
    c9e2:	4770      	bx	lr
    c9e4:	50039000 	.word	0x50039000

0000c9e8 <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    c9e8:	280a      	cmp	r0, #10
{
    c9ea:	b538      	push	{r3, r4, r5, lr}
    c9ec:	4604      	mov	r4, r0
    c9ee:	4d07      	ldr	r5, [pc, #28]	; (ca0c <console_out+0x24>)
	if ('\n' == c) {
    c9f0:	d104      	bne.n	c9fc <console_out+0x14>
    c9f2:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    c9f4:	6843      	ldr	r3, [r0, #4]
    c9f6:	210d      	movs	r1, #13
    c9f8:	685b      	ldr	r3, [r3, #4]
    c9fa:	4798      	blx	r3
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    c9fc:	6828      	ldr	r0, [r5, #0]
    c9fe:	6843      	ldr	r3, [r0, #4]
    ca00:	b2e1      	uxtb	r1, r4
    ca02:	685b      	ldr	r3, [r3, #4]
    ca04:	4798      	blx	r3

	return c;
}
    ca06:	4620      	mov	r0, r4
    ca08:	bd38      	pop	{r3, r4, r5, pc}
    ca0a:	bf00      	nop
    ca0c:	20000008 	.word	0x20000008

0000ca10 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    ca10:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    ca12:	4c04      	ldr	r4, [pc, #16]	; (ca24 <uart_console_hook_install+0x14>)
    ca14:	4620      	mov	r0, r4
    ca16:	f001 f821 	bl	da5c <__stdout_hook_install>
	__printk_hook_install(console_out);
    ca1a:	4620      	mov	r0, r4
}
    ca1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
    ca20:	f7ff bfb8 	b.w	c994 <__printk_hook_install>
    ca24:	0000c9e9 	.word	0x0000c9e9

0000ca28 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    ca28:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (struct device *) z_arch_syscall_invoke1(*(u32_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    ca2a:	4804      	ldr	r0, [pc, #16]	; (ca3c <uart_console_init+0x14>)
    ca2c:	f001 fa06 	bl	de3c <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    ca30:	4b03      	ldr	r3, [pc, #12]	; (ca40 <uart_console_init+0x18>)
    ca32:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    ca34:	f7ff ffec 	bl	ca10 <uart_console_hook_install>

	return 0;
}
    ca38:	2000      	movs	r0, #0
    ca3a:	bd08      	pop	{r3, pc}
    ca3c:	000108d3 	.word	0x000108d3
    ca40:	20000008 	.word	0x20000008

0000ca44 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    ca44:	b508      	push	{r3, lr}
#endif
}

__STATIC_INLINE bool nrf_clock_event_check(nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
    ca46:	4b11      	ldr	r3, [pc, #68]	; (ca8c <nrf_power_clock_isr+0x48>)
    ca48:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(evt) &&
    ca4a:	b16a      	cbz	r2, ca68 <nrf_power_clock_isr+0x24>
    return (bool)(NRF_CLOCK->INTENCLR & int_mask);
    ca4c:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    ca50:	f8d2 2308 	ldr.w	r2, [r2, #776]	; 0x308
	if (ret) {
    ca54:	07d1      	lsls	r1, r2, #31
    ca56:	d507      	bpl.n	ca68 <nrf_power_clock_isr+0x24>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    ca58:	2200      	movs	r2, #0
	ARG_UNUSED(arg);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct device *hfclk_dev = DEVICE_GET(clock_nrf5_m16src);
		struct nrf_clock_control *data = hfclk_dev->driver_data;
    ca5a:	480d      	ldr	r0, [pc, #52]	; (ca90 <nrf_power_clock_isr+0x4c>)
    ca5c:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    ca5e:	6883      	ldr	r3, [r0, #8]
    ca60:	7a5b      	ldrb	r3, [r3, #9]
    ca62:	b90b      	cbnz	r3, ca68 <nrf_power_clock_isr+0x24>
			clkstarted_handle(hfclk_dev);
    ca64:	f003 f94c 	bl	fd00 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
    ca68:	4b0a      	ldr	r3, [pc, #40]	; (ca94 <nrf_power_clock_isr+0x50>)
    ca6a:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(evt) &&
    ca6c:	b162      	cbz	r2, ca88 <nrf_power_clock_isr+0x44>
    return (bool)(NRF_CLOCK->INTENCLR & int_mask);
    ca6e:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    ca72:	f8d2 2308 	ldr.w	r2, [r2, #776]	; 0x308
	if (ret) {
    ca76:	0792      	lsls	r2, r2, #30
    ca78:	d506      	bpl.n	ca88 <nrf_power_clock_isr+0x44>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    ca7a:	2200      	movs	r2, #0

		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(lfclk_dev);
		}
		clkstarted_handle(lfclk_dev);
    ca7c:	4806      	ldr	r0, [pc, #24]	; (ca98 <nrf_power_clock_isr+0x54>)
    ca7e:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    ca80:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(lfclk_dev);
    ca84:	f003 b93c 	b.w	fd00 <clkstarted_handle>
}
    ca88:	bd08      	pop	{r3, pc}
    ca8a:	bf00      	nop
    ca8c:	50005100 	.word	0x50005100
    ca90:	20001484 	.word	0x20001484
    ca94:	50005104 	.word	0x50005104
    ca98:	20001490 	.word	0x20001490

0000ca9c <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    ca9c:	2200      	movs	r2, #0
    ca9e:	4b0d      	ldr	r3, [pc, #52]	; (cad4 <rtc1_nrf_isr+0x38>)
    caa0:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    caa4:	f04f 0220 	mov.w	r2, #32
    caa8:	f3ef 8111 	mrs	r1, BASEPRI
    caac:	f382 8811 	msr	BASEPRI, r2
    cab0:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    cab4:	4a08      	ldr	r2, [pc, #32]	; (cad8 <rtc1_nrf_isr+0x3c>)
#endif
}

__STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type * p_reg)
{
     return p_reg->COUNTER;
    cab6:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    caba:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    cabc:	1ac0      	subs	r0, r0, r3
    cabe:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    cac2:	4403      	add	r3, r0
    cac4:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    cac6:	f381 8811 	msr	BASEPRI, r1
    caca:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    cace:	f001 bf35 	b.w	e93c <z_clock_announce>
    cad2:	bf00      	nop
    cad4:	50015000 	.word	0x50015000
    cad8:	20000024 	.word	0x20000024

0000cadc <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    cadc:	b570      	push	{r4, r5, r6, lr}
    cade:	4818      	ldr	r0, [pc, #96]	; (cb40 <z_clock_driver_init+0x64>)
    cae0:	f001 f9ac 	bl	de3c <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL "_32K");
	if (!clock) {
    cae4:	b348      	cbz	r0, cb3a <z_clock_driver_init+0x5e>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    cae6:	6843      	ldr	r3, [r0, #4]
    cae8:	2100      	movs	r1, #0
    caea:	681b      	ldr	r3, [r3, #0]
    caec:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
    caee:	2601      	movs	r6, #1
}

__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    caf0:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    caf2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    caf6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
    cafa:	4d12      	ldr	r5, [pc, #72]	; (cb44 <z_clock_driver_init+0x68>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    cafc:	4631      	mov	r1, r6
    cafe:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    cb02:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    cb06:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    cb0a:	4b0f      	ldr	r3, [pc, #60]	; (cb48 <z_clock_driver_init+0x6c>)
    cb0c:	2015      	movs	r0, #21
    cb0e:	601c      	str	r4, [r3, #0]
    cb10:	4b0e      	ldr	r3, [pc, #56]	; (cb4c <z_clock_driver_init+0x70>)
    cb12:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    cb16:	4622      	mov	r2, r4
    cb18:	f000 fc56 	bl	d3c8 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    cb1c:	2015      	movs	r0, #21
    cb1e:	f000 fc43 	bl	d3a8 <z_arch_irq_enable>

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    cb22:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

__STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    cb24:	4b0a      	ldr	r3, [pc, #40]	; (cb50 <z_clock_driver_init+0x74>)
    cb26:	601e      	str	r6, [r3, #0]
    cb28:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
    cb2a:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504
		set_comparator(counter() + CYC_PER_TICK);
    cb2e:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    cb30:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    cb34:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
}
    cb38:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    cb3a:	f04f 30ff 	mov.w	r0, #4294967295
    cb3e:	e7fb      	b.n	cb38 <z_clock_driver_init+0x5c>
    cb40:	000108da 	.word	0x000108da
    cb44:	50015000 	.word	0x50015000
    cb48:	50015140 	.word	0x50015140
    cb4c:	e000e100 	.word	0xe000e100
    cb50:	50015008 	.word	0x50015008

0000cb54 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    cb54:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    cb56:	4e21      	ldr	r6, [pc, #132]	; (cbdc <z_clock_set_timeout+0x88>)
    cb58:	f1b0 3fff 	cmp.w	r0, #4294967295
    cb5c:	bf08      	it	eq
    cb5e:	4630      	moveq	r0, r6
	__asm__ volatile(
    cb60:	f04f 0320 	mov.w	r3, #32
    cb64:	f3ef 8411 	mrs	r4, BASEPRI
    cb68:	f383 8811 	msr	BASEPRI, r3
    cb6c:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    cb70:	491b      	ldr	r1, [pc, #108]	; (cbe0 <z_clock_set_timeout+0x8c>)
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	bool zli_fixup = IS_ENABLED(CONFIG_ZERO_LATENCY_IRQS);

	/* Round up to next tick boundary */
	cyc = ticks * CYC_PER_TICK + 1 + counter_sub(t, last_count);
    cb72:	4b1c      	ldr	r3, [pc, #112]	; (cbe4 <z_clock_set_timeout+0x90>)
    cb74:	f8d1 2504 	ldr.w	r2, [r1, #1284]	; 0x504
    cb78:	681d      	ldr	r5, [r3, #0]
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    cb7a:	3801      	subs	r0, #1
	return (a - b) & COUNTER_MAX;
    cb7c:	1b53      	subs	r3, r2, r5
    cb7e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	cyc += (CYC_PER_TICK - 1);
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
	cyc += last_count;
    cb82:	3501      	adds	r5, #1
    cb84:	442b      	add	r3, r5
	cyc = ticks * CYC_PER_TICK + 1 + counter_sub(t, last_count);
    cb86:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	cyc += last_count;
    cb8a:	42b0      	cmp	r0, r6
    cb8c:	bfd4      	ite	le
    cb8e:	1818      	addle	r0, r3, r0
    cb90:	1998      	addgt	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    cb92:	1a82      	subs	r2, r0, r2
    cb94:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    cb98:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    cb9c:	2a02      	cmp	r2, #2
    p_reg->CC[ch] = cc_val;
    cb9e:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    cba2:	d904      	bls.n	cbae <z_clock_set_timeout+0x5a>
	__asm__ volatile(
    cba4:	f384 8811 	msr	BASEPRI, r4
    cba8:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    cbac:	bd70      	pop	{r4, r5, r6, pc}
     return p_reg->COUNTER;
    cbae:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    cbb2:	4a0d      	ldr	r2, [pc, #52]	; (cbe8 <z_clock_set_timeout+0x94>)
	return (a - b) & COUNTER_MAX;
    cbb4:	1ac3      	subs	r3, r0, r3
    cbb6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    cbba:	1e5d      	subs	r5, r3, #1
    cbbc:	4295      	cmp	r5, r2
    cbbe:	d905      	bls.n	cbcc <z_clock_set_timeout+0x78>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cbc0:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    cbc4:	4b09      	ldr	r3, [pc, #36]	; (cbec <z_clock_set_timeout+0x98>)
    cbc6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    cbca:	e7eb      	b.n	cba4 <z_clock_set_timeout+0x50>
		} else if (dt == 1) {
    cbcc:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    cbce:	bf02      	ittt	eq
    cbd0:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    cbd2:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    cbd6:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    cbda:	e7e3      	b.n	cba4 <z_clock_set_timeout+0x50>
    cbdc:	00fffffe 	.word	0x00fffffe
    cbe0:	50015000 	.word	0x50015000
    cbe4:	20000024 	.word	0x20000024
    cbe8:	007ffffe 	.word	0x007ffffe
    cbec:	e000e100 	.word	0xe000e100

0000cbf0 <z_clock_elapsed>:
	__asm__ volatile(
    cbf0:	f04f 0220 	mov.w	r2, #32
    cbf4:	f3ef 8311 	mrs	r3, BASEPRI
    cbf8:	f382 8811 	msr	BASEPRI, r2
    cbfc:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    cc00:	4a06      	ldr	r2, [pc, #24]	; (cc1c <z_clock_elapsed+0x2c>)
    cc02:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    cc06:	4a06      	ldr	r2, [pc, #24]	; (cc20 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    cc08:	6812      	ldr	r2, [r2, #0]
    cc0a:	1a80      	subs	r0, r0, r2
    cc0c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    cc10:	f383 8811 	msr	BASEPRI, r3
    cc14:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    cc18:	4770      	bx	lr
    cc1a:	bf00      	nop
    cc1c:	50015000 	.word	0x50015000
    cc20:	20000024 	.word	0x20000024

0000cc24 <spm_config_peripheral.constprop.1>:
		     SPU_PERIPHID_PERM_SECUREMAPPING_Split;

	return present && (usel || split);
}

static int spm_config_peripheral(u8_t id, bool dma_present)
    cc24:	b508      	push	{r3, lr}
	 * Assign DMA capabilities and lock down the attribution.
	 *
	 * Note: the function assumes that the peripheral ID matches
	 * the IRQ line.
	 */
	NVIC_DisableIRQ(id);
    cc26:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    cc28:	2b00      	cmp	r3, #0
    cc2a:	db0c      	blt.n	cc46 <spm_config_peripheral.constprop.1+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cc2c:	2201      	movs	r2, #1
    cc2e:	f000 011f 	and.w	r1, r0, #31
    cc32:	408a      	lsls	r2, r1
    cc34:	095b      	lsrs	r3, r3, #5
    cc36:	4910      	ldr	r1, [pc, #64]	; (cc78 <spm_config_peripheral.constprop.1+0x54>)
    cc38:	3320      	adds	r3, #32
    cc3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    cc3e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    cc42:	f3bf 8f6f 	isb	sy
    cc46:	0083      	lsls	r3, r0, #2
    cc48:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    cc4c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
	if (id == NRFX_PERIPHERAL_ID_GET(NRF_GPIOTE1_NS)) {
    cc50:	2831      	cmp	r0, #49	; 0x31
	const u32_t perm = NRF_SPU->PERIPHID[id].PERM;
    cc52:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
	if (id == NRFX_PERIPHERAL_ID_GET(NRF_GPIOTE1_NS)) {
    cc56:	d006      	beq.n	cc66 <spm_config_peripheral.constprop.1+0x42>
	return present && (usel || split);
    cc58:	2a00      	cmp	r2, #0
    cc5a:	da07      	bge.n	cc6c <spm_config_peripheral.constprop.1+0x48>
	bool usel = (perm & SPU_PERIPHID_PERM_SECUREMAPPING_Msk) ==
    cc5c:	f002 0203 	and.w	r2, r2, #3
	return present && (usel || split);
    cc60:	3a02      	subs	r2, #2

	if (usel_or_split(id)) {
    cc62:	2a01      	cmp	r2, #1
    cc64:	d802      	bhi.n	cc6c <spm_config_peripheral.constprop.1+0x48>
		NRF_SPU->PERIPHID[id].PERM = PERIPH_PRESENT | PERIPH_NONSEC |
    cc66:	4a05      	ldr	r2, [pc, #20]	; (cc7c <spm_config_peripheral.constprop.1+0x58>)
    cc68:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	}

	/* Even for non-present peripherals we force IRQs to be routed
	 * to Non-Secure state.
	 */
	irq_target_state_set(id, 0);
    cc6c:	2100      	movs	r1, #0
    cc6e:	f003 f8b4 	bl	fdda <irq_target_state_set>
	return 0;
}
    cc72:	2000      	movs	r0, #0
    cc74:	bd08      	pop	{r3, pc}
    cc76:	bf00      	nop
    cc78:	e000e100 	.word	0xe000e100
    cc7c:	80000100 	.word	0x80000100

0000cc80 <spm_jump>:
	tz_nonsecure_fpu_access_enable();
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */
}

void spm_jump(void)
{
    cc80:	b530      	push	{r4, r5, lr}
	 * The assumption is that the MSP is located at VTOR_NS[0].
	 */
	u32_t *vtor_ns = (u32_t *)NON_SECURE_APP_ADDRESS;

	PRINT("SPM: NS image at 0x%x\n", (u32_t)vtor_ns);
	PRINT("SPM: NS MSP at 0x%x\n", vtor_ns[0]);
    cc82:	f44f 34c1 	mov.w	r4, #98816	; 0x18200
{
    cc86:	b085      	sub	sp, #20
	PRINT("SPM: NS reset vector at 0x%x\n", vtor_ns[1]);
    cc88:	4d2e      	ldr	r5, [pc, #184]	; (cd44 <spm_jump+0xc4>)
	PRINT("SPM: NS image at 0x%x\n", (u32_t)vtor_ns);
    cc8a:	f44f 31c1 	mov.w	r1, #98816	; 0x18200
    cc8e:	482e      	ldr	r0, [pc, #184]	; (cd48 <spm_jump+0xc8>)
    cc90:	f002 ff82 	bl	fb98 <printk>
	PRINT("SPM: NS MSP at 0x%x\n", vtor_ns[0]);
    cc94:	6821      	ldr	r1, [r4, #0]
    cc96:	482d      	ldr	r0, [pc, #180]	; (cd4c <spm_jump+0xcc>)
    cc98:	f002 ff7e 	bl	fb98 <printk>
	PRINT("SPM: NS reset vector at 0x%x\n", vtor_ns[1]);
    cc9c:	6829      	ldr	r1, [r5, #0]
    cc9e:	482c      	ldr	r0, [pc, #176]	; (cd50 <spm_jump+0xd0>)
    cca0:	f002 ff7a 	bl	fb98 <printk>

	/* Configure Non-Secure stack */
	tz_nonsecure_setup_conf_t spm_ns_conf = {
    cca4:	2210      	movs	r2, #16
    cca6:	2100      	movs	r1, #0
    cca8:	4668      	mov	r0, sp
    ccaa:	f003 f947 	bl	ff3c <memset>
		.vtor_ns = (u32_t)vtor_ns,
		.msp_ns = vtor_ns[0],
    ccae:	6823      	ldr	r3, [r4, #0]
	tz_nonsecure_state_setup(spm_ns_conf);
    ccb0:	4668      	mov	r0, sp
	tz_nonsecure_setup_conf_t spm_ns_conf = {
    ccb2:	9300      	str	r3, [sp, #0]
    ccb4:	9402      	str	r4, [sp, #8]
	tz_nonsecure_state_setup(spm_ns_conf);
    ccb6:	f7ff fda3 	bl	c800 <tz_nonsecure_state_setup>
	tz_nonsecure_exception_prio_config(1);
    ccba:	2001      	movs	r0, #1
    ccbc:	f7ff fdd0 	bl	c860 <tz_nonsecure_exception_prio_config>
	tz_nbanked_exception_target_state_set(0);
    ccc0:	2000      	movs	r0, #0
    ccc2:	f7ff fdb9 	bl	c838 <tz_nbanked_exception_target_state_set>
	tz_nonsecure_system_reset_req_block(
    ccc6:	2000      	movs	r0, #0
    ccc8:	f7ff fdde 	bl	c888 <tz_nonsecure_system_reset_req_block>
	tz_sau_configure(0, 1);
    cccc:	2101      	movs	r1, #1
    ccce:	2000      	movs	r0, #0
    ccd0:	f7ff fdf8 	bl	c8c4 <tz_sau_configure>
	tz_nonsecure_fpu_access_enable();
    ccd4:	f7ff fdec 	bl	c8b0 <tz_nonsecure_fpu_access_enable>

	spm_configure_ns(&spm_ns_conf);

	/* Generate function pointer for Non-Secure function call. */
	TZ_NONSECURE_FUNC_PTR_DECLARE(reset_ns);
	reset_ns = TZ_NONSECURE_FUNC_PTR_CREATE(vtor_ns[1]);
    ccd8:	682c      	ldr	r4, [r5, #0]

	if (TZ_NONSECURE_FUNC_PTR_IS_NS(reset_ns)) {
		PRINT("SPM: prepare to jump to Non-Secure image.\n");
    ccda:	481e      	ldr	r0, [pc, #120]	; (cd54 <spm_jump+0xd4>)
    ccdc:	f002 ff5c 	bl	fb98 <printk>
		/* Note: Move UARTE0 before jumping, if it is
		 * to be used on the Non-Secure domain.
		 */

		/* Configure UARTE0 as non-secure */
		spm_config_peripheral(
    cce0:	2008      	movs	r0, #8
    cce2:	f7ff ff9f 	bl	cc24 <spm_config_peripheral.constprop.1>
	reset_ns = TZ_NONSECURE_FUNC_PTR_CREATE(vtor_ns[1]);
    cce6:	f024 0401 	bic.w	r4, r4, #1
  __ASM volatile ("dsb 0xF":::"memory");
    ccea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    ccee:	f3bf 8f6f 	isb	sy

		__DSB();
		__ISB();

		/* Jump to Non-Secure firmware */
		reset_ns();
    ccf2:	0864      	lsrs	r4, r4, #1
    ccf4:	0064      	lsls	r4, r4, #1
    ccf6:	4620      	mov	r0, r4
    ccf8:	4621      	mov	r1, r4
    ccfa:	4622      	mov	r2, r4
    ccfc:	4623      	mov	r3, r4
    ccfe:	ed9f 0a16 	vldr	s0, [pc, #88]	; cd58 <spm_jump+0xd8>
    cd02:	eddf 0a15 	vldr	s1, [pc, #84]	; cd58 <spm_jump+0xd8>
    cd06:	ed9f 1a14 	vldr	s2, [pc, #80]	; cd58 <spm_jump+0xd8>
    cd0a:	eddf 1a13 	vldr	s3, [pc, #76]	; cd58 <spm_jump+0xd8>
    cd0e:	ed9f 2a12 	vldr	s4, [pc, #72]	; cd58 <spm_jump+0xd8>
    cd12:	eddf 2a11 	vldr	s5, [pc, #68]	; cd58 <spm_jump+0xd8>
    cd16:	ed9f 3a10 	vldr	s6, [pc, #64]	; cd58 <spm_jump+0xd8>
    cd1a:	eddf 3a0f 	vldr	s7, [pc, #60]	; cd58 <spm_jump+0xd8>
    cd1e:	ed9f 4a0e 	vldr	s8, [pc, #56]	; cd58 <spm_jump+0xd8>
    cd22:	eddf 4a0d 	vldr	s9, [pc, #52]	; cd58 <spm_jump+0xd8>
    cd26:	ed9f 5a0c 	vldr	s10, [pc, #48]	; cd58 <spm_jump+0xd8>
    cd2a:	eddf 5a0b 	vldr	s11, [pc, #44]	; cd58 <spm_jump+0xd8>
    cd2e:	ed9f 6a0a 	vldr	s12, [pc, #40]	; cd58 <spm_jump+0xd8>
    cd32:	eddf 6a09 	vldr	s13, [pc, #36]	; cd58 <spm_jump+0xd8>
    cd36:	ed9f 7a08 	vldr	s14, [pc, #32]	; cd58 <spm_jump+0xd8>
    cd3a:	eddf 7a07 	vldr	s15, [pc, #28]	; cd58 <spm_jump+0xd8>
    cd3e:	f7ff fd31 	bl	c7a4 <__gnu_cmse_nonsecure_call>
    cd42:	bf00      	nop
    cd44:	00018204 	.word	0x00018204
    cd48:	00010a3c 	.word	0x00010a3c
    cd4c:	00010a53 	.word	0x00010a53
    cd50:	00010a68 	.word	0x00010a68
    cd54:	00010a86 	.word	0x00010a86
    cd58:	00000000 	.word	0x00000000

0000cd5c <spm_config>:
		      (u32_t)reset_ns);
	}
}

void spm_config(void)
{
    cd5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	PRINT("Flash region\t\tDomain\t\tPermissions\n");
    cd60:	486f      	ldr	r0, [pc, #444]	; (cf20 <spm_config+0x1c4>)
    cd62:	f002 ff19 	bl	fb98 <printk>
	for (size_t i = 0; i < ARRAY_SIZE(flash_perm); i++) {
    cd66:	2100      	movs	r1, #0
		NRF_SPU->FLASHREGION[i].PERM = flash_perm[i];
    cd68:	f8df 8200 	ldr.w	r8, [pc, #512]	; cf6c <spm_config+0x210>
    cd6c:	4f6d      	ldr	r7, [pc, #436]	; (cf24 <spm_config+0x1c8>)
		PRINT("%c", flash_perm[i] & FLASH_READ  ? 'r' : '-');
    cd6e:	4d6e      	ldr	r5, [pc, #440]	; (cf28 <spm_config+0x1cc>)
		NRF_SPU->FLASHREGION[i].PERM = flash_perm[i];
    cd70:	f858 4021 	ldr.w	r4, [r8, r1, lsl #2]
    cd74:	03ca      	lsls	r2, r1, #15
    cd76:	f501 73c0 	add.w	r3, r1, #384	; 0x180
    cd7a:	f847 4023 	str.w	r4, [r7, r3, lsl #2]
		PRINT("%02u 0x%05x 0x%05x \t", i, 32 * KB(i), 32 * KB(i + 1));
    cd7e:	486b      	ldr	r0, [pc, #428]	; (cf2c <spm_config+0x1d0>)
    cd80:	f502 4300 	add.w	r3, r2, #32768	; 0x8000
    cd84:	1c4e      	adds	r6, r1, #1
    cd86:	f002 ff07 	bl	fb98 <printk>
		PRINT("%s", flash_perm[i] & FLASH_SECURE ? "Secure\t\t" :
    cd8a:	4b69      	ldr	r3, [pc, #420]	; (cf30 <spm_config+0x1d4>)
    cd8c:	f014 0f10 	tst.w	r4, #16
    cd90:	4968      	ldr	r1, [pc, #416]	; (cf34 <spm_config+0x1d8>)
    cd92:	4869      	ldr	r0, [pc, #420]	; (cf38 <spm_config+0x1dc>)
    cd94:	bf08      	it	eq
    cd96:	4619      	moveq	r1, r3
    cd98:	f002 fefe 	bl	fb98 <printk>
		PRINT("%c", flash_perm[i] & FLASH_READ  ? 'r' : '-');
    cd9c:	f014 0f04 	tst.w	r4, #4
    cda0:	bf14      	ite	ne
    cda2:	2172      	movne	r1, #114	; 0x72
    cda4:	212d      	moveq	r1, #45	; 0x2d
    cda6:	4628      	mov	r0, r5
    cda8:	f002 fef6 	bl	fb98 <printk>
		PRINT("%c", flash_perm[i] & FLASH_WRITE ? 'w' : '-');
    cdac:	f014 0f02 	tst.w	r4, #2
    cdb0:	bf14      	ite	ne
    cdb2:	2177      	movne	r1, #119	; 0x77
    cdb4:	212d      	moveq	r1, #45	; 0x2d
    cdb6:	4628      	mov	r0, r5
    cdb8:	f002 feee 	bl	fb98 <printk>
		PRINT("%c", flash_perm[i] & FLASH_EXEC  ? 'x' : '-');
    cdbc:	f014 0f01 	tst.w	r4, #1
    cdc0:	bf14      	ite	ne
    cdc2:	2178      	movne	r1, #120	; 0x78
    cdc4:	212d      	moveq	r1, #45	; 0x2d
    cdc6:	4628      	mov	r0, r5
    cdc8:	f002 fee6 	bl	fb98 <printk>
		PRINT("%c", flash_perm[i] & FLASH_LOCK  ? 'l' : '-');
    cdcc:	f414 7f80 	tst.w	r4, #256	; 0x100
    cdd0:	bf14      	ite	ne
    cdd2:	216c      	movne	r1, #108	; 0x6c
    cdd4:	212d      	moveq	r1, #45	; 0x2d
    cdd6:	4628      	mov	r0, r5
    cdd8:	f002 fede 	bl	fb98 <printk>
		PRINT("\n");
    cddc:	4857      	ldr	r0, [pc, #348]	; (cf3c <spm_config+0x1e0>)
    cdde:	f002 fedb 	bl	fb98 <printk>
	for (size_t i = 0; i < ARRAY_SIZE(flash_perm); i++) {
    cde2:	2e20      	cmp	r6, #32
    cde4:	4631      	mov	r1, r6
    cde6:	d1c3      	bne.n	cd70 <spm_config+0x14>
	u32_t nsc_size = FLASH_NSC_SIZE_FROM_ADDR(__sg_start);
    cde8:	4b55      	ldr	r3, [pc, #340]	; (cf40 <spm_config+0x1e4>)
	NRF_SPU->FLASHNSC[0].REGION = FLASH_NSC_REGION_FROM_ADDR(__sg_start);
    cdea:	4a4e      	ldr	r2, [pc, #312]	; (cf24 <spm_config+0x1c8>)
    cdec:	f3c3 31c4 	ubfx	r1, r3, #15, #5
	u32_t nsc_size = FLASH_NSC_SIZE_FROM_ADDR(__sg_start);
    cdf0:	f3c3 030e 	ubfx	r3, r3, #0, #15
    cdf4:	f5c3 4300 	rsb	r3, r3, #32768	; 0x8000
	NRF_SPU->FLASHNSC[0].SIZE = FLASH_NSC_SIZE_REG(nsc_size);
    cdf8:	f3c3 1343 	ubfx	r3, r3, #5, #4
	NRF_SPU->FLASHNSC[0].REGION = FLASH_NSC_REGION_FROM_ADDR(__sg_start);
    cdfc:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
	NRF_SPU->FLASHNSC[0].SIZE = FLASH_NSC_SIZE_REG(nsc_size);
    ce00:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
	PRINT("Non-secure callable region 0 placed in flash region %d with size %d.\n",
    ce04:	f8d2 1500 	ldr.w	r1, [r2, #1280]	; 0x500
    ce08:	f8d2 2504 	ldr.w	r2, [r2, #1284]	; 0x504
    ce0c:	484d      	ldr	r0, [pc, #308]	; (cf44 <spm_config+0x1e8>)
    ce0e:	0152      	lsls	r2, r2, #5
    ce10:	f002 fec2 	bl	fb98 <printk>
	PRINT("\n");
    ce14:	4849      	ldr	r0, [pc, #292]	; (cf3c <spm_config+0x1e0>)
    ce16:	f002 febf 	bl	fb98 <printk>
	int err = spm_secure_services_init();
    ce1a:	f002 ff90 	bl	fd3e <spm_secure_services_init>
	if (err != 0) {
    ce1e:	4601      	mov	r1, r0
    ce20:	b110      	cbz	r0, ce28 <spm_config+0xcc>
		PRINT("Could not initialize secure services (err %d).\n", err);
    ce22:	4849      	ldr	r0, [pc, #292]	; (cf48 <spm_config+0x1ec>)
    ce24:	f002 feb8 	bl	fb98 <printk>
	PRINT("\n");
    ce28:	4844      	ldr	r0, [pc, #272]	; (cf3c <spm_config+0x1e0>)
    ce2a:	f002 feb5 	bl	fb98 <printk>
	PRINT("SRAM region\t\tDomain\t\tPermissions\n");
    ce2e:	4847      	ldr	r0, [pc, #284]	; (cf4c <spm_config+0x1f0>)
    ce30:	f002 feb2 	bl	fb98 <printk>
	for (size_t i = 0; i < ARRAY_SIZE(sram_perm); i++) {
    ce34:	2100      	movs	r1, #0
		NRF_SPU->RAMREGION[i].PERM = sram_perm[i];
    ce36:	f8df 8138 	ldr.w	r8, [pc, #312]	; cf70 <spm_config+0x214>
    ce3a:	4f3a      	ldr	r7, [pc, #232]	; (cf24 <spm_config+0x1c8>)
		PRINT("%c", sram_perm[i] & SRAM_READ  ? 'r' : '-');
    ce3c:	4d3a      	ldr	r5, [pc, #232]	; (cf28 <spm_config+0x1cc>)
		NRF_SPU->RAMREGION[i].PERM = sram_perm[i];
    ce3e:	f858 4021 	ldr.w	r4, [r8, r1, lsl #2]
    ce42:	034a      	lsls	r2, r1, #13
    ce44:	f501 73e0 	add.w	r3, r1, #448	; 0x1c0
    ce48:	f847 4023 	str.w	r4, [r7, r3, lsl #2]
		PRINT("%02u 0x%05x 0x%05x\t", i, 8 * KB(i), 8 * KB(i + 1));
    ce4c:	4840      	ldr	r0, [pc, #256]	; (cf50 <spm_config+0x1f4>)
    ce4e:	f502 5300 	add.w	r3, r2, #8192	; 0x2000
    ce52:	1c4e      	adds	r6, r1, #1
    ce54:	f002 fea0 	bl	fb98 <printk>
		PRINT("%s", sram_perm[i] & SRAM_SECURE ? "Secure\t\t" :
    ce58:	4b35      	ldr	r3, [pc, #212]	; (cf30 <spm_config+0x1d4>)
    ce5a:	f014 0f10 	tst.w	r4, #16
    ce5e:	4935      	ldr	r1, [pc, #212]	; (cf34 <spm_config+0x1d8>)
    ce60:	4835      	ldr	r0, [pc, #212]	; (cf38 <spm_config+0x1dc>)
    ce62:	bf08      	it	eq
    ce64:	4619      	moveq	r1, r3
    ce66:	f002 fe97 	bl	fb98 <printk>
		PRINT("%c", sram_perm[i] & SRAM_READ  ? 'r' : '-');
    ce6a:	f014 0f04 	tst.w	r4, #4
    ce6e:	bf14      	ite	ne
    ce70:	2172      	movne	r1, #114	; 0x72
    ce72:	212d      	moveq	r1, #45	; 0x2d
    ce74:	4628      	mov	r0, r5
    ce76:	f002 fe8f 	bl	fb98 <printk>
		PRINT("%c", sram_perm[i] & SRAM_WRITE ? 'w' : '-');
    ce7a:	f014 0f02 	tst.w	r4, #2
    ce7e:	bf14      	ite	ne
    ce80:	2177      	movne	r1, #119	; 0x77
    ce82:	212d      	moveq	r1, #45	; 0x2d
    ce84:	4628      	mov	r0, r5
    ce86:	f002 fe87 	bl	fb98 <printk>
		PRINT("%c", sram_perm[i] & SRAM_EXEC  ? 'x' : '-');
    ce8a:	f014 0f01 	tst.w	r4, #1
    ce8e:	bf14      	ite	ne
    ce90:	2178      	movne	r1, #120	; 0x78
    ce92:	212d      	moveq	r1, #45	; 0x2d
    ce94:	4628      	mov	r0, r5
    ce96:	f002 fe7f 	bl	fb98 <printk>
		PRINT("%c", sram_perm[i] & SRAM_LOCK  ? 'l' : '-');
    ce9a:	f414 7f80 	tst.w	r4, #256	; 0x100
    ce9e:	bf14      	ite	ne
    cea0:	216c      	movne	r1, #108	; 0x6c
    cea2:	212d      	moveq	r1, #45	; 0x2d
    cea4:	4628      	mov	r0, r5
    cea6:	f002 fe77 	bl	fb98 <printk>
		PRINT("\n");
    ceaa:	4824      	ldr	r0, [pc, #144]	; (cf3c <spm_config+0x1e0>)
    ceac:	f002 fe74 	bl	fb98 <printk>
	for (size_t i = 0; i < ARRAY_SIZE(sram_perm); i++) {
    ceb0:	2e20      	cmp	r6, #32
    ceb2:	4631      	mov	r1, r6
    ceb4:	d1c3      	bne.n	ce3e <spm_config+0xe2>
	PRINT("\n");
    ceb6:	4821      	ldr	r0, [pc, #132]	; (cf3c <spm_config+0x1e0>)
    ceb8:	f002 fe6e 	bl	fb98 <printk>
	NRF_SPU->DPPI[0].PERM = mask;
    cebc:	f64f 73ff 	movw	r3, #65535	; 0xffff
		NRF_SPU->GPIOPORT[0].PERM = 0;
    cec0:	2400      	movs	r4, #0
	NRF_SPU->DPPI[0].PERM = mask;
    cec2:	4d18      	ldr	r5, [pc, #96]	; (cf24 <spm_config+0x1c8>)
	PRINT("Peripheral\t\tDomain\t\tStatus\n");
    cec4:	4823      	ldr	r0, [pc, #140]	; (cf54 <spm_config+0x1f8>)
	NRF_SPU->DPPI[0].PERM = mask;
    cec6:	f8c5 3480 	str.w	r3, [r5, #1152]	; 0x480
	PRINT("Peripheral\t\tDomain\t\tStatus\n");
    ceca:	f002 fe65 	bl	fb98 <printk>
		PRINT("%02u %-21s%s", i, periph[i].name,
    cece:	f8df 80a4 	ldr.w	r8, [pc, #164]	; cf74 <spm_config+0x218>
		NRF_SPU->GPIOPORT[0].PERM = 0;
    ced2:	f8c5 44c0 	str.w	r4, [r5, #1216]	; 0x4c0
		PRINT("%02u %-21s%s", i, periph[i].name,
    ced6:	f8df 90a0 	ldr.w	r9, [pc, #160]	; cf78 <spm_config+0x21c>
    ceda:	4d1f      	ldr	r5, [pc, #124]	; (cf58 <spm_config+0x1fc>)
    cedc:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
    cee0:	7977      	ldrb	r7, [r6, #5]
    cee2:	f855 2034 	ldr.w	r2, [r5, r4, lsl #3]
    cee6:	2f00      	cmp	r7, #0
    cee8:	bf14      	ite	ne
    ceea:	4643      	movne	r3, r8
    ceec:	464b      	moveq	r3, r9
    ceee:	4621      	mov	r1, r4
    cef0:	481a      	ldr	r0, [pc, #104]	; (cf5c <spm_config+0x200>)
    cef2:	f002 fe51 	bl	fb98 <printk>
		if (!periph[i].nonsecure) {
    cef6:	b957      	cbnz	r7, cf0e <spm_config+0x1b2>
			PRINT("\tSKIP\n");
    cef8:	4819      	ldr	r0, [pc, #100]	; (cf60 <spm_config+0x204>)
	for (size_t i = 0; i < ARRAY_SIZE(periph); i++) {
    cefa:	3401      	adds	r4, #1
			PRINT("\tOK\n");
    cefc:	f002 fe4c 	bl	fb98 <printk>
	for (size_t i = 0; i < ARRAY_SIZE(periph); i++) {
    cf00:	2c19      	cmp	r4, #25
    cf02:	d1eb      	bne.n	cedc <spm_config+0x180>
	PRINT("\n");
    cf04:	480d      	ldr	r0, [pc, #52]	; (cf3c <spm_config+0x1e0>)
	spm_config_flash();
	spm_config_sram();
	spm_config_peripherals();
}
    cf06:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	PRINT("\n");
    cf0a:	f002 be45 	b.w	fb98 <printk>
		err = spm_config_peripheral(periph[i].id, false);
    cf0e:	7930      	ldrb	r0, [r6, #4]
    cf10:	f7ff fe88 	bl	cc24 <spm_config_peripheral.constprop.1>
		if (err) {
    cf14:	b108      	cbz	r0, cf1a <spm_config+0x1be>
			PRINT("\tERROR\n");
    cf16:	4813      	ldr	r0, [pc, #76]	; (cf64 <spm_config+0x208>)
    cf18:	e7ef      	b.n	cefa <spm_config+0x19e>
			PRINT("\tOK\n");
    cf1a:	4813      	ldr	r0, [pc, #76]	; (cf68 <spm_config+0x20c>)
    cf1c:	e7ed      	b.n	cefa <spm_config+0x19e>
    cf1e:	bf00      	nop
    cf20:	00010918 	.word	0x00010918
    cf24:	50003000 	.word	0x50003000
    cf28:	00010950 	.word	0x00010950
    cf2c:	0001093b 	.word	0x0001093b
    cf30:	00010901 	.word	0x00010901
    cf34:	000108f8 	.word	0x000108f8
    cf38:	00010a25 	.word	0x00010a25
    cf3c:	00010c32 	.word	0x00010c32
    cf40:	00017fe0 	.word	0x00017fe0
    cf44:	00010953 	.word	0x00010953
    cf48:	00010999 	.word	0x00010999
    cf4c:	000109c9 	.word	0x000109c9
    cf50:	000109eb 	.word	0x000109eb
    cf54:	000109ff 	.word	0x000109ff
    cf58:	00010620 	.word	0x00010620
    cf5c:	00010a1b 	.word	0x00010a1b
    cf60:	00010a28 	.word	0x00010a28
    cf64:	00010a2f 	.word	0x00010a2f
    cf68:	00010a37 	.word	0x00010a37
    cf6c:	000105a0 	.word	0x000105a0
    cf70:	000106e8 	.word	0x000106e8
    cf74:	0001090d 	.word	0x0001090d
    cf78:	00010905 	.word	0x00010905

0000cf7c <__acle_se_spm_request_read>:
	size_t size;
};

__TZ_NONSECURE_ENTRY_FUNC
int spm_request_read(void *destination, u32_t addr, size_t len)
{
    cf7c:	b510      	push	{r4, lr}
		 .size = FICR_PUBLIC_SIZE},
		{.start = FICR_RESTRICTED_ADDR,
		 .size = FICR_RESTRICTED_SIZE},
	};

	if (destination == NULL || len <= 0) {
    cf7e:	2800      	cmp	r0, #0
    cf80:	d050      	beq.n	d024 <__acle_se_spm_request_read+0xa8>
    cf82:	2a00      	cmp	r2, #0
    cf84:	d04e      	beq.n	d024 <__acle_se_spm_request_read+0xa8>

	for (size_t i = 0; i < ARRAY_SIZE(ranges); i++) {
		u32_t start = ranges[i].start;
		u32_t size = ranges[i].size;

		if (addr >= start && addr + len <= start + size) {
    cf86:	f5b1 4f40 	cmp.w	r1, #49152	; 0xc000
    cf8a:	d348      	bcc.n	d01e <__acle_se_spm_request_read+0xa2>
    cf8c:	1853      	adds	r3, r2, r1
    cf8e:	f5b3 4f42 	cmp.w	r3, #49664	; 0xc200
    cf92:	d906      	bls.n	cfa2 <__acle_se_spm_request_read+0x26>
    cf94:	4c25      	ldr	r4, [pc, #148]	; (d02c <__acle_se_spm_request_read+0xb0>)
    cf96:	42a1      	cmp	r1, r4
    cf98:	d93b      	bls.n	d012 <__acle_se_spm_request_read+0x96>
    cf9a:	f604 241d 	addw	r4, r4, #2589	; 0xa1d
    cf9e:	42a3      	cmp	r3, r4
    cfa0:	d83a      	bhi.n	d018 <__acle_se_spm_request_read+0x9c>
			memcpy(destination, (const void *)addr, len);
    cfa2:	f002 ff9e 	bl	fee2 <memcpy>
			return 0;
    cfa6:	2000      	movs	r0, #0
		}
	}

	return -EPERM;
}
    cfa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cfac:	4671      	mov	r1, lr
    cfae:	4672      	mov	r2, lr
    cfb0:	4673      	mov	r3, lr
    cfb2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cfb6:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    cfba:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    cfbe:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    cfc2:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    cfc6:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    cfca:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    cfce:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    cfd2:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    cfd6:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    cfda:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    cfde:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    cfe2:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    cfe6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    cfea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    cfee:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    cff2:	f38e 8c00 	msr	CPSR_fs, lr
    cff6:	b410      	push	{r4}
    cff8:	eef1 ca10 	vmrs	ip, fpscr
    cffc:	f64f 7460 	movw	r4, #65376	; 0xff60
    d000:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    d004:	ea0c 0c04 	and.w	ip, ip, r4
    d008:	eee1 ca10 	vmsr	fpscr, ip
    d00c:	bc10      	pop	{r4}
    d00e:	46f4      	mov	ip, lr
    d010:	4774      	bxns	lr
		if (addr >= start && addr + len <= start + size) {
    d012:	4c07      	ldr	r4, [pc, #28]	; (d030 <__acle_se_spm_request_read+0xb4>)
    d014:	42a1      	cmp	r1, r4
    d016:	d902      	bls.n	d01e <__acle_se_spm_request_read+0xa2>
    d018:	4c06      	ldr	r4, [pc, #24]	; (d034 <__acle_se_spm_request_read+0xb8>)
    d01a:	42a3      	cmp	r3, r4
    d01c:	d9c1      	bls.n	cfa2 <__acle_se_spm_request_read+0x26>
	return -EPERM;
    d01e:	f04f 30ff 	mov.w	r0, #4294967295
    d022:	e7c1      	b.n	cfa8 <__acle_se_spm_request_read+0x2c>
		return -EINVAL;
    d024:	f06f 0015 	mvn.w	r0, #21
    d028:	e7be      	b.n	cfa8 <__acle_se_spm_request_read+0x2c>
    d02a:	bf00      	nop
    d02c:	00ff0203 	.word	0x00ff0203
    d030:	00ff012f 	.word	0x00ff012f
    d034:	00ff0138 	.word	0x00ff0138

0000d038 <__acle_se_spm_firmware_info>:
#endif /* CONFIG_SPM_SERVICE_RNG */

#ifdef CONFIG_SPM_SERVICE_FIND_FIRMWARE_INFO
__TZ_NONSECURE_ENTRY_FUNC
int spm_firmware_info(u32_t fw_address, struct fw_info *info)
{
    d038:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d03c:	4684      	mov	ip, r0
    d03e:	b085      	sub	sp, #20
	const struct fw_info *tmp_info;

	if (info == NULL) {
    d040:	460f      	mov	r7, r1
    d042:	2900      	cmp	r1, #0
    d044:	d06a      	beq.n	d11c <__acle_se_spm_firmware_info+0xe4>
/* Search for the firmware_info structure inside the firmware. */
static inline const struct fw_info *fw_info_find(u32_t firmware_address)
{
	const struct fw_info *finfo;

	for (u32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
    d046:	2400      	movs	r4, #0
		if (expected_32[i] != actual_32[i]) {
    d048:	f645 3a01 	movw	sl, #23297	; 0x5b01
		finfo = fw_info_check(firmware_address +
						allowed_offsets[i]);
    d04c:	f8df e0d8 	ldr.w	lr, [pc, #216]	; d128 <__acle_se_spm_firmware_info+0xf0>
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d050:	4e34      	ldr	r6, [pc, #208]	; (d124 <__acle_se_spm_firmware_info+0xec>)
		if (expected_32[i] != actual_32[i]) {
    d052:	f8df 80d8 	ldr.w	r8, [pc, #216]	; d12c <__acle_se_spm_firmware_info+0xf4>
    d056:	f8df 90d8 	ldr.w	r9, [pc, #216]	; d130 <__acle_se_spm_firmware_info+0xf8>
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d05a:	ad01      	add	r5, sp, #4
		finfo = fw_info_check(firmware_address +
    d05c:	f85e b024 	ldr.w	fp, [lr, r4, lsl #2]
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d060:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
		finfo = fw_info_check(firmware_address +
    d064:	eb0c 030b 	add.w	r3, ip, fp
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d068:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (((u32_t)expected % 4) || ((u32_t)actual % 4) || ((u32_t)len % 4)) {
    d06c:	079a      	lsls	r2, r3, #30
    d06e:	d144      	bne.n	d0fa <__acle_se_spm_firmware_info+0xc2>
		if (expected_32[i] != actual_32[i]) {
    d070:	f85c 200b 	ldr.w	r2, [ip, fp]
    d074:	4542      	cmp	r2, r8
    d076:	d105      	bne.n	d084 <__acle_se_spm_firmware_info+0x4c>
    d078:	685a      	ldr	r2, [r3, #4]
    d07a:	454a      	cmp	r2, r9
    d07c:	d102      	bne.n	d084 <__acle_se_spm_firmware_info+0x4c>
    d07e:	689a      	ldr	r2, [r3, #8]
    d080:	4552      	cmp	r2, sl
    d082:	d044      	beq.n	d10e <__acle_se_spm_firmware_info+0xd6>
	for (u32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
    d084:	3401      	adds	r4, #1
    d086:	2c03      	cmp	r4, #3
    d088:	d1e8      	bne.n	d05c <__acle_se_spm_firmware_info+0x24>
	if (tmp_info != NULL) {
		memcpy(info, tmp_info, sizeof(*tmp_info));
		return 0;
	}

	return -EFAULT;
    d08a:	f06f 000d 	mvn.w	r0, #13
}
    d08e:	b005      	add	sp, #20
    d090:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    d094:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    d098:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    d09c:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    d0a0:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    d0a4:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    d0a8:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    d0ac:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    d0b0:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    d0b4:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    d0b8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    d0bc:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    d0c0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    d0c4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    d0c8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    d0cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d0d0:	4671      	mov	r1, lr
    d0d2:	4672      	mov	r2, lr
    d0d4:	4673      	mov	r3, lr
    d0d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d0da:	f38e 8c00 	msr	CPSR_fs, lr
    d0de:	b410      	push	{r4}
    d0e0:	eef1 ca10 	vmrs	ip, fpscr
    d0e4:	f64f 7460 	movw	r4, #65376	; 0xff60
    d0e8:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    d0ec:	ea0c 0c04 	and.w	ip, ip, r4
    d0f0:	eee1 ca10 	vmsr	fpscr, ip
    d0f4:	bc10      	pop	{r4}
    d0f6:	46f4      	mov	ip, lr
    d0f8:	4774      	bxns	lr
	if (((u32_t)expected % 4) || ((u32_t)actual % 4) || ((u32_t)len % 4)) {
    d0fa:	2200      	movs	r2, #0
		if (expected_8[i] != actual_8[i]) {
    d0fc:	5c98      	ldrb	r0, [r3, r2]
    d0fe:	5ca9      	ldrb	r1, [r5, r2]
    d100:	4288      	cmp	r0, r1
    d102:	d1bf      	bne.n	d084 <__acle_se_spm_firmware_info+0x4c>
	for (u32_t i = 0; i < len; i++) {
    d104:	3201      	adds	r2, #1
    d106:	2a0c      	cmp	r2, #12
    d108:	d1f8      	bne.n	d0fc <__acle_se_spm_firmware_info+0xc4>
		if (finfo) {
    d10a:	2b00      	cmp	r3, #0
    d10c:	d0ba      	beq.n	d084 <__acle_se_spm_firmware_info+0x4c>
		memcpy(info, tmp_info, sizeof(*tmp_info));
    d10e:	2220      	movs	r2, #32
    d110:	4619      	mov	r1, r3
    d112:	4638      	mov	r0, r7
    d114:	f002 fee5 	bl	fee2 <memcpy>
		return 0;
    d118:	2000      	movs	r0, #0
    d11a:	e7b8      	b.n	d08e <__acle_se_spm_firmware_info+0x56>
		return -EINVAL;
    d11c:	f06f 0015 	mvn.w	r0, #21
    d120:	e7b5      	b.n	d08e <__acle_se_spm_firmware_info+0x56>
    d122:	bf00      	nop
    d124:	00010540 	.word	0x00010540
    d128:	00010768 	.word	0x00010768
    d12c:	281ee6de 	.word	0x281ee6de
    d130:	8fcebb4c 	.word	0x8fcebb4c

0000d134 <nrf_cc310_platform_abort_init>:

/** @brief Function to initialize the nrf_cc310_platform abort APIs.
 */
void nrf_cc310_platform_abort_init(void)
{
	nrf_cc310_platform_set_abort(&apis);
    d134:	4801      	ldr	r0, [pc, #4]	; (d13c <nrf_cc310_platform_abort_init+0x8>)
    d136:	f001 be61 	b.w	edfc <nrf_cc310_platform_set_abort>
    d13a:	bf00      	nop
    d13c:	00010774 	.word	0x00010774

0000d140 <mutex_unlock>:
}


/** @brief Static function to unlock a mutex
 */
static int32_t mutex_unlock(nrf_cc310_platform_mutex_t *mutex) {
    d140:	b508      	push	{r3, lr}
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    d142:	b130      	cbz	r0, d152 <mutex_unlock+0x12>
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    }

    /* Ensure that the mutex has been initialized */
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d144:	6843      	ldr	r3, [r0, #4]
    d146:	b13b      	cbz	r3, d158 <mutex_unlock+0x18>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    }

    p_mutex = (struct k_mutex *)mutex->mutex;
    d148:	6800      	ldr	r0, [r0, #0]
		z_arch_syscall_invoke1(*(u32_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
    d14a:	f001 f865 	bl	e218 <z_impl_k_mutex_unlock>

    k_mutex_unlock(p_mutex);
    return NRF_CC310_PLATFORM_SUCCESS;
    d14e:	2000      	movs	r0, #0
}
    d150:	bd08      	pop	{r3, pc}
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    d152:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d156:	e7fb      	b.n	d150 <mutex_unlock+0x10>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d158:	4800      	ldr	r0, [pc, #0]	; (d15c <mutex_unlock+0x1c>)
    d15a:	e7f9      	b.n	d150 <mutex_unlock+0x10>
    d15c:	ffff8fea 	.word	0xffff8fea

0000d160 <mutex_lock>:
static int32_t mutex_lock(nrf_cc310_platform_mutex_t *mutex) {
    d160:	b508      	push	{r3, lr}
    if(mutex == NULL) {
    d162:	b158      	cbz	r0, d17c <mutex_lock+0x1c>
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d164:	6843      	ldr	r3, [r0, #4]
    d166:	b163      	cbz	r3, d182 <mutex_lock+0x22>
    p_mutex = (struct k_mutex *)mutex->mutex;
    d168:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    d16a:	f04f 31ff 	mov.w	r1, #4294967295
    d16e:	f000 ffe1 	bl	e134 <z_impl_k_mutex_lock>
    if (ret == 0) {
    d172:	2800      	cmp	r0, #0
        return NRF_CC310_PLATFORM_ERROR_MUTEX_FAILED;
    d174:	4804      	ldr	r0, [pc, #16]	; (d188 <mutex_lock+0x28>)
    d176:	bf08      	it	eq
    d178:	2000      	moveq	r0, #0
}
    d17a:	bd08      	pop	{r3, pc}
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    d17c:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d180:	e7fb      	b.n	d17a <mutex_lock+0x1a>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d182:	4802      	ldr	r0, [pc, #8]	; (d18c <mutex_lock+0x2c>)
    d184:	e7f9      	b.n	d17a <mutex_lock+0x1a>
    d186:	bf00      	nop
    d188:	ffff8fe9 	.word	0xffff8fe9
    d18c:	ffff8fea 	.word	0xffff8fea

0000d190 <mutex_free>:
static void mutex_free(nrf_cc310_platform_mutex_t *mutex) {
    d190:	b538      	push	{r3, r4, r5, lr}
    if (mutex == NULL) {
    d192:	4604      	mov	r4, r0
    d194:	b918      	cbnz	r0, d19e <mutex_free+0xe>
        platform_abort_apis.abort_fn(
    d196:	4b0b      	ldr	r3, [pc, #44]	; (d1c4 <mutex_free+0x34>)
    d198:	480b      	ldr	r0, [pc, #44]	; (d1c8 <mutex_free+0x38>)
    d19a:	685b      	ldr	r3, [r3, #4]
    d19c:	4798      	blx	r3
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d19e:	6865      	ldr	r5, [r4, #4]
    d1a0:	b155      	cbz	r5, d1b8 <mutex_free+0x28>
    if ((mutex->flags & NRF_CC310_PLATFORM_MUTEX_MASK_IS_ALLOCATED) == 0) {
    d1a2:	f015 0502 	ands.w	r5, r5, #2
    d1a6:	6820      	ldr	r0, [r4, #0]
    d1a8:	d107      	bne.n	d1ba <mutex_free+0x2a>
        k_mem_slab_free(&mutex_slab, mutex->mutex);
    d1aa:	4601      	mov	r1, r0
    d1ac:	4807      	ldr	r0, [pc, #28]	; (d1cc <mutex_free+0x3c>)
    d1ae:	f000 ff93 	bl	e0d8 <k_mem_slab_free>
        mutex->mutex = NULL;
    d1b2:	6025      	str	r5, [r4, #0]
    mutex->flags = NRF_CC310_PLATFORM_MUTEX_MASK_INVALID;
    d1b4:	2300      	movs	r3, #0
    d1b6:	6063      	str	r3, [r4, #4]
}
    d1b8:	bd38      	pop	{r3, r4, r5, pc}
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d1ba:	2214      	movs	r2, #20
    d1bc:	2100      	movs	r1, #0
    d1be:	f002 febd 	bl	ff3c <memset>
    d1c2:	e7f7      	b.n	d1b4 <mutex_free+0x24>
    d1c4:	20001428 	.word	0x20001428
    d1c8:	00010ba4 	.word	0x00010ba4
    d1cc:	20000028 	.word	0x20000028

0000d1d0 <mutex_init>:
static void mutex_init(nrf_cc310_platform_mutex_t *mutex) {
    d1d0:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    d1d2:	4604      	mov	r4, r0
    d1d4:	b918      	cbnz	r0, d1de <mutex_init+0xe>
        platform_abort_apis.abort_fn(
    d1d6:	4b13      	ldr	r3, [pc, #76]	; (d224 <mutex_init+0x54>)
    d1d8:	4813      	ldr	r0, [pc, #76]	; (d228 <mutex_init+0x58>)
    d1da:	685b      	ldr	r3, [r3, #4]
    d1dc:	4798      	blx	r3
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID &&
    d1de:	6863      	ldr	r3, [r4, #4]
    d1e0:	b9bb      	cbnz	r3, d212 <mutex_init+0x42>
    d1e2:	6823      	ldr	r3, [r4, #0]
    d1e4:	b9ab      	cbnz	r3, d212 <mutex_init+0x42>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    d1e6:	f04f 32ff 	mov.w	r2, #4294967295
    d1ea:	4621      	mov	r1, r4
    d1ec:	480f      	ldr	r0, [pc, #60]	; (d22c <mutex_init+0x5c>)
    d1ee:	f000 ff45 	bl	e07c <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    d1f2:	b908      	cbnz	r0, d1f8 <mutex_init+0x28>
    d1f4:	6823      	ldr	r3, [r4, #0]
    d1f6:	b91b      	cbnz	r3, d200 <mutex_init+0x30>
            platform_abort_apis.abort_fn(
    d1f8:	4b0a      	ldr	r3, [pc, #40]	; (d224 <mutex_init+0x54>)
    d1fa:	480d      	ldr	r0, [pc, #52]	; (d230 <mutex_init+0x60>)
    d1fc:	685b      	ldr	r3, [r3, #4]
    d1fe:	4798      	blx	r3
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d200:	2214      	movs	r2, #20
    d202:	2100      	movs	r1, #0
    d204:	6820      	ldr	r0, [r4, #0]
    d206:	f002 fe99 	bl	ff3c <memset>
        mutex->flags |= NRF_CC310_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    d20a:	6863      	ldr	r3, [r4, #4]
    d20c:	f043 0302 	orr.w	r3, r3, #2
    d210:	6063      	str	r3, [r4, #4]
    p_mutex = (struct k_mutex *)mutex->mutex;
    d212:	6820      	ldr	r0, [r4, #0]
	z_impl_k_mutex_init(mutex);
    d214:	f002 ff2a 	bl	1006c <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC310_PLATFORM_MUTEX_MASK_IS_VALID;
    d218:	6863      	ldr	r3, [r4, #4]
    d21a:	f043 0301 	orr.w	r3, r3, #1
    d21e:	6063      	str	r3, [r4, #4]
}
    d220:	bd10      	pop	{r4, pc}
    d222:	bf00      	nop
    d224:	20001428 	.word	0x20001428
    d228:	00010ba4 	.word	0x00010ba4
    d22c:	20000028 	.word	0x20000028
    d230:	00010bca 	.word	0x00010bca

0000d234 <nrf_cc310_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc310_platform mutex APIs
 */
void nrf_cc310_platform_mutex_init(void)
{
    d234:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    d236:	4906      	ldr	r1, [pc, #24]	; (d250 <nrf_cc310_platform_mutex_init+0x1c>)
    d238:	2340      	movs	r3, #64	; 0x40
    d23a:	4806      	ldr	r0, [pc, #24]	; (d254 <nrf_cc310_platform_mutex_init+0x20>)
    d23c:	2214      	movs	r2, #20
    d23e:	f002 ff03 	bl	10048 <k_mem_slab_init>
            mutex_slab_buffer,
            sizeof(struct k_mutex),
            NUM_MUTEXES);

    nrf_cc310_platform_set_mutexes(&mutex_apis, &mutexes);
}
    d242:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrf_cc310_platform_set_mutexes(&mutex_apis, &mutexes);
    d246:	4904      	ldr	r1, [pc, #16]	; (d258 <nrf_cc310_platform_mutex_init+0x24>)
    d248:	4804      	ldr	r0, [pc, #16]	; (d25c <nrf_cc310_platform_mutex_init+0x28>)
    d24a:	f001 be0f 	b.w	ee6c <nrf_cc310_platform_set_mutexes>
    d24e:	bf00      	nop
    d250:	20000044 	.word	0x20000044
    d254:	20000028 	.word	0x20000028
    d258:	0001078c 	.word	0x0001078c
    d25c:	0001077c 	.word	0x0001077c

0000d260 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    d260:	4804      	ldr	r0, [pc, #16]	; (d274 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    d262:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    d264:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    d266:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    d268:	d003      	beq.n	d272 <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    d26a:	4903      	ldr	r1, [pc, #12]	; (d278 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    d26c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    d270:	600a      	str	r2, [r1, #0]

0000d272 <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    d272:	4770      	bx	lr
    ldr r0, =_kernel
    d274:	20000630 	.word	0x20000630
    ldr r1, =_SCS_ICSR
    d278:	e000ed04 	.word	0xe000ed04

0000d27c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    d27c:	4912      	ldr	r1, [pc, #72]	; (d2c8 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    d27e:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    d280:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    d284:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    d286:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    d28a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    d28e:	2020      	movs	r0, #32
    msr BASEPRI, r0
    d290:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    d294:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    d298:	4f0c      	ldr	r7, [pc, #48]	; (d2cc <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    d29a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    d29e:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    d2a0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    d2a2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    d2a4:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    d2a6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    d2a8:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    d2aa:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    d2ae:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    d2b0:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    d2b2:	f002 fdc8 	bl	fe46 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    d2b6:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    d2ba:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    d2be:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    d2c2:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    d2c6:	4770      	bx	lr
    ldr r1, =_kernel
    d2c8:	20000630 	.word	0x20000630
    ldr v4, =_SCS_ICSR
    d2cc:	e000ed04 	.word	0xe000ed04

0000d2d0 <z_arm_svc>:
 */
SECTION_FUNC(TEXT, z_arm_svc)
  /* Use EXC_RETURN state to find out if stack frame is on the
   * MSP or PSP
   */
    tst lr, #0x4    /* did we come from thread mode ? */
    d2d0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    d2d4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    d2d6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    d2da:	f3ef 8009 	mrsne	r0, PSP


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    d2de:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read the
     * SVC number (lower byte of SCV instruction)
     */
    ldrb r1, [r1, #-2]
    d2e0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
    tst r2, #0x1
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    d2e4:	2902      	cmp	r1, #2
    beq _oops
    d2e6:	d0ff      	beq.n	d2e8 <_oops>

0000d2e8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    d2e8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    d2ea:	f002 fda1 	bl	fe30 <z_do_kernel_oops>
    pop {r0, pc}
    d2ee:	bd01      	pop	{r0, pc}

0000d2f0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    d2f0:	4901      	ldr	r1, [pc, #4]	; (d2f8 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    d2f2:	2210      	movs	r2, #16
	str r2, [r1]
    d2f4:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    d2f6:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    d2f8:	e000ed10 	.word	0xe000ed10

0000d2fc <z_arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    d2fc:	4040      	eors	r0, r0
	msr BASEPRI, r0
    d2fe:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    d302:	bf30      	wfi

	bx lr
    d304:	4770      	bx	lr
    d306:	bf00      	nop

0000d308 <z_arm_bus_fault>:
	mrs r0, MSP
_stack_frame_endif:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* force unlock interrupts */
	eors.n r0, r0
    d308:	4040      	eors	r0, r0
	msr BASEPRI, r0
    d30a:	f380 8811 	msr	BASEPRI, r0
	/* RETTOBASE flag is not banked between security states.
	 * Therefore, we cannot rely on this flag, to obtain the SP
	 * of the current security state.
	 * Instead, we use the EXC_RETURN.SPSEL flag.
	 */
 	ldr r0, =0x4
    d30e:	f04f 0004 	mov.w	r0, #4
	mov r1, lr
    d312:	4671      	mov	r1, lr
	tst r1, r0
    d314:	4201      	tst	r1, r0
	beq _s_stack_frame_msp
    d316:	d002      	beq.n	d31e <_s_stack_frame_msp>
	mrs r0, PSP
    d318:	f3ef 8009 	mrs	r0, PSP
	bne _s_stack_frame_endif
    d31c:	d101      	bne.n	d322 <_s_stack_frame_endif>

0000d31e <_s_stack_frame_msp>:
_s_stack_frame_msp:
	mrs r0, MSP
    d31e:	f3ef 8008 	mrs	r0, MSP

0000d322 <_s_stack_frame_endif>:
	 *
	 * To determine this we need to inspect the EXC_RETURN value
	 * located in the LR. Therefore, we supply the LR value as an
	 * argument to the fault handler.
	 */
	mov r1, lr
    d322:	4671      	mov	r1, lr
#endif /* CONFIG_ARM_SECURE_FIRMWARE || CONFIG_ARM_NONSECURE_FIRMWARE */
	push {r0, lr}
    d324:	b501      	push	{r0, lr}
	bl z_arm_fault
    d326:	f000 f961 	bl	d5ec <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    d32a:	bd01      	pop	{r0, pc}

0000d32c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    d32c:	bf30      	wfi
    b z_SysNmiOnReset
    d32e:	f7ff bffd 	b.w	d32c <z_SysNmiOnReset>
    d332:	bf00      	nop

0000d334 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    d334:	b501      	push	{r0, lr}
	 * device for the next timer deadline is not interrupted.  For
	 * non-tickless idle, this ensures that the clearing of the kernel idle
	 * state is not interrupted.  In each case, z_sys_power_save_idle_exit
	 * is called with interrupts disabled.
	 */
	cpsid i  /* PRIMASK = 1 */
    d336:	b672      	cpsid	i

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    d338:	4a0b      	ldr	r2, [pc, #44]	; (d368 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    d33a:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    d33c:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    d33e:	bf1e      	ittt	ne
	movne	r1, #0
    d340:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    d342:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    d344:	f002 fe7e 	blne	10044 <z_sys_power_save_idle_exit>
_idle_state_cleared:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    d348:	b662      	cpsie	i
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    d34a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    d34e:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    d352:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    d356:	4905      	ldr	r1, [pc, #20]	; (d36c <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    d358:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    d35a:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    d35c:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    d35e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    d362:	4903      	ldr	r1, [pc, #12]	; (d370 <_isr_wrapper+0x3c>)
	bx r1
    d364:	4708      	bx	r1
    d366:	0000      	.short	0x0000
	ldr r2, =_kernel
    d368:	20000630 	.word	0x20000630
	ldr r1, =_sw_isr_table
    d36c:	000102c0 	.word	0x000102c0
	ldr r1, =z_arm_int_exit
    d370:	0000d261 	.word	0x0000d261

0000d374 <z_arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    d374:	4a09      	ldr	r2, [pc, #36]	; (d39c <z_arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    d376:	490a      	ldr	r1, [pc, #40]	; (d3a0 <z_arch_swap+0x2c>)
	_current->arch.basepri = key;
    d378:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    d37a:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    d37c:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
    d37e:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    d380:	4908      	ldr	r1, [pc, #32]	; (d3a4 <z_arch_swap+0x30>)
    d382:	684b      	ldr	r3, [r1, #4]
    d384:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    d388:	604b      	str	r3, [r1, #4]
    d38a:	2300      	movs	r3, #0
    d38c:	f383 8811 	msr	BASEPRI, r3
    d390:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    d394:	6893      	ldr	r3, [r2, #8]
}
    d396:	6e98      	ldr	r0, [r3, #104]	; 0x68
    d398:	4770      	bx	lr
    d39a:	bf00      	nop
    d39c:	20000630 	.word	0x20000630
    d3a0:	000107d0 	.word	0x000107d0
    d3a4:	e000ed00 	.word	0xe000ed00

0000d3a8 <z_arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void z_arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    d3a8:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    d3aa:	2b00      	cmp	r3, #0
    d3ac:	db08      	blt.n	d3c0 <z_arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    d3ae:	2201      	movs	r2, #1
    d3b0:	f000 001f 	and.w	r0, r0, #31
    d3b4:	fa02 f000 	lsl.w	r0, r2, r0
    d3b8:	4a02      	ldr	r2, [pc, #8]	; (d3c4 <z_arch_irq_enable+0x1c>)
    d3ba:	095b      	lsrs	r3, r3, #5
    d3bc:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    d3c0:	4770      	bx	lr
    d3c2:	bf00      	nop
    d3c4:	e000e100 	.word	0xe000e100

0000d3c8 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    d3c8:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    d3ca:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    d3cc:	f101 0101 	add.w	r1, r1, #1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3d0:	bfa8      	it	ge
    d3d2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
    d3d6:	ea4f 1141 	mov.w	r1, r1, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3da:	bfb8      	it	lt
    d3dc:	4b05      	ldrlt	r3, [pc, #20]	; (d3f4 <z_arm_irq_priority_set+0x2c>)
    d3de:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3e0:	bfab      	itete	ge
    d3e2:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3e6:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3ea:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d3ee:	5419      	strblt	r1, [r3, r0]
}
    d3f0:	4770      	bx	lr
    d3f2:	bf00      	nop
    d3f4:	e000ed14 	.word	0xe000ed14

0000d3f8 <z_arch_new_thread>:
 */
void z_arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		       size_t stackSize, k_thread_entry_t pEntry,
		       void *parameter1, void *parameter2, void *parameter3,
		       int priority, unsigned int options)
{
    d3f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
    d3fc:	188c      	adds	r4, r1, r2
{
    d3fe:	4688      	mov	r8, r1
    d400:	4617      	mov	r7, r2
    d402:	461e      	mov	r6, r3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    d404:	2204      	movs	r2, #4
    d406:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d408:	9909      	ldr	r1, [sp, #36]	; 0x24
    d40a:	4605      	mov	r5, r0
    d40c:	f002 ff0b 	bl	10226 <z_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
    d410:	2200      	movs	r2, #0
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    d412:	490d      	ldr	r1, [pc, #52]	; (d448 <z_arch_new_thread+0x50>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    d414:	f1a4 0320 	sub.w	r3, r4, #32
    d418:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    d41c:	f021 0101 	bic.w	r1, r1, #1
	thread->fn_abort = NULL;
    d420:	e9c5 2213 	strd	r2, r2, [r5, #76]	; 0x4c
	thread->mem_domain_info.mem_domain = NULL;
#endif /* CONFIG_USERSPACE */

#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)pStack;
	thread->stack_info.size = (u32_t)stackSize;
    d424:	e9c5 8716 	strd	r8, r7, [r5, #88]	; 0x58
    d428:	6199      	str	r1, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    d42a:	9906      	ldr	r1, [sp, #24]
	pInitCtx->basic.a1 = (u32_t)pEntry;
    d42c:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    d42e:	6059      	str	r1, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    d430:	9907      	ldr	r1, [sp, #28]
    d432:	6099      	str	r1, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    d434:	9908      	ldr	r1, [sp, #32]
    d436:	60d9      	str	r1, [r3, #12]
	pInitCtx->basic.xpsr =
    d438:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    d43c:	61d9      	str	r1, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    d43e:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    d440:	666a      	str	r2, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    d442:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d446:	bf00      	nop
    d448:	0000f879 	.word	0x0000f879

0000d44c <z_arch_switch_to_main_thread>:

void z_arch_switch_to_main_thread(struct k_thread *main_thread,
				  k_thread_stack_t *main_stack,
				  size_t main_stack_size,
				  k_thread_entry_t _main)
{
    d44c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d44e:	461e      	mov	r6, r3
    d450:	4605      	mov	r5, r0
    d452:	460c      	mov	r4, r1
    d454:	4617      	mov	r7, r2
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    d456:	2300      	movs	r3, #0
    d458:	eee1 3a10 	vmsr	fpscr, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    d45c:	f000 f96e 	bl	d73c <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    d460:	4b0b      	ldr	r3, [pc, #44]	; (d490 <z_arch_switch_to_main_thread+0x44>)
	start_of_main_stack =
    d462:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    d464:	4628      	mov	r0, r5
	_current = main_thread;
    d466:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    d468:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    d46c:	f002 fceb 	bl	fe46 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    d470:	4630      	mov	r0, r6
    d472:	f384 8809 	msr	PSP, r4
    d476:	b663      	cpsie	if
    d478:	f04f 0100 	mov.w	r1, #0
    d47c:	f381 8811 	msr	BASEPRI, r1
    d480:	f3bf 8f6f 	isb	sy
    d484:	2100      	movs	r1, #0
    d486:	2200      	movs	r2, #0
    d488:	2300      	movs	r3, #0
    d48a:	f002 f9f5 	bl	f878 <z_thread_entry>
    d48e:	bf00      	nop
    d490:	20000630 	.word	0x20000630

0000d494 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d494:	4a11      	ldr	r2, [pc, #68]	; (d4dc <z_arm_prep_c+0x48>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    d496:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d498:	4b11      	ldr	r3, [pc, #68]	; (d4e0 <z_arm_prep_c+0x4c>)
    d49a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    d49e:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    d4a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d4a4:	f3bf 8f6f 	isb	sy
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
    d4a8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    d4ac:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
    d4b0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR &= (~(FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk));
    d4b4:	4a0b      	ldr	r2, [pc, #44]	; (d4e4 <z_arm_prep_c+0x50>)
    d4b6:	6853      	ldr	r3, [r2, #4]
    d4b8:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
    d4bc:	6053      	str	r3, [r2, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    d4be:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d4c2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    d4c6:	2300      	movs	r3, #0
    d4c8:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    d4cc:	f000 fcf6 	bl	debc <z_bss_zero>
	z_data_copy();
    d4d0:	f000 fcfe 	bl	ded0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    d4d4:	f000 f900 	bl	d6d8 <z_arm_int_lib_init>
	z_cstart();
    d4d8:	f000 fd2c 	bl	df34 <z_cstart>
    d4dc:	0000c200 	.word	0x0000c200
    d4e0:	e000ed00 	.word	0xe000ed00
    d4e4:	e000ef30 	.word	0xe000ef30

0000d4e8 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    d4e8:	f002 fb64 	bl	fbb4 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    d4ec:	2020      	movs	r0, #32
    msr BASEPRI, r0
    d4ee:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    d4f2:	4808      	ldr	r0, [pc, #32]	; (d514 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    d4f4:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    d4f8:	1840      	adds	r0, r0, r1
    msr PSP, r0
    d4fa:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    d4fe:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    d502:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    d504:	4308      	orrs	r0, r1
    msr CONTROL, r0
    d506:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    d50a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    d50e:	f7ff ffc1 	bl	d494 <z_arm_prep_c>
    d512:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    d514:	20000bd0 	.word	0x20000bd0

0000d518 <mem_manage_fault.isra.2>:
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    d518:	4b0c      	ldr	r3, [pc, #48]	; (d54c <mem_manage_fault.isra.2+0x34>)
    d51a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    d51c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    d51e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d520:	0792      	lsls	r2, r2, #30
    d522:	d508      	bpl.n	d536 <mem_manage_fault.isra.2+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    d524:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    d526:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d528:	0612      	lsls	r2, r2, #24
    d52a:	d504      	bpl.n	d536 <mem_manage_fault.isra.2+0x1e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    d52c:	b118      	cbz	r0, d536 <mem_manage_fault.isra.2+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    d52e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d530:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    d534:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    d536:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    d538:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    d53a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    d53c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    d53e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d540:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    d544:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    d546:	7008      	strb	r0, [r1, #0]

	return reason;
}
    d548:	4770      	bx	lr
    d54a:	bf00      	nop
    d54c:	e000ed00 	.word	0xe000ed00

0000d550 <bus_fault.isra.3>:
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    d550:	4b0d      	ldr	r3, [pc, #52]	; (d588 <bus_fault.isra.3+0x38>)
    d552:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    d554:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    d556:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d558:	0592      	lsls	r2, r2, #22
    d55a:	d508      	bpl.n	d56e <bus_fault.isra.3+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    d55c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    d55e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d560:	0412      	lsls	r2, r2, #16
    d562:	d504      	bpl.n	d56e <bus_fault.isra.3+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    d564:	b118      	cbz	r0, d56e <bus_fault.isra.3+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    d566:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d568:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    d56c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    d56e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    d570:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    d572:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d574:	05d2      	lsls	r2, r2, #23
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    d576:	4a04      	ldr	r2, [pc, #16]	; (d588 <bus_fault.isra.3+0x38>)
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    d578:	bf58      	it	pl
    d57a:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    d57c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    d57e:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    d582:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    d584:	7008      	strb	r0, [r1, #0]

	return reason;
}
    d586:	4770      	bx	lr
    d588:	e000ed00 	.word	0xe000ed00

0000d58c <usage_fault.isra.4>:
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    d58c:	4b07      	ldr	r3, [pc, #28]	; (d5ac <usage_fault.isra.4+0x20>)

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;

	return reason;
}
    d58e:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    d590:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    d592:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    d594:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    d596:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    d598:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    d59a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    d59c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    d59e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d5a0:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    d5a4:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    d5a8:	629a      	str	r2, [r3, #40]	; 0x28
}
    d5aa:	4770      	bx	lr
    d5ac:	e000ed00 	.word	0xe000ed00

0000d5b0 <secure_fault.isra.5>:
 */
static void secure_fault(const z_arch_esf_t *esf)
{
	PR_FAULT_INFO("***** SECURE FAULT *****");

	STORE_xFAR(sfar, SAU->SFAR);
    d5b0:	4b0d      	ldr	r3, [pc, #52]	; (d5e8 <secure_fault.isra.5+0x38>)
    d5b2:	699a      	ldr	r2, [r3, #24]
	if ((SAU->SFSR & SAU_SFSR_SFARVALID_Msk) != 0) {
    d5b4:	695a      	ldr	r2, [r3, #20]
		PR_EXC("  Address: 0x%x", sfar);
	}

	/* bits are sticky: they stack and must be reset */
	if ((SAU->SFSR & SAU_SFSR_INVEP_Msk) != 0) {
    d5b6:	695a      	ldr	r2, [r3, #20]
    d5b8:	07d0      	lsls	r0, r2, #31
    d5ba:	d40f      	bmi.n	d5dc <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid entry point");
	} else if ((SAU->SFSR & SAU_SFSR_INVIS_Msk) != 0) {
    d5bc:	695a      	ldr	r2, [r3, #20]
    d5be:	0791      	lsls	r1, r2, #30
    d5c0:	d40c      	bmi.n	d5dc <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid integrity signature");
	} else if ((SAU->SFSR & SAU_SFSR_INVER_Msk) != 0) {
    d5c2:	695a      	ldr	r2, [r3, #20]
    d5c4:	0752      	lsls	r2, r2, #29
    d5c6:	d409      	bmi.n	d5dc <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid exception return");
	} else if ((SAU->SFSR & SAU_SFSR_AUVIOL_Msk) != 0) {
    d5c8:	695a      	ldr	r2, [r3, #20]
    d5ca:	0710      	lsls	r0, r2, #28
    d5cc:	d406      	bmi.n	d5dc <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Attribution unit violation");
	} else if ((SAU->SFSR & SAU_SFSR_INVTRAN_Msk) != 0) {
    d5ce:	695a      	ldr	r2, [r3, #20]
    d5d0:	06d1      	lsls	r1, r2, #27
    d5d2:	d403      	bmi.n	d5dc <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid transition");
	} else if ((SAU->SFSR & SAU_SFSR_LSPERR_Msk) != 0) {
    d5d4:	695a      	ldr	r2, [r3, #20]
    d5d6:	0692      	lsls	r2, r2, #26
		PR_FAULT_INFO("  Lazy state preservation");
	} else if ((SAU->SFSR & SAU_SFSR_LSERR_Msk) != 0) {
    d5d8:	bf58      	it	pl
    d5da:	695a      	ldrpl	r2, [r3, #20]
		PR_FAULT_INFO("  Lazy state error");
	}

	/* clear SFSR sticky bits */
	SAU->SFSR |= 0xFF;
    d5dc:	695a      	ldr	r2, [r3, #20]
    d5de:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    d5e2:	615a      	str	r2, [r3, #20]
}
    d5e4:	4770      	bx	lr
    d5e6:	bf00      	nop
    d5e8:	e000edd0 	.word	0xe000edd0

0000d5ec <z_arm_fault>:
 *
 * Note: exc_return argument shall only be used by the Fault handler if we are
 * running a Secure Firmware.
 */
void z_arm_fault(z_arch_esf_t *esf, u32_t exc_return)
{
    d5ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d5ee:	4604      	mov	r4, r0
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d5f0:	4a31      	ldr	r2, [pc, #196]	; (d6b8 <z_arm_fault+0xcc>)
	bool recoverable;

#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    d5f2:	f001 407f 	and.w	r0, r1, #4278190080	; 0xff000000
    d5f6:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d5fa:	6853      	ldr	r3, [r2, #4]
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    d5fc:	d159      	bne.n	d6b2 <z_arm_fault+0xc6>
			EXC_RETURN_INDICATOR_PREFIX) {
		/* Invalid EXC_RETURN value */
		goto _exit_fatal;
	}
	if ((exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) == 0U) {
    d5fe:	f011 0001 	ands.w	r0, r1, #1
    d602:	d00a      	beq.n	d61a <z_arm_fault+0x2e>
		 * This is a fatal error.
		 */
		goto _exit_fatal;
	}

	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
    d604:	0648      	lsls	r0, r1, #25
    d606:	d411      	bmi.n	d62c <z_arm_fault+0x40>

		/* Handle the actual fault.
		 * Extract the correct stack frame from the Non-Secure state
		 * and supply it to the fault handing function.
		 */
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    d608:	f011 0008 	ands.w	r0, r1, #8
    d60c:	d009      	beq.n	d622 <z_arm_fault+0x36>
  __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
    d60e:	f3ef 8489 	mrs	r4, PSP_NS
			esf = (z_arch_esf_t *)__TZ_get_PSP_NS();
			if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) == 0) {
    d612:	6850      	ldr	r0, [r2, #4]
    d614:	f410 6000 	ands.w	r0, r0, #2048	; 0x800
    d618:	d108      	bne.n	d62c <z_arm_fault+0x40>

#if defined(CONFIG_ARM_SECURE_FIRMWARE) || \
	defined(CONFIG_ARM_NONSECURE_FIRMWARE)
_exit_fatal:
#endif
	z_arm_fatal_error(reason, esf);
    d61a:	4621      	mov	r1, r4
    d61c:	f002 fc06 	bl	fe2c <z_arm_fatal_error>
    d620:	e025      	b.n	d66e <z_arm_fault+0x82>
  __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
    d622:	f3ef 8488 	mrs	r4, MSP_NS
			if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
    d626:	6852      	ldr	r2, [r2, #4]
    d628:	0511      	lsls	r1, r2, #20
    d62a:	d4f6      	bmi.n	d61a <z_arm_fault+0x2e>
	*recoverable = false;
    d62c:	2200      	movs	r2, #0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d62e:	f3c3 0308 	ubfx	r3, r3, #0, #9
	switch (fault) {
    d632:	3b03      	subs	r3, #3
	*recoverable = false;
    d634:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    d638:	2b04      	cmp	r3, #4
    d63a:	d830      	bhi.n	d69e <z_arm_fault+0xb2>
    d63c:	e8df f003 	tbb	[pc, r3]
    d640:	26353103 	.word	0x26353103
    d644:	2d          	.byte	0x2d
    d645:	00          	.byte	0x00
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    d646:	4b1c      	ldr	r3, [pc, #112]	; (d6b8 <z_arm_fault+0xcc>)
    d648:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    d64a:	0792      	lsls	r2, r2, #30
    d64c:	d427      	bmi.n	d69e <z_arm_fault+0xb2>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    d64e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    d650:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
    d654:	d007      	beq.n	d666 <z_arm_fault+0x7a>
		if (SCB_MMFSR != 0) {
    d656:	3328      	adds	r3, #40	; 0x28
    d658:	781b      	ldrb	r3, [r3, #0]
    d65a:	b153      	cbz	r3, d672 <z_arm_fault+0x86>
			reason = mem_manage_fault(esf, 1, recoverable);
    d65c:	2001      	movs	r0, #1
    d65e:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    d662:	f7ff ff59 	bl	d518 <mem_manage_fault.isra.2>
	if (recoverable) {
    d666:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d66a:	2b00      	cmp	r3, #0
    d66c:	d0d5      	beq.n	d61a <z_arm_fault+0x2e>
}
    d66e:	b003      	add	sp, #12
    d670:	bd30      	pop	{r4, r5, pc}
		} else if (SCB_BFSR != 0) {
    d672:	4b12      	ldr	r3, [pc, #72]	; (d6bc <z_arm_fault+0xd0>)
    d674:	781b      	ldrb	r3, [r3, #0]
    d676:	b12b      	cbz	r3, d684 <z_arm_fault+0x98>
			reason = bus_fault(esf, 1, recoverable);
    d678:	2001      	movs	r0, #1
    d67a:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    d67e:	f7ff ff67 	bl	d550 <bus_fault.isra.3>
    d682:	e7f0      	b.n	d666 <z_arm_fault+0x7a>
		} else if (SCB_UFSR != 0) {
    d684:	4b0e      	ldr	r3, [pc, #56]	; (d6c0 <z_arm_fault+0xd4>)
    d686:	8818      	ldrh	r0, [r3, #0]
    d688:	b285      	uxth	r5, r0
    d68a:	b115      	cbz	r5, d692 <z_arm_fault+0xa6>
		reason = usage_fault(esf);
    d68c:	f7ff ff7e 	bl	d58c <usage_fault.isra.4>
    d690:	e7e9      	b.n	d666 <z_arm_fault+0x7a>
		} else if (SAU->SFSR != 0) {
    d692:	4b0c      	ldr	r3, [pc, #48]	; (d6c4 <z_arm_fault+0xd8>)
    d694:	6958      	ldr	r0, [r3, #20]
    d696:	2800      	cmp	r0, #0
    d698:	d0e5      	beq.n	d666 <z_arm_fault+0x7a>
		secure_fault(esf);
    d69a:	f7ff ff89 	bl	d5b0 <secure_fault.isra.5>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    d69e:	2000      	movs	r0, #0
    d6a0:	e7e1      	b.n	d666 <z_arm_fault+0x7a>
		reason = mem_manage_fault(esf, 0, recoverable);
    d6a2:	f10d 0107 	add.w	r1, sp, #7
    d6a6:	2000      	movs	r0, #0
    d6a8:	e7db      	b.n	d662 <z_arm_fault+0x76>
		reason = bus_fault(esf, 0, recoverable);
    d6aa:	f10d 0107 	add.w	r1, sp, #7
    d6ae:	2000      	movs	r0, #0
    d6b0:	e7e5      	b.n	d67e <z_arm_fault+0x92>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    d6b2:	2000      	movs	r0, #0
    d6b4:	e7b1      	b.n	d61a <z_arm_fault+0x2e>
    d6b6:	bf00      	nop
    d6b8:	e000ed00 	.word	0xe000ed00
    d6bc:	e000ed29 	.word	0xe000ed29
    d6c0:	e000ed2a 	.word	0xe000ed2a
    d6c4:	e000edd0 	.word	0xe000edd0

0000d6c8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    d6c8:	4a02      	ldr	r2, [pc, #8]	; (d6d4 <z_arm_fault_init+0xc>)
    d6ca:	6953      	ldr	r3, [r2, #20]
    d6cc:	f043 0310 	orr.w	r3, r3, #16
    d6d0:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    d6d2:	4770      	bx	lr
    d6d4:	e000ed00 	.word	0xe000ed00

0000d6d8 <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    d6d8:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d6da:	2120      	movs	r1, #32
    d6dc:	4803      	ldr	r0, [pc, #12]	; (d6ec <z_arm_int_lib_init+0x14>)
    d6de:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    d6e0:	3301      	adds	r3, #1
    d6e2:	2b41      	cmp	r3, #65	; 0x41
    d6e4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    d6e8:	d1f9      	bne.n	d6de <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    d6ea:	4770      	bx	lr
    d6ec:	e000e100 	.word	0xe000e100

0000d6f0 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    d6f0:	b538      	push	{r3, r4, r5, lr}
    d6f2:	4605      	mov	r5, r0
	__asm__ volatile(
    d6f4:	f04f 0320 	mov.w	r3, #32
    d6f8:	f3ef 8411 	mrs	r4, BASEPRI
    d6fc:	f383 8811 	msr	BASEPRI, r3
    d700:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    d704:	f002 fd70 	bl	101e8 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    d708:	4b0a      	ldr	r3, [pc, #40]	; (d734 <z_impl_k_thread_abort+0x44>)
    d70a:	689b      	ldr	r3, [r3, #8]
    d70c:	42ab      	cmp	r3, r5
    d70e:	d10b      	bne.n	d728 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    d710:	4b09      	ldr	r3, [pc, #36]	; (d738 <z_impl_k_thread_abort+0x48>)
    d712:	685a      	ldr	r2, [r3, #4]
    d714:	f3c2 0208 	ubfx	r2, r2, #0, #9
    d718:	b912      	cbnz	r2, d720 <z_impl_k_thread_abort+0x30>
	z_check_stack_sentinel();

#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = z_arch_swap(key);
    d71a:	4620      	mov	r0, r4
    d71c:	f7ff fe2a 	bl	d374 <z_arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    d720:	685a      	ldr	r2, [r3, #4]
    d722:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    d726:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    d728:	4620      	mov	r0, r4
}
    d72a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    d72e:	f002 bcd4 	b.w	100da <z_reschedule_irqlock>
    d732:	bf00      	nop
    d734:	20000630 	.word	0x20000630
    d738:	e000ed00 	.word	0xe000ed00

0000d73c <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    d73c:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    d73e:	4b0e      	ldr	r3, [pc, #56]	; (d778 <z_arm_configure_static_mpu_regions+0x3c>)
{
    d740:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
    d742:	9302      	str	r3, [sp, #8]
    d744:	4b0d      	ldr	r3, [pc, #52]	; (d77c <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    d746:	4c0e      	ldr	r4, [pc, #56]	; (d780 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
    d748:	9303      	str	r3, [sp, #12]
    d74a:	4b0e      	ldr	r3, [pc, #56]	; (d784 <z_arm_configure_static_mpu_regions+0x48>)
	const struct k_mem_partition *static_regions[] = {
    d74c:	a808      	add	r0, sp, #32
		const struct k_mem_partition ramfunc_region =
    d74e:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
    d750:	ab02      	add	r3, sp, #8
    d752:	f840 3d1c 	str.w	r3, [r0, #-28]!
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    d756:	4a0c      	ldr	r2, [pc, #48]	; (d788 <z_arm_configure_static_mpu_regions+0x4c>)
    d758:	4623      	mov	r3, r4
    d75a:	2101      	movs	r1, #1
    d75c:	f000 f902 	bl	d964 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
    d760:	2300      	movs	r3, #0
    d762:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    d764:	4b09      	ldr	r3, [pc, #36]	; (d78c <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d766:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    d768:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d76a:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
    d76c:	9305      	str	r3, [sp, #20]
    d76e:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d770:	f000 f902 	bl	d978 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    d774:	b008      	add	sp, #32
    d776:	bd10      	pop	{r4, pc}
    d778:	20000000 	.word	0x20000000
    d77c:	00000000 	.word	0x00000000
    d780:	20010000 	.word	0x20010000
    d784:	00010006 	.word	0x00010006
    d788:	20000000 	.word	0x20000000
    d78c:	20000000 	.word	0x20000000

0000d790 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
    d790:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    d792:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    d794:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    d796:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
    d79a:	f004 021f 	and.w	r2, r4, #31
    d79e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    d7a0:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    d7a2:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    d7a4:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    d7a8:	4904      	ldr	r1, [pc, #16]	; (d7bc <region_init+0x2c>)
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    d7aa:	f043 0301 	orr.w	r3, r3, #1
    d7ae:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
    d7b2:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    d7b4:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    d7b6:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    d7b8:	bd10      	pop	{r4, pc}
    d7ba:	bf00      	nop
    d7bc:	e000ed90 	.word	0xe000ed90

0000d7c0 <mpu_configure_regions.constprop.1>:

/* This internal function programs a set of given MPU regions
 * over a background memory area, optionally performing a
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
    d7c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d7c4:	4680      	mov	r8, r0
    d7c6:	4689      	mov	r9, r1
    d7c8:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    d7ca:	2700      	movs	r7, #0
	MPU->RNR = index;
    d7cc:	4d48      	ldr	r5, [pc, #288]	; (d8f0 <mpu_configure_regions.constprop.1+0x130>)
static int mpu_configure_regions(const struct k_mem_partition
    d7ce:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    d7d0:	454f      	cmp	r7, r9
    d7d2:	da07      	bge.n	d7e4 <mpu_configure_regions.constprop.1+0x24>
		if (regions[i]->size == 0U) {
    d7d4:	f858 3027 	ldr.w	r3, [r8, r7, lsl #2]
    d7d8:	685e      	ldr	r6, [r3, #4]
    d7da:	b3c6      	cbz	r6, d84e <mpu_configure_regions.constprop.1+0x8e>
		&&
    d7dc:	2e1f      	cmp	r6, #31
    d7de:	d805      	bhi.n	d7ec <mpu_configure_regions.constprop.1+0x2c>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    d7e0:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    d7e4:	4620      	mov	r0, r4
    d7e6:	b005      	add	sp, #20
    d7e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    d7ec:	06f2      	lsls	r2, r6, #27
    d7ee:	d1f7      	bne.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
		((part->start &
    d7f0:	f8d3 a000 	ldr.w	sl, [r3]
		&&
    d7f4:	f01a 0f1f 	tst.w	sl, #31
    d7f8:	d1f2      	bne.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d7fa:	4650      	mov	r0, sl
    d7fc:	f001 ffe7 	bl	f7ce <arm_cmse_mpu_region_get>
    d800:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d802:	eb06 000a 	add.w	r0, r6, sl
    d806:	3801      	subs	r0, #1
    d808:	f001 ffe1 	bl	f7ce <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    d80c:	4583      	cmp	fp, r0
    d80e:	d1e7      	bne.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
		if ((u_reg_index == -EINVAL) ||
    d810:	f11b 0f16 	cmn.w	fp, #22
    d814:	d0e4      	beq.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
			(u_reg_index > (reg_index - 1))) {
    d816:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    d818:	455b      	cmp	r3, fp
    d81a:	dbe1      	blt.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
	MPU->RNR = index;
    d81c:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    d820:	68e8      	ldr	r0, [r5, #12]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d822:	f858 1027 	ldr.w	r1, [r8, r7, lsl #2]
	MPU->RNR = index;
    d826:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    d82a:	692e      	ldr	r6, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    d82c:	f020 001f 	bic.w	r0, r0, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d830:	e9d1 3200 	ldrd	r3, r2, [r1]
    d834:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
    d836:	4298      	cmp	r0, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    d838:	f046 061f 	orr.w	r6, r6, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d83c:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
    d840:	d118      	bne.n	d874 <mpu_configure_regions.constprop.1+0xb4>
    d842:	4556      	cmp	r6, sl
    d844:	d105      	bne.n	d852 <mpu_configure_regions.constprop.1+0x92>
			mpu_configure_region(u_reg_index, regions[i]);
    d846:	fa5f f08b 	uxtb.w	r0, fp
    d84a:	f002 fb04 	bl	fe56 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    d84e:	3701      	adds	r7, #1
    d850:	e7be      	b.n	d7d0 <mpu_configure_regions.constprop.1+0x10>
	MPU->RNR = index;
    d852:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d856:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    d858:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d85c:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    d860:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d862:	60ea      	str	r2, [r5, #12]
			reg_index =
    d864:	b2e0      	uxtb	r0, r4
			reg_index =
    d866:	f002 faf6 	bl	fe56 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    d86a:	f110 0f16 	cmn.w	r0, #22
    d86e:	d0b7      	beq.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
			reg_index++;
    d870:	1c44      	adds	r4, r0, #1
    d872:	e7ec      	b.n	d84e <mpu_configure_regions.constprop.1+0x8e>
	MPU->RNR = index;
    d874:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    d878:	692a      	ldr	r2, [r5, #16]
    d87a:	3b01      	subs	r3, #1
    d87c:	f023 031f 	bic.w	r3, r3, #31
    d880:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    d884:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
    d886:	4556      	cmp	r6, sl
    d888:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    d88a:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
    d88c:	d0eb      	beq.n	d866 <mpu_configure_regions.constprop.1+0xa6>
			reg_index =
    d88e:	f002 fae2 	bl	fe56 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    d892:	f110 0f16 	cmn.w	r0, #22
    d896:	d0a3      	beq.n	d7e0 <mpu_configure_regions.constprop.1+0x20>
	MPU->RNR = index;
    d898:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    d89c:	68ea      	ldr	r2, [r5, #12]
    d89e:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
    d8a2:	3e01      	subs	r6, #1
	attr->rbar = MPU->RBAR &
    d8a4:	f362 0304 	bfi	r3, r2, #0, #5
    d8a8:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    d8ac:	692b      	ldr	r3, [r5, #16]
    d8ae:	f89d 2008 	ldrb.w	r2, [sp, #8]
    d8b2:	085b      	lsrs	r3, r3, #1
    d8b4:	f363 1247 	bfi	r2, r3, #5, #3
    d8b8:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
    d8bc:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
			reg_index++;
    d8c0:	3001      	adds	r0, #1
			fill_region.base = regions[i]->start +
    d8c2:	e9d2 3200 	ldrd	r3, r2, [r2]
    d8c6:	4413      	add	r3, r2
    d8c8:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
    d8ca:	f023 031f 	bic.w	r3, r3, #31
    d8ce:	441e      	add	r6, r3
    d8d0:	eba6 060a 	sub.w	r6, r6, sl
    d8d4:	b2c4      	uxtb	r4, r0
    d8d6:	f026 061f 	bic.w	r6, r6, #31

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
    d8da:	2c0f      	cmp	r4, #15
			fill_region.attr.r_limit =
    d8dc:	9603      	str	r6, [sp, #12]
    d8de:	f63f af7f 	bhi.w	d7e0 <mpu_configure_regions.constprop.1+0x20>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    d8e2:	4620      	mov	r0, r4
    d8e4:	4669      	mov	r1, sp
    d8e6:	f7ff ff53 	bl	d790 <region_init>
			reg_index++;
    d8ea:	3401      	adds	r4, #1
    d8ec:	e7af      	b.n	d84e <mpu_configure_regions.constprop.1+0x8e>
    d8ee:	bf00      	nop
    d8f0:	e000ed90 	.word	0xe000ed90

0000d8f4 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    d8f4:	2205      	movs	r2, #5
    d8f6:	4b03      	ldr	r3, [pc, #12]	; (d904 <arm_core_mpu_enable+0x10>)
    d8f8:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    d8fa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d8fe:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    d902:	4770      	bx	lr
    d904:	e000ed90 	.word	0xe000ed90

0000d908 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    d908:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    d90c:	2200      	movs	r2, #0
    d90e:	4b01      	ldr	r3, [pc, #4]	; (d914 <arm_core_mpu_disable+0xc>)
    d910:	605a      	str	r2, [r3, #4]
}
    d912:	4770      	bx	lr
    d914:	e000ed90 	.word	0xe000ed90

0000d918 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
    d918:	b570      	push	{r4, r5, r6, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    d91a:	4d0e      	ldr	r5, [pc, #56]	; (d954 <arm_mpu_init+0x3c>)
    d91c:	682e      	ldr	r6, [r5, #0]
    d91e:	2e10      	cmp	r6, #16
    d920:	d815      	bhi.n	d94e <arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d922:	2400      	movs	r4, #0
	arm_core_mpu_disable();
    d924:	f7ff fff0 	bl	d908 <arm_core_mpu_disable>
	MPU->MAIR0 =
    d928:	4b0b      	ldr	r3, [pc, #44]	; (d958 <arm_mpu_init+0x40>)
    d92a:	4a0c      	ldr	r2, [pc, #48]	; (d95c <arm_mpu_init+0x44>)
    d92c:	631a      	str	r2, [r3, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d92e:	42a6      	cmp	r6, r4
    d930:	d105      	bne.n	d93e <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    d932:	4b0b      	ldr	r3, [pc, #44]	; (d960 <arm_mpu_init+0x48>)
    d934:	701e      	strb	r6, [r3, #0]


	arm_core_mpu_enable();
    d936:	f7ff ffdd 	bl	d8f4 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    d93a:	2000      	movs	r0, #0
}
    d93c:	bd70      	pop	{r4, r5, r6, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    d93e:	6869      	ldr	r1, [r5, #4]
    d940:	4620      	mov	r0, r4
    d942:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    d946:	f7ff ff23 	bl	d790 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d94a:	3401      	adds	r4, #1
    d94c:	e7ef      	b.n	d92e <arm_mpu_init+0x16>
		return -1;
    d94e:	f04f 30ff 	mov.w	r0, #4294967295
    d952:	e7f3      	b.n	d93c <arm_mpu_init+0x24>
    d954:	0001054c 	.word	0x0001054c
    d958:	e000ed90 	.word	0xe000ed90
    d95c:	0044ffaa 	.word	0x0044ffaa
    d960:	2000068c 	.word	0x2000068c

0000d964 <arm_core_mpu_configure_static_mpu_regions>:
{
    d964:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    d966:	4c03      	ldr	r4, [pc, #12]	; (d974 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    d968:	7822      	ldrb	r2, [r4, #0]
    d96a:	f7ff ff29 	bl	d7c0 <mpu_configure_regions.constprop.1>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    d96e:	7020      	strb	r0, [r4, #0]
}
    d970:	bd10      	pop	{r4, pc}
    d972:	bf00      	nop
    d974:	2000068c 	.word	0x2000068c

0000d978 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    d978:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d97c:	4689      	mov	r9, r1
    d97e:	4607      	mov	r7, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d980:	2600      	movs	r6, #0
    d982:	f8df 8090 	ldr.w	r8, [pc, #144]	; da14 <arm_core_mpu_mark_areas_for_dynamic_regions+0x9c>
		if (dyn_reg_info[i].index == -EINVAL) {

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    d986:	f8df a090 	ldr.w	sl, [pc, #144]	; da18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
	MPU->RNR = index;
    d98a:	4c21      	ldr	r4, [pc, #132]	; (da10 <arm_core_mpu_mark_areas_for_dynamic_regions+0x98>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d98c:	454e      	cmp	r6, r9
    d98e:	da19      	bge.n	d9c4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4c>
		if (dyn_region_areas[i].size == 0U) {
    d990:	f8d7 b004 	ldr.w	fp, [r7, #4]
    d994:	f1bb 0f00 	cmp.w	fp, #0
    d998:	d036      	beq.n	da08 <arm_core_mpu_mark_areas_for_dynamic_regions+0x90>
			get_region_index(dyn_region_areas[i].start,
    d99a:	683b      	ldr	r3, [r7, #0]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d99c:	4618      	mov	r0, r3
    d99e:	9301      	str	r3, [sp, #4]
    d9a0:	f001 ff15 	bl	f7ce <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d9a4:	9b01      	ldr	r3, [sp, #4]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d9a6:	4605      	mov	r5, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d9a8:	eb0b 0003 	add.w	r0, fp, r3
    d9ac:	3801      	subs	r0, #1
    d9ae:	f001 ff0e 	bl	f7ce <arm_cmse_mpu_region_get>
    d9b2:	2314      	movs	r3, #20
	if (region_start_addr == region_end_addr) {
    d9b4:	4285      	cmp	r5, r0
    d9b6:	fb03 f306 	mul.w	r3, r3, r6
    d9ba:	d006      	beq.n	d9ca <arm_core_mpu_mark_areas_for_dynamic_regions+0x52>
		dyn_reg_info[i].index =
    d9bc:	f06f 0215 	mvn.w	r2, #21
    d9c0:	f848 2003 	str.w	r2, [r8, r3]
}
    d9c4:	b003      	add	sp, #12
    d9c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_reg_info[i].index == -EINVAL) {
    d9ca:	f115 0f16 	cmn.w	r5, #22
		dyn_reg_info[i].index =
    d9ce:	f848 5003 	str.w	r5, [r8, r3]
		if (dyn_reg_info[i].index == -EINVAL) {
    d9d2:	d0f7      	beq.n	d9c4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4c>
		if (dyn_reg_info[i].index >= static_regions_num) {
    d9d4:	f89a 2000 	ldrb.w	r2, [sl]
    d9d8:	42aa      	cmp	r2, r5
    d9da:	ddf3      	ble.n	d9c4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4c>
	MPU->RNR = index;
    d9dc:	60a5      	str	r5, [r4, #8]
	attr->rbar = MPU->RBAR &
    d9de:	4443      	add	r3, r8
	MPU->RNR = index;
    d9e0:	60a5      	str	r5, [r4, #8]
	attr->rbar = MPU->RBAR &
    d9e2:	68e0      	ldr	r0, [r4, #12]
    d9e4:	7b19      	ldrb	r1, [r3, #12]
    d9e6:	f360 0104 	bfi	r1, r0, #0, #5
    d9ea:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    d9ec:	6921      	ldr	r1, [r4, #16]
    d9ee:	7b18      	ldrb	r0, [r3, #12]
    d9f0:	0849      	lsrs	r1, r1, #1
    d9f2:	f361 1047 	bfi	r0, r1, #5, #3
    d9f6:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    d9f8:	68e2      	ldr	r2, [r4, #12]
    d9fa:	f022 021f 	bic.w	r2, r2, #31
    d9fe:	605a      	str	r2, [r3, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    da00:	6922      	ldr	r2, [r4, #16]
    da02:	f022 021f 	bic.w	r2, r2, #31
    da06:	611a      	str	r2, [r3, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    da08:	3601      	adds	r6, #1
    da0a:	370c      	adds	r7, #12
    da0c:	e7be      	b.n	d98c <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
    da0e:	bf00      	nop
    da10:	e000ed90 	.word	0xe000ed90
    da14:	20000544 	.word	0x20000544
    da18:	2000068c 	.word	0x2000068c

0000da1c <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    da1c:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
    da1e:	4b0c      	ldr	r3, [pc, #48]	; (da50 <arm_core_mpu_configure_dynamic_mpu_regions+0x34>)
    da20:	460e      	mov	r6, r1
    da22:	781c      	ldrb	r4, [r3, #0]
    da24:	4605      	mov	r5, r0
    da26:	4623      	mov	r3, r4
  mpu->RLAR = 0U;
    da28:	2100      	movs	r1, #0
  mpu->RNR = rnr;
    da2a:	4a0a      	ldr	r2, [pc, #40]	; (da54 <arm_core_mpu_configure_dynamic_mpu_regions+0x38>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    da2c:	2b0f      	cmp	r3, #15
    da2e:	dd0b      	ble.n	da48 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>

	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
    da30:	4b09      	ldr	r3, [pc, #36]	; (da58 <arm_core_mpu_configure_dynamic_mpu_regions+0x3c>)
    da32:	1d19      	adds	r1, r3, #4
    da34:	6818      	ldr	r0, [r3, #0]
    da36:	f7ff feab 	bl	d790 <region_init>
	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    da3a:	4622      	mov	r2, r4
    da3c:	4631      	mov	r1, r6
    da3e:	4628      	mov	r0, r5
}
    da40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    da44:	f7ff bebc 	b.w	d7c0 <mpu_configure_regions.constprop.1>
    da48:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
    da4a:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    da4c:	3301      	adds	r3, #1
    da4e:	e7ed      	b.n	da2c <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
    da50:	2000068c 	.word	0x2000068c
    da54:	e000ed90 	.word	0xe000ed90
    da58:	20000544 	.word	0x20000544

0000da5c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    da5c:	4b01      	ldr	r3, [pc, #4]	; (da64 <__stdout_hook_install+0x8>)
    da5e:	6018      	str	r0, [r3, #0]
}
    da60:	4770      	bx	lr
    da62:	bf00      	nop
    da64:	200013f8 	.word	0x200013f8

0000da68 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
    da68:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_hwfc_t hwfc;
#ifdef UARTE_CONFIG_STOP_Two
	bool two_stop_bits = false;
#endif

	switch (cfg->stop_bits) {
    da6a:	794b      	ldrb	r3, [r1, #5]
    da6c:	2b01      	cmp	r3, #1
    da6e:	d029      	beq.n	dac4 <uarte_nrfx_configure+0x5c>
    da70:	2b03      	cmp	r3, #3
    da72:	d124      	bne.n	dabe <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		break;
#ifdef UARTE_CONFIG_STOP_Two
	case UART_CFG_STOP_BITS_2:
		two_stop_bits = true;
    da74:	2601      	movs	r6, #1
#endif
	default:
		return -ENOTSUP;
	}

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    da76:	798b      	ldrb	r3, [r1, #6]
    da78:	2b03      	cmp	r3, #3
    da7a:	d120      	bne.n	dabe <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    da7c:	79cd      	ldrb	r5, [r1, #7]
    da7e:	b12d      	cbz	r5, da8c <uarte_nrfx_configure+0x24>
    da80:	2d01      	cmp	r5, #1
    da82:	d11c      	bne.n	dabe <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
    da84:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    da86:	689b      	ldr	r3, [r3, #8]
    da88:	791b      	ldrb	r3, [r3, #4]
    da8a:	b1c3      	cbz	r3, dabe <uarte_nrfx_configure+0x56>
		break;
	default:
		return -ENOTSUP;
	}

	switch (cfg->parity) {
    da8c:	790a      	ldrb	r2, [r1, #4]
    da8e:	b112      	cbz	r2, da96 <uarte_nrfx_configure+0x2e>
    da90:	2a02      	cmp	r2, #2
    da92:	d114      	bne.n	dabe <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		parity = NRF_UARTE_PARITY_INCLUDED;
    da94:	220e      	movs	r2, #14
	switch (baudrate) {
    da96:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
    da9a:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
    da9c:	689b      	ldr	r3, [r3, #8]
    da9e:	681c      	ldr	r4, [r3, #0]
	switch (baudrate) {
    daa0:	680b      	ldr	r3, [r1, #0]
    daa2:	42bb      	cmp	r3, r7
    daa4:	d074      	beq.n	db90 <uarte_nrfx_configure+0x128>
    daa6:	d829      	bhi.n	dafc <uarte_nrfx_configure+0x94>
    daa8:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    daac:	d06a      	beq.n	db84 <uarte_nrfx_configure+0x11c>
    daae:	d814      	bhi.n	dada <uarte_nrfx_configure+0x72>
    dab0:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    dab4:	d04f      	beq.n	db56 <uarte_nrfx_configure+0xee>
    dab6:	d807      	bhi.n	dac8 <uarte_nrfx_configure+0x60>
    dab8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    dabc:	d07d      	beq.n	dbba <uarte_nrfx_configure+0x152>
		return -ENOTSUP;
    dabe:	f06f 0022 	mvn.w	r0, #34	; 0x22
    dac2:	e05b      	b.n	db7c <uarte_nrfx_configure+0x114>
	bool two_stop_bits = false;
    dac4:	2600      	movs	r6, #0
    dac6:	e7d6      	b.n	da76 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    dac8:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    dacc:	d057      	beq.n	db7e <uarte_nrfx_configure+0x116>
    dace:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    dad2:	d1f4      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    dad4:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    dad8:	e03f      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    dada:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    dade:	d053      	beq.n	db88 <uarte_nrfx_configure+0x120>
    dae0:	d804      	bhi.n	daec <uarte_nrfx_configure+0x84>
    dae2:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    dae6:	d1ea      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    dae8:	4b35      	ldr	r3, [pc, #212]	; (dbc0 <uarte_nrfx_configure+0x158>)
    daea:	e036      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    daec:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    daf0:	d04c      	beq.n	db8c <uarte_nrfx_configure+0x124>
    daf2:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    daf6:	d1e2      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    daf8:	4b32      	ldr	r3, [pc, #200]	; (dbc4 <uarte_nrfx_configure+0x15c>)
    dafa:	e02e      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    dafc:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    db00:	d04f      	beq.n	dba2 <uarte_nrfx_configure+0x13a>
    db02:	d812      	bhi.n	db2a <uarte_nrfx_configure+0xc2>
    db04:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    db08:	42bb      	cmp	r3, r7
    db0a:	d044      	beq.n	db96 <uarte_nrfx_configure+0x12e>
    db0c:	d805      	bhi.n	db1a <uarte_nrfx_configure+0xb2>
    db0e:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    db12:	d1d4      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    db14:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    db18:	e01f      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    db1a:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    db1e:	d03d      	beq.n	db9c <uarte_nrfx_configure+0x134>
    db20:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    db24:	d1cb      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    db26:	4b28      	ldr	r3, [pc, #160]	; (dbc8 <uarte_nrfx_configure+0x160>)
    db28:	e017      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    db2a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    db2e:	d03e      	beq.n	dbae <uarte_nrfx_configure+0x146>
    db30:	d808      	bhi.n	db44 <uarte_nrfx_configure+0xdc>
    db32:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    db36:	d037      	beq.n	dba8 <uarte_nrfx_configure+0x140>
    db38:	4f24      	ldr	r7, [pc, #144]	; (dbcc <uarte_nrfx_configure+0x164>)
    db3a:	42bb      	cmp	r3, r7
    db3c:	d1bf      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    db3e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    db42:	e00a      	b.n	db5a <uarte_nrfx_configure+0xf2>
	switch (baudrate) {
    db44:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    db48:	d034      	beq.n	dbb4 <uarte_nrfx_configure+0x14c>
    db4a:	4f21      	ldr	r7, [pc, #132]	; (dbd0 <uarte_nrfx_configure+0x168>)
    db4c:	42bb      	cmp	r3, r7
    db4e:	d1b6      	bne.n	dabe <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    db50:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    db54:	e001      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = 0x00027000;
    db56:	f44f 331c 	mov.w	r3, #159744	; 0x27000

__STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type   * p_reg,
                                         nrf_uarte_parity_t parity,
                                         nrf_uarte_hwfc_t   hwfc)
{
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
    db5a:	432a      	orrs	r2, r5
}

__STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type   * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    db5c:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
    db60:	f8c4 256c 	str.w	r2, [r4, #1388]	; 0x56c
	}

	nrf_uarte_configure(get_uarte_instance(dev), parity, hwfc);

#ifdef UARTE_CONFIG_STOP_Two
	if (two_stop_bits) {
    db64:	b12e      	cbz	r6, db72 <uarte_nrfx_configure+0x10a>
		/* TODO Change this to nrfx HAL function when available */
		get_uarte_instance(dev)->CONFIG |=
    db66:	f8d4 356c 	ldr.w	r3, [r4, #1388]	; 0x56c
    db6a:	f043 0310 	orr.w	r3, r3, #16
    db6e:	f8c4 356c 	str.w	r3, [r4, #1388]	; 0x56c
			UARTE_CONFIG_STOP_Two << UARTE_CONFIG_STOP_Pos;
	}
#endif
	get_dev_data(dev)->uart_config = *cfg;
    db72:	6883      	ldr	r3, [r0, #8]
    db74:	c903      	ldmia	r1, {r0, r1}
    db76:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    db7a:	2000      	movs	r0, #0
}
    db7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    db7e:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    db82:	e7ea      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    db84:	4b13      	ldr	r3, [pc, #76]	; (dbd4 <uarte_nrfx_configure+0x16c>)
    db86:	e7e8      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    db88:	4b13      	ldr	r3, [pc, #76]	; (dbd8 <uarte_nrfx_configure+0x170>)
    db8a:	e7e6      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    db8c:	4b13      	ldr	r3, [pc, #76]	; (dbdc <uarte_nrfx_configure+0x174>)
    db8e:	e7e4      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    db90:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    db94:	e7e1      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    db96:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    db9a:	e7de      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    db9c:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    dba0:	e7db      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    dba2:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    dba6:	e7d8      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    dba8:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    dbac:	e7d5      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    dbae:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    dbb2:	e7d2      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    dbb4:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    dbb8:	e7cf      	b.n	db5a <uarte_nrfx_configure+0xf2>
		nrf_baudrate = 0x00014000;
    dbba:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    dbbe:	e7cc      	b.n	db5a <uarte_nrfx_configure+0xf2>
    dbc0:	00275000 	.word	0x00275000
    dbc4:	0075c000 	.word	0x0075c000
    dbc8:	013a9000 	.word	0x013a9000
    dbcc:	0003d090 	.word	0x0003d090
    dbd0:	000f4240 	.word	0x000f4240
    dbd4:	0013b000 	.word	0x0013b000
    dbd8:	003af000 	.word	0x003af000
    dbdc:	004ea000 	.word	0x004ea000

0000dbe0 <uarte_0_init>:
	return dev->config->config_info;
    dbe0:	6802      	ldr	r2, [r0, #0]
	#if defined(DT_NORDIC_NRF_UARTE_UART_0_RTS_PIN) && \
	    defined(DT_NORDIC_NRF_UARTE_UART_0_CTS_PIN)
		#define UARTE_0_CONFIG_RTS_CTS 1
	#endif

	UART_NRF_UARTE_DEVICE(0);
    dbe2:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
    dbe4:	6892      	ldr	r2, [r2, #8]
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    dbe6:	4b18      	ldr	r3, [pc, #96]	; (dc48 <uarte_0_init+0x68>)
    dbe8:	6814      	ldr	r4, [r2, #0]
    dbea:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	struct uarte_nrfx_data *data = get_dev_data(dev);
    dbee:	6885      	ldr	r5, [r0, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dbf0:	2103      	movs	r1, #3
    p_reg->OUTSET = set_mask;
    dbf2:	609a      	str	r2, [r3, #8]
    p_reg->PSEL.TXD = pseltxd;
    dbf4:	261d      	movs	r6, #29
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dbf6:	2200      	movs	r2, #0
    dbf8:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
    dbfc:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    dc00:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    dc04:	261c      	movs	r6, #28
    dc06:	f8c4 6514 	str.w	r6, [r4, #1300]	; 0x514
    p_reg->OUTSET = set_mask;
    dc0a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
    dc0e:	609e      	str	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dc10:	f8c3 126c 	str.w	r1, [r3, #620]	; 0x26c
    dc14:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
    p_reg->PSEL.RTS = pselrts;
    dc18:	231b      	movs	r3, #27
    dc1a:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    dc1e:	231a      	movs	r3, #26
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    dc20:	4629      	mov	r1, r5
    dc22:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    dc26:	f7ff ff1f 	bl	da68 <uarte_nrfx_configure>
	if (err) {
    dc2a:	b958      	cbnz	r0, dc44 <uarte_0_init+0x64>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    dc2c:	2308      	movs	r3, #8
    dc2e:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    dc32:	441d      	add	r5, r3
__STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                             uint8_t *        p_buffer,
                                             size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    p_reg->RXD.MAXCNT = length;
    dc34:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    dc36:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    dc3a:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    dc3e:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    dc42:	6023      	str	r3, [r4, #0]
	UART_NRF_UARTE_DEVICE(0);
    dc44:	bd70      	pop	{r4, r5, r6, pc}
    dc46:	bf00      	nop
    dc48:	50842500 	.word	0x50842500

0000dc4c <abi_getter>:
extern const struct fw_info_abi * const _ext_abis_start[];
extern const u32_t _ext_abis_size;
__noinit fw_info_abi_getter abi_getter_in;

int abi_getter(u32_t id, u32_t index, const struct fw_info_abi **abi)
{
    dc4c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!abi) {
    dc4e:	b1da      	cbz	r2, dc88 <abi_getter+0x3c>
		return -EFAULT;
	}

	bool id_found = false;

	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc50:	2300      	movs	r3, #0
	bool id_found = false;
    dc52:	461c      	mov	r4, r3
	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc54:	4e0e      	ldr	r6, [pc, #56]	; (dc90 <abi_getter+0x44>)
		const struct fw_info_abi *ext_abi = _ext_abis_start[i];
    dc56:	4f0f      	ldr	r7, [pc, #60]	; (dc94 <abi_getter+0x48>)
	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc58:	42b3      	cmp	r3, r6
    dc5a:	d306      	bcc.n	dc6a <abi_getter+0x1e>
				*abi = ext_abi;
				return 0;
			}
		}
	}
	return id_found ? -EBADF : -ENOENT;
    dc5c:	2c00      	cmp	r4, #0
    dc5e:	bf14      	ite	ne
    dc60:	f06f 0008 	mvnne.w	r0, #8
    dc64:	f06f 0001 	mvneq.w	r0, #1
    dc68:	e009      	b.n	dc7e <abi_getter+0x32>
		const struct fw_info_abi *ext_abi = _ext_abis_start[i];
    dc6a:	f857 5023 	ldr.w	r5, [r7, r3, lsl #2]
		if (ext_abi->abi_id == id) {
    dc6e:	f8d5 c00c 	ldr.w	ip, [r5, #12]
    dc72:	4560      	cmp	r0, ip
    dc74:	d106      	bne.n	dc84 <abi_getter+0x38>
			if (index-- == 0) {
    dc76:	1e4c      	subs	r4, r1, #1
    dc78:	b911      	cbnz	r1, dc80 <abi_getter+0x34>
				return 0;
    dc7a:	4608      	mov	r0, r1
				*abi = ext_abi;
    dc7c:	6015      	str	r5, [r2, #0]
}
    dc7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (index-- == 0) {
    dc80:	4621      	mov	r1, r4
			id_found = true;
    dc82:	2401      	movs	r4, #1
	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc84:	3301      	adds	r3, #1
    dc86:	e7e7      	b.n	dc58 <abi_getter+0xc>
		return -EFAULT;
    dc88:	f06f 000d 	mvn.w	r0, #13
    dc8c:	e7f7      	b.n	dc7e <abi_getter+0x32>
    dc8e:	bf00      	nop
    dc90:	00000000 	.word	0x00000000
    dc94:	00010c40 	.word	0x00010c40

0000dc98 <SystemInit>:
        /* Perform Secure-mode initialization routines. */

        /* Set all ARM SAU regions to NonSecure if TrustZone extensions are enabled.
        * Nordic SPU should handle Secure Attribution tasks */
        #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
          SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
    dc98:	4a52      	ldr	r2, [pc, #328]	; (dde4 <SystemInit+0x14c>)
    dc9a:	6813      	ldr	r3, [r2, #0]
    dc9c:	f043 0302 	orr.w	r3, r3, #2
    dca0:	6013      	str	r3, [r2, #0]
        #endif

        /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim 
         until one ADDR is not initialized. */
        uint32_t index = 0;
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dca2:	2200      	movs	r2, #0
    dca4:	00d3      	lsls	r3, r2, #3
    dca6:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
    dcaa:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    dcae:	3101      	adds	r1, #1
    dcb0:	d008      	beq.n	dcc4 <SystemInit+0x2c>
          #if defined ( __ICCARM__ )
              #pragma diag_suppress=Pa082
          #endif
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dcb2:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dcb6:	3201      	adds	r2, #1
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dcb8:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dcbc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dcc0:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dcc2:	d1ef      	bne.n	dca4 <SystemInit+0xc>
    }
    
    
    bool uicr_HFXOSRC_erased()
    {
        if ((NRF_UICR_S->HFXOSRC & UICR_HFXOSRC_HFXOSRC_Msk) != UICR_HFXOSRC_HFXOSRC_TCXO) {
    dcc4:	4a48      	ldr	r2, [pc, #288]	; (dde8 <SystemInit+0x150>)
    dcc6:	69d3      	ldr	r3, [r2, #28]
    dcc8:	f013 0301 	ands.w	r3, r3, #1
    dccc:	d03b      	beq.n	dd46 <SystemInit+0xae>
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcce:	4b47      	ldr	r3, [pc, #284]	; (ddec <SystemInit+0x154>)
    dcd0:	4619      	mov	r1, r3
    dcd2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    dcd6:	2a01      	cmp	r2, #1
    dcd8:	d1fb      	bne.n	dcd2 <SystemInit+0x3a>
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Wen;
    dcda:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcde:	f8d1 3400 	ldr.w	r3, [r1, #1024]	; 0x400
    dce2:	2b01      	cmp	r3, #1
    dce4:	d1fb      	bne.n	dcde <SystemInit+0x46>
        if ((NRF_UICR_S->HFXOSRC & UICR_HFXOSRC_HFXOSRC_Msk) != UICR_HFXOSRC_HFXOSRC_TCXO) {
    dce6:	4b40      	ldr	r3, [pc, #256]	; (dde8 <SystemInit+0x150>)
    dce8:	69da      	ldr	r2, [r3, #28]
    dcea:	07d2      	lsls	r2, r2, #31
    dcec:	d508      	bpl.n	dd00 <SystemInit+0x68>
            NRF_UICR_S->HFXOSRC = (NRF_UICR_S->HFXOSRC & ~UICR_HFXOSRC_HFXOSRC_Msk) | UICR_HFXOSRC_HFXOSRC_TCXO;
    dcee:	69da      	ldr	r2, [r3, #28]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcf0:	493e      	ldr	r1, [pc, #248]	; (ddec <SystemInit+0x154>)
            NRF_UICR_S->HFXOSRC = (NRF_UICR_S->HFXOSRC & ~UICR_HFXOSRC_HFXOSRC_Msk) | UICR_HFXOSRC_HFXOSRC_TCXO;
    dcf2:	f022 0201 	bic.w	r2, r2, #1
    dcf6:	61da      	str	r2, [r3, #28]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcf8:	f8d1 2400 	ldr.w	r2, [r1, #1024]	; 0x400
    dcfc:	2a01      	cmp	r2, #1
    dcfe:	d1fb      	bne.n	dcf8 <SystemInit+0x60>
        if (NRF_UICR_S->HFXOCNT == 0xFFFFFFFFul) {
    dd00:	6a1a      	ldr	r2, [r3, #32]
    dd02:	3201      	adds	r2, #1
    dd04:	d10a      	bne.n	dd1c <SystemInit+0x84>
            NRF_UICR_S->HFXOCNT = (NRF_UICR_S->HFXOCNT & ~UICR_HFXOCNT_HFXOCNT_Msk) | 0x20;
    dd06:	6a1a      	ldr	r2, [r3, #32]
    dd08:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    dd0c:	f042 0220 	orr.w	r2, r2, #32
    dd10:	621a      	str	r2, [r3, #32]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dd12:	4a36      	ldr	r2, [pc, #216]	; (ddec <SystemInit+0x154>)
    dd14:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    dd18:	2b01      	cmp	r3, #1
    dd1a:	d1fb      	bne.n	dd14 <SystemInit+0x7c>
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Ren;
    dd1c:	2200      	movs	r2, #0
    dd1e:	4b33      	ldr	r3, [pc, #204]	; (ddec <SystemInit+0x154>)
    dd20:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dd24:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    dd28:	2a01      	cmp	r2, #1
    dd2a:	d1fb      	bne.n	dd24 <SystemInit+0x8c>
  __ASM volatile ("dsb 0xF":::"memory");
    dd2c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    dd30:	492f      	ldr	r1, [pc, #188]	; (ddf0 <SystemInit+0x158>)
    dd32:	4b30      	ldr	r3, [pc, #192]	; (ddf4 <SystemInit+0x15c>)
    dd34:	68ca      	ldr	r2, [r1, #12]
    dd36:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    dd3a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    dd3c:	60cb      	str	r3, [r1, #12]
    dd3e:	f3bf 8f4f 	dsb	sy
    __NOP();
    dd42:	bf00      	nop
    dd44:	e7fd      	b.n	dd42 <SystemInit+0xaa>
        if (NRF_UICR_S->HFXOCNT == 0xFFFFFFFFul) {
    dd46:	6a12      	ldr	r2, [r2, #32]
    dd48:	3201      	adds	r2, #1
    dd4a:	d0c0      	beq.n	dcce <SystemInit+0x36>
    }
    

    bool errata_6()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd4c:	4a2a      	ldr	r2, [pc, #168]	; (ddf8 <SystemInit+0x160>)
    dd4e:	6811      	ldr	r1, [r2, #0]
    dd50:	2909      	cmp	r1, #9
    dd52:	d10a      	bne.n	dd6a <SystemInit+0xd2>
            if (*(uint32_t *)0x00FF0134 == 0x01ul){
    dd54:	4929      	ldr	r1, [pc, #164]	; (ddfc <SystemInit+0x164>)
    dd56:	6809      	ldr	r1, [r1, #0]
    dd58:	3901      	subs	r1, #1
    dd5a:	2901      	cmp	r1, #1
            NRF_POWER_S->EVENTS_SLEEPENTER = (POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated << POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos);
    dd5c:	bf9e      	ittt	ls
    dd5e:	f04f 2150 	movls.w	r1, #1342197760	; 0x50005000
    dd62:	f8c1 3114 	strls.w	r3, [r1, #276]	; 0x114
            NRF_POWER_S->EVENTS_SLEEPEXIT = (POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated << POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos);
    dd66:	f8c1 3118 	strls.w	r3, [r1, #280]	; 0x118
    }

    
    bool errata_14()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd6a:	6813      	ldr	r3, [r2, #0]
    dd6c:	2b09      	cmp	r3, #9
    dd6e:	d109      	bne.n	dd84 <SystemInit+0xec>
            if (*(uint32_t *)0x00FF0134 == 0x01ul){
    dd70:	4b22      	ldr	r3, [pc, #136]	; (ddfc <SystemInit+0x164>)
    dd72:	681b      	ldr	r3, [r3, #0]
    dd74:	2b01      	cmp	r3, #1
            *((volatile uint32_t *)0x50004A38) = 0x01ul;
    dd76:	bf01      	itttt	eq
    dd78:	4a21      	ldreq	r2, [pc, #132]	; (de00 <SystemInit+0x168>)
    dd7a:	6013      	streq	r3, [r2, #0]
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    dd7c:	f6a2 2238 	subweq	r2, r2, #2616	; 0xa38
    dd80:	f8c2 3578 	streq.w	r3, [r2, #1400]	; 0x578
    }


    bool errata_15()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd84:	4b1c      	ldr	r3, [pc, #112]	; (ddf8 <SystemInit+0x160>)
    dd86:	681a      	ldr	r2, [r3, #0]
    dd88:	2a09      	cmp	r2, #9
    dd8a:	d10b      	bne.n	dda4 <SystemInit+0x10c>
            if (*(uint32_t *)0x00FF0134 == 0x02ul){
    dd8c:	4a1b      	ldr	r2, [pc, #108]	; (ddfc <SystemInit+0x164>)
    dd8e:	6812      	ldr	r2, [r2, #0]
    dd90:	2a02      	cmp	r2, #2
    dd92:	d107      	bne.n	dda4 <SystemInit+0x10c>
            *((volatile uint32_t *)0x50004A38) = 0x00ul;
    dd94:	2100      	movs	r1, #0
    dd96:	4a1a      	ldr	r2, [pc, #104]	; (de00 <SystemInit+0x168>)
    dd98:	6011      	str	r1, [r2, #0]
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    dd9a:	2101      	movs	r1, #1
    dd9c:	f6a2 2238 	subw	r2, r2, #2616	; 0xa38
    dda0:	f8c2 1578 	str.w	r1, [r2, #1400]	; 0x578
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dda4:	681b      	ldr	r3, [r3, #0]
    dda6:	2b09      	cmp	r3, #9
    dda8:	d106      	bne.n	ddb8 <SystemInit+0x120>
            if (*(uint32_t *)0x00FF0134 == 0x02ul){
    ddaa:	4b14      	ldr	r3, [pc, #80]	; (ddfc <SystemInit+0x164>)
    ddac:	681b      	ldr	r3, [r3, #0]
    ddae:	2b02      	cmp	r3, #2
            *((volatile uint32_t *)0x5003AEE4) = 0xC;
    ddb0:	bf02      	ittt	eq
    ddb2:	220c      	moveq	r2, #12
    ddb4:	4b13      	ldreq	r3, [pc, #76]	; (de04 <SystemInit+0x16c>)
    ddb6:	601a      	streq	r2, [r3, #0]
        SCB->NSACR |= (3UL << 10);
    ddb8:	4b0d      	ldr	r3, [pc, #52]	; (ddf0 <SystemInit+0x158>)
    ddba:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    ddbe:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
    ddc2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
    ddc6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    ddca:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    ddce:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    ddd2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    ddd6:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
    ddda:	4b0b      	ldr	r3, [pc, #44]	; (de08 <SystemInit+0x170>)
    dddc:	4a0b      	ldr	r2, [pc, #44]	; (de0c <SystemInit+0x174>)
    ddde:	601a      	str	r2, [r3, #0]
}
    dde0:	4770      	bx	lr
    dde2:	bf00      	nop
    dde4:	e000edd0 	.word	0xe000edd0
    dde8:	00ff8000 	.word	0x00ff8000
    ddec:	50039000 	.word	0x50039000
    ddf0:	e000ed00 	.word	0xe000ed00
    ddf4:	05fa0004 	.word	0x05fa0004
    ddf8:	00ff0130 	.word	0x00ff0130
    ddfc:	00ff0134 	.word	0x00ff0134
    de00:	50004a38 	.word	0x50004a38
    de04:	5003aee4 	.word	0x5003aee4
    de08:	20001408 	.word	0x20001408
    de0c:	03d09000 	.word	0x03d09000

0000de10 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
    de10:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    de12:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    de14:	4b08      	ldr	r3, [pc, #32]	; (de38 <z_sys_device_do_config_level+0x28>)
    de16:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    de1a:	3001      	adds	r0, #1
    de1c:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    de20:	42a5      	cmp	r5, r4
    de22:	d800      	bhi.n	de26 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    de24:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    de26:	6823      	ldr	r3, [r4, #0]
    de28:	4620      	mov	r0, r4
    de2a:	685b      	ldr	r3, [r3, #4]
    de2c:	4798      	blx	r3
		if (retval != 0) {
    de2e:	b100      	cbz	r0, de32 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    de30:	6066      	str	r6, [r4, #4]
								info++) {
    de32:	340c      	adds	r4, #12
    de34:	e7f4      	b.n	de20 <z_sys_device_do_config_level+0x10>
    de36:	bf00      	nop
    de38:	000107bc 	.word	0x000107bc

0000de3c <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    de3c:	4b10      	ldr	r3, [pc, #64]	; (de80 <z_impl_device_get_binding+0x44>)
{
    de3e:	b570      	push	{r4, r5, r6, lr}
    de40:	4605      	mov	r5, r0
    de42:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    de44:	4c0f      	ldr	r4, [pc, #60]	; (de84 <z_impl_device_get_binding+0x48>)
    de46:	429c      	cmp	r4, r3
    de48:	d104      	bne.n	de54 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    de4a:	4c0e      	ldr	r4, [pc, #56]	; (de84 <z_impl_device_get_binding+0x48>)
    de4c:	42b4      	cmp	r4, r6
    de4e:	d109      	bne.n	de64 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    de50:	2400      	movs	r4, #0
    de52:	e012      	b.n	de7a <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    de54:	6862      	ldr	r2, [r4, #4]
    de56:	b11a      	cbz	r2, de60 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    de58:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    de5a:	6812      	ldr	r2, [r2, #0]
    de5c:	42aa      	cmp	r2, r5
    de5e:	d00c      	beq.n	de7a <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    de60:	340c      	adds	r4, #12
    de62:	e7f0      	b.n	de46 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    de64:	6863      	ldr	r3, [r4, #4]
    de66:	b90b      	cbnz	r3, de6c <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    de68:	340c      	adds	r4, #12
    de6a:	e7ef      	b.n	de4c <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    de6c:	6823      	ldr	r3, [r4, #0]
    de6e:	4628      	mov	r0, r5
    de70:	6819      	ldr	r1, [r3, #0]
    de72:	f002 f812 	bl	fe9a <strcmp>
    de76:	2800      	cmp	r0, #0
    de78:	d1f6      	bne.n	de68 <z_impl_device_get_binding+0x2c>
}
    de7a:	4620      	mov	r0, r4
    de7c:	bd70      	pop	{r4, r5, r6, pc}
    de7e:	bf00      	nop
    de80:	200014cc 	.word	0x200014cc
    de84:	20001454 	.word	0x20001454

0000de88 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    de88:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    de8a:	4d0b      	ldr	r5, [pc, #44]	; (deb8 <idle+0x30>)
    de8c:	f04f 0220 	mov.w	r2, #32
    de90:	f3ef 8311 	mrs	r3, BASEPRI
    de94:	f382 8811 	msr	BASEPRI, r2
    de98:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    de9c:	f002 f9e1 	bl	10262 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    dea0:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
    dea2:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    dea4:	2802      	cmp	r0, #2
    dea6:	bfd8      	it	le
    dea8:	4608      	movle	r0, r1
    deaa:	f002 f9ea 	bl	10282 <z_set_timeout_expiry>
	_kernel.idle = ticks;
    deae:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	z_arch_cpu_idle();
    deb0:	f7ff fa24 	bl	d2fc <z_arch_cpu_idle>
    deb4:	e7ea      	b.n	de8c <idle+0x4>
    deb6:	bf00      	nop
    deb8:	20000630 	.word	0x20000630

0000debc <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    debc:	4802      	ldr	r0, [pc, #8]	; (dec8 <z_bss_zero+0xc>)
    debe:	4a03      	ldr	r2, [pc, #12]	; (decc <z_bss_zero+0x10>)
    dec0:	2100      	movs	r1, #0
    dec2:	1a12      	subs	r2, r2, r0
    dec4:	f002 b83a 	b.w	ff3c <memset>
    dec8:	20000000 	.word	0x20000000
    decc:	20000690 	.word	0x20000690

0000ded0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    ded0:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    ded2:	4806      	ldr	r0, [pc, #24]	; (deec <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    ded4:	4a06      	ldr	r2, [pc, #24]	; (def0 <z_data_copy+0x20>)
    ded6:	4907      	ldr	r1, [pc, #28]	; (def4 <z_data_copy+0x24>)
    ded8:	1a12      	subs	r2, r2, r0
    deda:	f002 f802 	bl	fee2 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    dede:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    dee2:	4a05      	ldr	r2, [pc, #20]	; (def8 <z_data_copy+0x28>)
    dee4:	4905      	ldr	r1, [pc, #20]	; (defc <z_data_copy+0x2c>)
    dee6:	4806      	ldr	r0, [pc, #24]	; (df00 <z_data_copy+0x30>)
    dee8:	f001 bffb 	b.w	fee2 <memcpy>
    deec:	200013d4 	.word	0x200013d4
    def0:	20001530 	.word	0x20001530
    def4:	00010c40 	.word	0x00010c40
    def8:	00000000 	.word	0x00000000
    defc:	00010c40 	.word	0x00010c40
    df00:	20000000 	.word	0x20000000

0000df04 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    df04:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    df06:	2002      	movs	r0, #2
    df08:	f7ff ff82 	bl	de10 <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
    df0c:	4807      	ldr	r0, [pc, #28]	; (df2c <bg_thread_main+0x28>)
    df0e:	f001 fe43 	bl	fb98 <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    df12:	2003      	movs	r0, #3
    df14:	f7ff ff7c 	bl	de10 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    df18:	f000 fc36 	bl	e788 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    df1c:	f001 fc50 	bl	f7c0 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    df20:	4a03      	ldr	r2, [pc, #12]	; (df30 <bg_thread_main+0x2c>)
    df22:	7b13      	ldrb	r3, [r2, #12]
    df24:	f023 0301 	bic.w	r3, r3, #1
    df28:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    df2a:	bd08      	pop	{r3, pc}
    df2c:	00010c02 	.word	0x00010c02
    df30:	200005c4 	.word	0x200005c4

0000df34 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    df34:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
    df36:	4b37      	ldr	r3, [pc, #220]	; (e014 <z_cstart+0xe0>)
    df38:	b0a2      	sub	sp, #136	; 0x88
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    df3a:	f383 8808 	msr	MSP, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    df3e:	2500      	movs	r5, #0
    df40:	23e0      	movs	r3, #224	; 0xe0
    df42:	4c35      	ldr	r4, [pc, #212]	; (e018 <z_cstart+0xe4>)

	/* perform any architecture-specific initialization */
	z_arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    df44:	2701      	movs	r7, #1
    df46:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    df4a:	77e5      	strb	r5, [r4, #31]
    df4c:	7625      	strb	r5, [r4, #24]
    df4e:	7665      	strb	r5, [r4, #25]
    df50:	76a5      	strb	r5, [r4, #26]
    df52:	76e5      	strb	r5, [r4, #27]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    df54:	6a63      	ldr	r3, [r4, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
    df56:	4e31      	ldr	r6, [pc, #196]	; (e01c <z_cstart+0xe8>)
    df58:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    df5c:	6263      	str	r3, [r4, #36]	; 0x24
		      SCB_SHCSR_BUSFAULTENA_Msk;
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	/* Enable Secure Fault */
	SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
    df5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    df60:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    df64:	6263      	str	r3, [r4, #36]	; 0x24
	/* Clear BFAR before setting BusFaults to target Non-Secure state. */
	SCB->BFAR = 0;
    df66:	63a5      	str	r5, [r4, #56]	; 0x38

static ALWAYS_INLINE void z_arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    df68:	f7ff fbae 	bl	d6c8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    df6c:	f7ff f9c0 	bl	d2f0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    df70:	f04f 33ff 	mov.w	r3, #4294967295
    df74:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    df76:	62e3      	str	r3, [r4, #44]	; 0x2c
	struct k_thread dummy_thread = {
    df78:	ab07      	add	r3, sp, #28
    df7a:	226c      	movs	r2, #108	; 0x6c
    df7c:	4629      	mov	r1, r5
    df7e:	4618      	mov	r0, r3
    df80:	f001 ffdc 	bl	ff3c <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    df84:	4c26      	ldr	r4, [pc, #152]	; (e020 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
    df86:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	_current = &dummy_thread;
    df8a:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    df8c:	4628      	mov	r0, r5
    df8e:	f7ff ff3f 	bl	de10 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    df92:	4638      	mov	r0, r7
    df94:	f7ff ff3c 	bl	de10 <z_sys_device_do_config_level>
	z_sched_init();
    df98:	f000 fba6 	bl	e6e8 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    df9c:	4b21      	ldr	r3, [pc, #132]	; (e024 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
    df9e:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
    dfa0:	f44f 6280 	mov.w	r2, #1024	; 0x400
    dfa4:	e9cd 7304 	strd	r7, r3, [sp, #16]
    dfa8:	e9cd 5502 	strd	r5, r5, [sp, #8]
    dfac:	4b1e      	ldr	r3, [pc, #120]	; (e028 <z_cstart+0xf4>)
    dfae:	e9cd 5500 	strd	r5, r5, [sp]
    dfb2:	491e      	ldr	r1, [pc, #120]	; (e02c <z_cstart+0xf8>)
    dfb4:	4630      	mov	r0, r6
    dfb6:	f000 fbcd 	bl	e754 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dfba:	7b73      	ldrb	r3, [r6, #13]
    dfbc:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dfc0:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dfc4:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dfc6:	d104      	bne.n	dfd2 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    dfc8:	69b3      	ldr	r3, [r6, #24]
    dfca:	b913      	cbnz	r3, dfd2 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
    dfcc:	4630      	mov	r0, r6
    dfce:	f000 fa1b 	bl	e408 <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
    dfd2:	4b17      	ldr	r3, [pc, #92]	; (e030 <z_cstart+0xfc>)
    dfd4:	2201      	movs	r2, #1
    dfd6:	9305      	str	r3, [sp, #20]
    dfd8:	230f      	movs	r3, #15
    dfda:	e9cd 3203 	strd	r3, r2, [sp, #12]
    dfde:	2300      	movs	r3, #0
    dfe0:	4d14      	ldr	r5, [pc, #80]	; (e034 <z_cstart+0x100>)
    dfe2:	e9cd 3301 	strd	r3, r3, [sp, #4]
    dfe6:	9300      	str	r3, [sp, #0]
    dfe8:	f44f 72a0 	mov.w	r2, #320	; 0x140
    dfec:	4b12      	ldr	r3, [pc, #72]	; (e038 <z_cstart+0x104>)
    dfee:	4913      	ldr	r1, [pc, #76]	; (e03c <z_cstart+0x108>)
    dff0:	4628      	mov	r0, r5
    dff2:	f000 fbaf 	bl	e754 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dff6:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    dff8:	60e5      	str	r5, [r4, #12]
    dffa:	f023 0304 	bic.w	r3, r3, #4
    dffe:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    e000:	4b0f      	ldr	r3, [pc, #60]	; (e040 <z_cstart+0x10c>)
	z_arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    e002:	f44f 6280 	mov.w	r2, #1024	; 0x400
	list->tail = (sys_dnode_t *)list;
    e006:	e9c4 3306 	strd	r3, r3, [r4, #24]
    e00a:	4908      	ldr	r1, [pc, #32]	; (e02c <z_cstart+0xf8>)
    e00c:	4b06      	ldr	r3, [pc, #24]	; (e028 <z_cstart+0xf4>)
    e00e:	4803      	ldr	r0, [pc, #12]	; (e01c <z_cstart+0xe8>)
    e010:	f7ff fa1c 	bl	d44c <z_arch_switch_to_main_thread>
    e014:	200013d0 	.word	0x200013d0
    e018:	e000ed00 	.word	0xe000ed00
    e01c:	200005c4 	.word	0x200005c4
    e020:	20000630 	.word	0x20000630
    e024:	00010c34 	.word	0x00010c34
    e028:	0000df05 	.word	0x0000df05
    e02c:	20000690 	.word	0x20000690
    e030:	00010c39 	.word	0x00010c39
    e034:	20000558 	.word	0x20000558
    e038:	0000de89 	.word	0x0000de89
    e03c:	20000a90 	.word	0x20000a90
    e040:	20000648 	.word	0x20000648

0000e044 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
    e044:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
    e046:	2400      	movs	r4, #0
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    e048:	4b0a      	ldr	r3, [pc, #40]	; (e074 <init_mem_slab_module+0x30>)
    e04a:	480b      	ldr	r0, [pc, #44]	; (e078 <init_mem_slab_module+0x34>)
    e04c:	4283      	cmp	r3, r0
    e04e:	d301      	bcc.n	e054 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
    e050:	2000      	movs	r0, #0
    e052:	bd70      	pop	{r4, r5, r6, pc}
	for (j = 0U; j < slab->num_blocks; j++) {
    e054:	2100      	movs	r1, #0
	p = slab->buffer;
    e056:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    e058:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    e05a:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    e05c:	42a9      	cmp	r1, r5
    e05e:	d101      	bne.n	e064 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    e060:	331c      	adds	r3, #28
    e062:	e7f3      	b.n	e04c <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
    e064:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    e066:	3101      	adds	r1, #1
		*(char **)p = slab->free_list;
    e068:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
    e06a:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
    e06c:	615a      	str	r2, [r3, #20]
		p += slab->block_size;
    e06e:	4432      	add	r2, r6
    e070:	e7f4      	b.n	e05c <init_mem_slab_module+0x18>
    e072:	bf00      	nop
    e074:	200014cc 	.word	0x200014cc
    e078:	200014cc 	.word	0x200014cc

0000e07c <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    e07c:	b510      	push	{r4, lr}
    e07e:	4613      	mov	r3, r2
    e080:	460c      	mov	r4, r1
    e082:	f04f 0220 	mov.w	r2, #32
    e086:	f3ef 8111 	mrs	r1, BASEPRI
    e08a:	f382 8811 	msr	BASEPRI, r2
    e08e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    e092:	6942      	ldr	r2, [r0, #20]
    e094:	b162      	cbz	r2, e0b0 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
    e096:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    e098:	6943      	ldr	r3, [r0, #20]
    e09a:	681b      	ldr	r3, [r3, #0]
    e09c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    e09e:	6983      	ldr	r3, [r0, #24]
    e0a0:	3301      	adds	r3, #1
    e0a2:	6183      	str	r3, [r0, #24]
		result = 0;
    e0a4:	2000      	movs	r0, #0
	__asm__ volatile(
    e0a6:	f381 8811 	msr	BASEPRI, r1
    e0aa:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    e0ae:	e00d      	b.n	e0cc <k_mem_slab_alloc+0x50>
	} else if (timeout == K_NO_WAIT) {
    e0b0:	b91b      	cbnz	r3, e0ba <k_mem_slab_alloc+0x3e>
		*mem = NULL;
    e0b2:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    e0b4:	f06f 000b 	mvn.w	r0, #11
    e0b8:	e7f5      	b.n	e0a6 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    e0ba:	4602      	mov	r2, r0
    e0bc:	4804      	ldr	r0, [pc, #16]	; (e0d0 <k_mem_slab_alloc+0x54>)
    e0be:	f000 fabd 	bl	e63c <z_pend_curr>
		if (result == 0) {
    e0c2:	b918      	cbnz	r0, e0cc <k_mem_slab_alloc+0x50>
			*mem = _current->base.swap_data;
    e0c4:	4b03      	ldr	r3, [pc, #12]	; (e0d4 <k_mem_slab_alloc+0x58>)
    e0c6:	689b      	ldr	r3, [r3, #8]
    e0c8:	695b      	ldr	r3, [r3, #20]
    e0ca:	6023      	str	r3, [r4, #0]
}
    e0cc:	bd10      	pop	{r4, pc}
    e0ce:	bf00      	nop
    e0d0:	2000068d 	.word	0x2000068d
    e0d4:	20000630 	.word	0x20000630

0000e0d8 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    e0d8:	b570      	push	{r4, r5, r6, lr}
    e0da:	4604      	mov	r4, r0
    e0dc:	460d      	mov	r5, r1
	__asm__ volatile(
    e0de:	f04f 0320 	mov.w	r3, #32
    e0e2:	f3ef 8611 	mrs	r6, BASEPRI
    e0e6:	f383 8811 	msr	BASEPRI, r3
    e0ea:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    e0ee:	f002 f845 	bl	1017c <z_unpend_first_thread>

	if (pending_thread != NULL) {
    e0f2:	b180      	cbz	r0, e116 <k_mem_slab_free+0x3e>
}

static ALWAYS_INLINE void
z_arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    e0f4:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    e0f6:	682a      	ldr	r2, [r5, #0]
    e0f8:	6681      	str	r1, [r0, #104]	; 0x68
	thread->base.swap_data = data;
    e0fa:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    e0fc:	7b42      	ldrb	r2, [r0, #13]
    e0fe:	06d2      	lsls	r2, r2, #27
    e100:	d103      	bne.n	e10a <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
    e102:	6983      	ldr	r3, [r0, #24]
    e104:	b90b      	cbnz	r3, e10a <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
    e106:	f000 f97f 	bl	e408 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
    e10a:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    e10c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    e110:	4807      	ldr	r0, [pc, #28]	; (e130 <k_mem_slab_free+0x58>)
    e112:	f001 bfd3 	b.w	100bc <z_reschedule>
		**(char ***)mem = slab->free_list;
    e116:	682b      	ldr	r3, [r5, #0]
    e118:	6962      	ldr	r2, [r4, #20]
    e11a:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    e11c:	682b      	ldr	r3, [r5, #0]
    e11e:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    e120:	69a3      	ldr	r3, [r4, #24]
    e122:	3b01      	subs	r3, #1
    e124:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    e126:	f386 8811 	msr	BASEPRI, r6
    e12a:	f3bf 8f6f 	isb	sy
}
    e12e:	bd70      	pop	{r4, r5, r6, pc}
    e130:	2000068d 	.word	0x2000068d

0000e134 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
    e134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e136:	4604      	mov	r4, r0
    e138:	460f      	mov	r7, r1
	__asm__ volatile(
    e13a:	f04f 0320 	mov.w	r3, #32
    e13e:	f3ef 8511 	mrs	r5, BASEPRI
    e142:	f383 8811 	msr	BASEPRI, r3
    e146:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    e14a:	68c2      	ldr	r2, [r0, #12]
    e14c:	4930      	ldr	r1, [pc, #192]	; (e210 <z_impl_k_mutex_lock+0xdc>)
    e14e:	b15a      	cbz	r2, e168 <z_impl_k_mutex_lock+0x34>
    e150:	6880      	ldr	r0, [r0, #8]
    e152:	688e      	ldr	r6, [r1, #8]
    e154:	42b0      	cmp	r0, r6
    e156:	d015      	beq.n	e184 <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
    e158:	b9b7      	cbnz	r7, e188 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
    e15a:	f385 8811 	msr	BASEPRI, r5
    e15e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
    e162:	f06f 000f 	mvn.w	r0, #15
    e166:	e00c      	b.n	e182 <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
    e168:	688b      	ldr	r3, [r1, #8]
    e16a:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    e16e:	6123      	str	r3, [r4, #16]
		mutex->owner = _current;
    e170:	688b      	ldr	r3, [r1, #8]
		mutex->lock_count++;
    e172:	3201      	adds	r2, #1
    e174:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
    e176:	60a3      	str	r3, [r4, #8]
    e178:	f385 8811 	msr	BASEPRI, r5
    e17c:	f3bf 8f6f 	isb	sy
		return 0;
    e180:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
    e182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
    e184:	6923      	ldr	r3, [r4, #16]
    e186:	e7f2      	b.n	e16e <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    e188:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e18c:	f996 100e 	ldrsb.w	r1, [r6, #14]
    e190:	4299      	cmp	r1, r3
    e192:	bfa8      	it	ge
    e194:	4619      	movge	r1, r3
    e196:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    e19a:	4299      	cmp	r1, r3
    e19c:	da2b      	bge.n	e1f6 <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
    e19e:	f000 fa61 	bl	e664 <z_set_prio>
    e1a2:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    e1a4:	463b      	mov	r3, r7
    e1a6:	4622      	mov	r2, r4
    e1a8:	4629      	mov	r1, r5
    e1aa:	481a      	ldr	r0, [pc, #104]	; (e214 <z_impl_k_mutex_lock+0xe0>)
    e1ac:	f000 fa46 	bl	e63c <z_pend_curr>
	if (got_mutex == 0) {
    e1b0:	2800      	cmp	r0, #0
    e1b2:	d0e6      	beq.n	e182 <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
    e1b4:	f04f 0320 	mov.w	r3, #32
    e1b8:	f3ef 8511 	mrs	r5, BASEPRI
    e1bc:	f383 8811 	msr	BASEPRI, r3
    e1c0:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    e1c4:	6823      	ldr	r3, [r4, #0]
    e1c6:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e1c8:	429c      	cmp	r4, r3
    e1ca:	d007      	beq.n	e1dc <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
    e1cc:	b133      	cbz	r3, e1dc <z_impl_k_mutex_lock+0xa8>
    e1ce:	f993 300e 	ldrsb.w	r3, [r3, #14]
    e1d2:	4299      	cmp	r1, r3
    e1d4:	bfa8      	it	ge
    e1d6:	4619      	movge	r1, r3
    e1d8:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    e1dc:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
    e1de:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e1e2:	4299      	cmp	r1, r3
    e1e4:	d109      	bne.n	e1fa <z_impl_k_mutex_lock+0xc6>
	if (resched) {
    e1e6:	b16e      	cbz	r6, e204 <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
    e1e8:	4629      	mov	r1, r5
    e1ea:	480a      	ldr	r0, [pc, #40]	; (e214 <z_impl_k_mutex_lock+0xe0>)
    e1ec:	f001 ff66 	bl	100bc <z_reschedule>
	return -EAGAIN;
    e1f0:	f06f 000a 	mvn.w	r0, #10
    e1f4:	e7c5      	b.n	e182 <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
    e1f6:	2600      	movs	r6, #0
    e1f8:	e7d4      	b.n	e1a4 <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
    e1fa:	f000 fa33 	bl	e664 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    e1fe:	2800      	cmp	r0, #0
    e200:	d1f2      	bne.n	e1e8 <z_impl_k_mutex_lock+0xb4>
    e202:	e7f0      	b.n	e1e6 <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
    e204:	f385 8811 	msr	BASEPRI, r5
    e208:	f3bf 8f6f 	isb	sy
    e20c:	e7f0      	b.n	e1f0 <z_impl_k_mutex_lock+0xbc>
    e20e:	bf00      	nop
    e210:	20000630 	.word	0x20000630
    e214:	2000068d 	.word	0x2000068d

0000e218 <z_impl_k_mutex_unlock>:
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    e218:	4b1e      	ldr	r3, [pc, #120]	; (e294 <z_impl_k_mutex_unlock+0x7c>)
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    e21a:	b570      	push	{r4, r5, r6, lr}
    e21c:	689a      	ldr	r2, [r3, #8]
    e21e:	4604      	mov	r4, r0
    e220:	7bd3      	ldrb	r3, [r2, #15]
    e222:	3b01      	subs	r3, #1
    e224:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
    e226:	68c3      	ldr	r3, [r0, #12]
    e228:	2b01      	cmp	r3, #1
    e22a:	d005      	beq.n	e238 <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
    e22c:	3b01      	subs	r3, #1
    e22e:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	k_sched_unlock();
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);
}
    e230:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_sched_unlock();
    e234:	f000 b8cc 	b.w	e3d0 <k_sched_unlock>
	__asm__ volatile(
    e238:	f04f 0320 	mov.w	r3, #32
    e23c:	f3ef 8611 	mrs	r6, BASEPRI
    e240:	f383 8811 	msr	BASEPRI, r3
    e244:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    e248:	6901      	ldr	r1, [r0, #16]
    e24a:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
    e24c:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e250:	4299      	cmp	r1, r3
    e252:	d001      	beq.n	e258 <z_impl_k_mutex_unlock+0x40>
		return z_set_prio(mutex->owner, new_prio);
    e254:	f000 fa06 	bl	e664 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    e258:	4620      	mov	r0, r4
    e25a:	f001 ff8f 	bl	1017c <z_unpend_first_thread>
    e25e:	4605      	mov	r5, r0
	mutex->owner = new_owner;
    e260:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    e262:	b180      	cbz	r0, e286 <z_impl_k_mutex_unlock+0x6e>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    e264:	7b43      	ldrb	r3, [r0, #13]
    e266:	06db      	lsls	r3, r3, #27
    e268:	d103      	bne.n	e272 <z_impl_k_mutex_unlock+0x5a>
	if (z_is_thread_ready(thread)) {
    e26a:	6983      	ldr	r3, [r0, #24]
    e26c:	b90b      	cbnz	r3, e272 <z_impl_k_mutex_unlock+0x5a>
		z_add_thread_to_ready_q(thread);
    e26e:	f000 f8cb 	bl	e408 <z_add_thread_to_ready_q>
	__asm__ volatile(
    e272:	f386 8811 	msr	BASEPRI, r6
    e276:	f3bf 8f6f 	isb	sy
    e27a:	2300      	movs	r3, #0
    e27c:	66ab      	str	r3, [r5, #104]	; 0x68
		mutex->owner_orig_prio = new_owner->base.prio;
    e27e:	f995 300e 	ldrsb.w	r3, [r5, #14]
    e282:	6123      	str	r3, [r4, #16]
    e284:	e7d4      	b.n	e230 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
    e286:	60e0      	str	r0, [r4, #12]
    e288:	f386 8811 	msr	BASEPRI, r6
    e28c:	f3bf 8f6f 	isb	sy
    e290:	e7ce      	b.n	e230 <z_impl_k_mutex_unlock+0x18>
    e292:	bf00      	nop
    e294:	20000630 	.word	0x20000630

0000e298 <resched.part.15>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e298:	f3ef 8005 	mrs	r0, IPSR
		|| (vector && !(SCB->ICSR & SCB_ICSR_RETTOBASE_Msk))
    e29c:	280d      	cmp	r0, #13
    e29e:	d809      	bhi.n	e2b4 <resched.part.15+0x1c>
    e2a0:	b128      	cbz	r0, e2ae <resched.part.15+0x16>
    e2a2:	4b05      	ldr	r3, [pc, #20]	; (e2b8 <resched.part.15+0x20>)
    e2a4:	6858      	ldr	r0, [r3, #4]
    e2a6:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
    e2aa:	f3c0 20c0 	ubfx	r0, r0, #11, #1
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
}
    e2ae:	f080 0001 	eor.w	r0, r0, #1
    e2b2:	4770      	bx	lr
    e2b4:	2001      	movs	r0, #1
    e2b6:	e7fa      	b.n	e2ae <resched.part.15+0x16>
    e2b8:	e000ed00 	.word	0xe000ed00

0000e2bc <z_reset_time_slice>:
{
    e2bc:	b510      	push	{r4, lr}
	if (slice_time != 0) {
    e2be:	4c08      	ldr	r4, [pc, #32]	; (e2e0 <z_reset_time_slice+0x24>)
    e2c0:	6823      	ldr	r3, [r4, #0]
    e2c2:	b15b      	cbz	r3, e2dc <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    e2c4:	f7fe fc94 	bl	cbf0 <z_clock_elapsed>
    e2c8:	6823      	ldr	r3, [r4, #0]
    e2ca:	4a06      	ldr	r2, [pc, #24]	; (e2e4 <z_reset_time_slice+0x28>)
    e2cc:	4418      	add	r0, r3
    e2ce:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    e2d0:	2100      	movs	r1, #0
}
    e2d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
    e2d6:	4618      	mov	r0, r3
    e2d8:	f001 bfd3 	b.w	10282 <z_set_timeout_expiry>
}
    e2dc:	bd10      	pop	{r4, pc}
    e2de:	bf00      	nop
    e2e0:	20000668 	.word	0x20000668
    e2e4:	20000630 	.word	0x20000630

0000e2e8 <k_sched_time_slice_set>:
{
    e2e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e2ea:	460d      	mov	r5, r1
	__asm__ volatile(
    e2ec:	f04f 0320 	mov.w	r3, #32
    e2f0:	f3ef 8411 	mrs	r4, BASEPRI
    e2f4:	f383 8811 	msr	BASEPRI, r3
    e2f8:	f3bf 8f6f 	isb	sy

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	int cyc = sys_clock_hw_cycles_per_sec();

	/* use 64-bit math to keep precision */
	return (s32_t)ceiling_fraction((s64_t)ms * cyc,
    e2fc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    e300:	f240 36e7 	movw	r6, #999	; 0x3e7
    e304:	2700      	movs	r7, #0
		_current_cpu->slice_ticks = 0;
    e306:	2200      	movs	r2, #0
    e308:	fbc1 6700 	smlal	r6, r7, r1, r0
    e30c:	4b09      	ldr	r3, [pc, #36]	; (e334 <k_sched_time_slice_set+0x4c>)
    e30e:	4630      	mov	r0, r6
    e310:	611a      	str	r2, [r3, #16]
    e312:	4639      	mov	r1, r7
    e314:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e318:	2300      	movs	r3, #0
    e31a:	f7fe f881 	bl	c420 <__aeabi_ldivmod>
    e31e:	4b06      	ldr	r3, [pc, #24]	; (e338 <k_sched_time_slice_set+0x50>)
    e320:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    e322:	4b06      	ldr	r3, [pc, #24]	; (e33c <k_sched_time_slice_set+0x54>)
    e324:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    e326:	f7ff ffc9 	bl	e2bc <z_reset_time_slice>
	__asm__ volatile(
    e32a:	f384 8811 	msr	BASEPRI, r4
    e32e:	f3bf 8f6f 	isb	sy
}
    e332:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e334:	20000630 	.word	0x20000630
    e338:	20000668 	.word	0x20000668
    e33c:	20000664 	.word	0x20000664

0000e340 <k_sched_lock>:
	__asm__ volatile(
    e340:	f04f 0320 	mov.w	r3, #32
    e344:	f3ef 8111 	mrs	r1, BASEPRI
    e348:	f383 8811 	msr	BASEPRI, r3
    e34c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    e350:	4b04      	ldr	r3, [pc, #16]	; (e364 <k_sched_lock+0x24>)
    e352:	689a      	ldr	r2, [r3, #8]
    e354:	7bd3      	ldrb	r3, [r2, #15]
    e356:	3b01      	subs	r3, #1
    e358:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    e35a:	f381 8811 	msr	BASEPRI, r1
    e35e:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    e362:	4770      	bx	lr
    e364:	20000630 	.word	0x20000630

0000e368 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    e368:	4b09      	ldr	r3, [pc, #36]	; (e390 <z_priq_dumb_remove+0x28>)
    e36a:	f103 0228 	add.w	r2, r3, #40	; 0x28
    e36e:	4282      	cmp	r2, r0
    e370:	d105      	bne.n	e37e <z_priq_dumb_remove+0x16>
    e372:	689b      	ldr	r3, [r3, #8]
    e374:	428b      	cmp	r3, r1
    e376:	d102      	bne.n	e37e <z_priq_dumb_remove+0x16>
    e378:	7b4b      	ldrb	r3, [r1, #13]
    e37a:	06db      	lsls	r3, r3, #27
    e37c:	d107      	bne.n	e38e <z_priq_dumb_remove+0x26>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    e37e:	e9d1 2300 	ldrd	r2, r3, [r1]
    e382:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
    e384:	680a      	ldr	r2, [r1, #0]
    e386:	6053      	str	r3, [r2, #4]
	node->next = NULL;
    e388:	2300      	movs	r3, #0
	node->prev = NULL;
    e38a:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    e38e:	4770      	bx	lr
    e390:	20000630 	.word	0x20000630

0000e394 <update_cache>:
{
    e394:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    e396:	4c0d      	ldr	r4, [pc, #52]	; (e3cc <update_cache+0x38>)
{
    e398:	4602      	mov	r2, r0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    e39a:	f104 0028 	add.w	r0, r4, #40	; 0x28
    e39e:	f001 feb6 	bl	1010e <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
    e3a2:	4605      	mov	r5, r0
    e3a4:	b900      	cbnz	r0, e3a8 <update_cache+0x14>
    e3a6:	68e5      	ldr	r5, [r4, #12]
    e3a8:	68a3      	ldr	r3, [r4, #8]
	if (preempt_ok != 0) {
    e3aa:	b94a      	cbnz	r2, e3c0 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    e3ac:	7b5a      	ldrb	r2, [r3, #13]
    e3ae:	06d2      	lsls	r2, r2, #27
    e3b0:	d106      	bne.n	e3c0 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    e3b2:	69aa      	ldr	r2, [r5, #24]
    e3b4:	b922      	cbnz	r2, e3c0 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(th)) {
    e3b6:	89da      	ldrh	r2, [r3, #14]
    e3b8:	2a7f      	cmp	r2, #127	; 0x7f
    e3ba:	d901      	bls.n	e3c0 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    e3bc:	6263      	str	r3, [r4, #36]	; 0x24
}
    e3be:	bd38      	pop	{r3, r4, r5, pc}
		if (th != _current) {
    e3c0:	429d      	cmp	r5, r3
    e3c2:	d001      	beq.n	e3c8 <update_cache+0x34>
			z_reset_time_slice();
    e3c4:	f7ff ff7a 	bl	e2bc <z_reset_time_slice>
		_kernel.ready_q.cache = th;
    e3c8:	6265      	str	r5, [r4, #36]	; 0x24
}
    e3ca:	e7f8      	b.n	e3be <update_cache+0x2a>
    e3cc:	20000630 	.word	0x20000630

0000e3d0 <k_sched_unlock>:
{
    e3d0:	b510      	push	{r4, lr}
	__asm__ volatile(
    e3d2:	f04f 0320 	mov.w	r3, #32
    e3d6:	f3ef 8411 	mrs	r4, BASEPRI
    e3da:	f383 8811 	msr	BASEPRI, r3
    e3de:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    e3e2:	4b08      	ldr	r3, [pc, #32]	; (e404 <k_sched_unlock+0x34>)
		update_cache(0);
    e3e4:	2000      	movs	r0, #0
		++_current->base.sched_locked;
    e3e6:	689a      	ldr	r2, [r3, #8]
    e3e8:	7bd3      	ldrb	r3, [r2, #15]
    e3ea:	3301      	adds	r3, #1
    e3ec:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    e3ee:	f7ff ffd1 	bl	e394 <update_cache>
	__asm__ volatile(
    e3f2:	f384 8811 	msr	BASEPRI, r4
    e3f6:	f3bf 8f6f 	isb	sy
}
    e3fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    e3fe:	f001 be7c 	b.w	100fa <z_reschedule_unlocked>
    e402:	bf00      	nop
    e404:	20000630 	.word	0x20000630

0000e408 <z_add_thread_to_ready_q>:
{
    e408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    e40a:	f04f 0320 	mov.w	r3, #32
    e40e:	f3ef 8411 	mrs	r4, BASEPRI
    e412:	f383 8811 	msr	BASEPRI, r3
    e416:	f3bf 8f6f 	isb	sy
	return list->head == list;
    e41a:	4a16      	ldr	r2, [pc, #88]	; (e474 <z_add_thread_to_ready_q+0x6c>)
    e41c:	4611      	mov	r1, r2
    e41e:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e422:	428b      	cmp	r3, r1
    e424:	d00c      	beq.n	e440 <z_add_thread_to_ready_q+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e426:	b15b      	cbz	r3, e440 <z_add_thread_to_ready_q+0x38>
    e428:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    e42a:	f990 500e 	ldrsb.w	r5, [r0, #14]
    e42e:	f993 700e 	ldrsb.w	r7, [r3, #14]
    e432:	42af      	cmp	r7, r5
    e434:	dc0b      	bgt.n	e44e <z_add_thread_to_ready_q+0x46>
	return (node == list->tail) ? NULL : node->next;
    e436:	42b3      	cmp	r3, r6
    e438:	d002      	beq.n	e440 <z_add_thread_to_ready_q+0x38>
    e43a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e43c:	2b00      	cmp	r3, #0
    e43e:	d1f6      	bne.n	e42e <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    e440:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    e442:	6001      	str	r1, [r0, #0]
	node->prev = list->tail;
    e444:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    e446:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e448:	6018      	str	r0, [r3, #0]
	list->tail = node;
    e44a:	62d0      	str	r0, [r2, #44]	; 0x2c
    e44c:	e005      	b.n	e45a <z_add_thread_to_ready_q+0x52>
	node->prev = successor->prev;
    e44e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e450:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    e454:	685a      	ldr	r2, [r3, #4]
    e456:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    e458:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    e45a:	7b43      	ldrb	r3, [r0, #13]
    e45c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e460:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    e462:	2000      	movs	r0, #0
    e464:	f7ff ff96 	bl	e394 <update_cache>
	__asm__ volatile(
    e468:	f384 8811 	msr	BASEPRI, r4
    e46c:	f3bf 8f6f 	isb	sy
}
    e470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e472:	bf00      	nop
    e474:	20000630 	.word	0x20000630

0000e478 <z_move_thread_to_end_of_prio_q>:
{
    e478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e47a:	4604      	mov	r4, r0
	__asm__ volatile(
    e47c:	f04f 0320 	mov.w	r3, #32
    e480:	f3ef 8511 	mrs	r5, BASEPRI
    e484:	f383 8811 	msr	BASEPRI, r3
    e488:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    e48c:	7b43      	ldrb	r3, [r0, #13]
    e48e:	065a      	lsls	r2, r3, #25
    e490:	d503      	bpl.n	e49a <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    e492:	4601      	mov	r1, r0
    e494:	4818      	ldr	r0, [pc, #96]	; (e4f8 <z_move_thread_to_end_of_prio_q+0x80>)
    e496:	f7ff ff67 	bl	e368 <z_priq_dumb_remove>
	return list->head == list;
    e49a:	4a18      	ldr	r2, [pc, #96]	; (e4fc <z_move_thread_to_end_of_prio_q+0x84>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e49c:	f102 0128 	add.w	r1, r2, #40	; 0x28
    e4a0:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
    e4a4:	428b      	cmp	r3, r1
    e4a6:	d00b      	beq.n	e4c0 <z_move_thread_to_end_of_prio_q+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e4a8:	b153      	cbz	r3, e4c0 <z_move_thread_to_end_of_prio_q+0x48>
	if (t1->base.prio < t2->base.prio) {
    e4aa:	f994 600e 	ldrsb.w	r6, [r4, #14]
    e4ae:	f993 700e 	ldrsb.w	r7, [r3, #14]
    e4b2:	42b7      	cmp	r7, r6
    e4b4:	dc0a      	bgt.n	e4cc <z_move_thread_to_end_of_prio_q+0x54>
	return (node == list->tail) ? NULL : node->next;
    e4b6:	4283      	cmp	r3, r0
    e4b8:	d002      	beq.n	e4c0 <z_move_thread_to_end_of_prio_q+0x48>
    e4ba:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e4bc:	2b00      	cmp	r3, #0
    e4be:	d1f6      	bne.n	e4ae <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
    e4c0:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
    e4c4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e4c6:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e4c8:	62d4      	str	r4, [r2, #44]	; 0x2c
    e4ca:	e005      	b.n	e4d8 <z_move_thread_to_end_of_prio_q+0x60>
	node->prev = successor->prev;
    e4cc:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    e4ce:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    e4d2:	6859      	ldr	r1, [r3, #4]
    e4d4:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    e4d6:	605c      	str	r4, [r3, #4]
    e4d8:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    e4da:	6890      	ldr	r0, [r2, #8]
    e4dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e4e0:	7363      	strb	r3, [r4, #13]
    e4e2:	1b03      	subs	r3, r0, r4
    e4e4:	4258      	negs	r0, r3
    e4e6:	4158      	adcs	r0, r3
    e4e8:	f7ff ff54 	bl	e394 <update_cache>
	__asm__ volatile(
    e4ec:	f385 8811 	msr	BASEPRI, r5
    e4f0:	f3bf 8f6f 	isb	sy
}
    e4f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e4f6:	bf00      	nop
    e4f8:	20000658 	.word	0x20000658
    e4fc:	20000630 	.word	0x20000630

0000e500 <z_time_slice>:
	if (pending_current == _current) {
    e500:	4a15      	ldr	r2, [pc, #84]	; (e558 <z_time_slice+0x58>)
    e502:	4916      	ldr	r1, [pc, #88]	; (e55c <z_time_slice+0x5c>)
{
    e504:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    e506:	680c      	ldr	r4, [r1, #0]
    e508:	6893      	ldr	r3, [r2, #8]
    e50a:	42a3      	cmp	r3, r4
    e50c:	4614      	mov	r4, r2
    e50e:	d103      	bne.n	e518 <z_time_slice+0x18>
}
    e510:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
    e514:	f7ff bed2 	b.w	e2bc <z_reset_time_slice>
	pending_current = NULL;
    e518:	2500      	movs	r5, #0
    e51a:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    e51c:	4910      	ldr	r1, [pc, #64]	; (e560 <z_time_slice+0x60>)
    e51e:	6809      	ldr	r1, [r1, #0]
    e520:	b1b9      	cbz	r1, e552 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
    e522:	89d9      	ldrh	r1, [r3, #14]
    e524:	297f      	cmp	r1, #127	; 0x7f
    e526:	d814      	bhi.n	e552 <z_time_slice+0x52>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
    e528:	490e      	ldr	r1, [pc, #56]	; (e564 <z_time_slice+0x64>)
    e52a:	f993 500e 	ldrsb.w	r5, [r3, #14]
    e52e:	6809      	ldr	r1, [r1, #0]
    e530:	428d      	cmp	r5, r1
    e532:	db0e      	blt.n	e552 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(t)
    e534:	490c      	ldr	r1, [pc, #48]	; (e568 <z_time_slice+0x68>)
    e536:	428b      	cmp	r3, r1
    e538:	d00b      	beq.n	e552 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
    e53a:	6999      	ldr	r1, [r3, #24]
    e53c:	b949      	cbnz	r1, e552 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
    e53e:	6911      	ldr	r1, [r2, #16]
    e540:	4281      	cmp	r1, r0
    e542:	dc03      	bgt.n	e54c <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
    e544:	4618      	mov	r0, r3
    e546:	f7ff ff97 	bl	e478 <z_move_thread_to_end_of_prio_q>
    e54a:	e7e1      	b.n	e510 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    e54c:	1a09      	subs	r1, r1, r0
    e54e:	6111      	str	r1, [r2, #16]
}
    e550:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    e552:	2300      	movs	r3, #0
    e554:	6123      	str	r3, [r4, #16]
    e556:	e7fb      	b.n	e550 <z_time_slice+0x50>
    e558:	20000630 	.word	0x20000630
    e55c:	20000660 	.word	0x20000660
    e560:	20000668 	.word	0x20000668
    e564:	20000664 	.word	0x20000664
    e568:	20000558 	.word	0x20000558

0000e56c <z_remove_thread_from_ready_q>:
{
    e56c:	b538      	push	{r3, r4, r5, lr}
    e56e:	4604      	mov	r4, r0
	__asm__ volatile(
    e570:	f04f 0320 	mov.w	r3, #32
    e574:	f3ef 8511 	mrs	r5, BASEPRI
    e578:	f383 8811 	msr	BASEPRI, r3
    e57c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    e580:	7b43      	ldrb	r3, [r0, #13]
    e582:	065a      	lsls	r2, r3, #25
    e584:	d507      	bpl.n	e596 <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    e586:	4601      	mov	r1, r0
    e588:	4809      	ldr	r0, [pc, #36]	; (e5b0 <z_remove_thread_from_ready_q+0x44>)
    e58a:	f7ff feed 	bl	e368 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    e58e:	7b63      	ldrb	r3, [r4, #13]
    e590:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    e594:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    e596:	4b07      	ldr	r3, [pc, #28]	; (e5b4 <z_remove_thread_from_ready_q+0x48>)
    e598:	6898      	ldr	r0, [r3, #8]
    e59a:	1b03      	subs	r3, r0, r4
    e59c:	4258      	negs	r0, r3
    e59e:	4158      	adcs	r0, r3
    e5a0:	f7ff fef8 	bl	e394 <update_cache>
	__asm__ volatile(
    e5a4:	f385 8811 	msr	BASEPRI, r5
    e5a8:	f3bf 8f6f 	isb	sy
}
    e5ac:	bd38      	pop	{r3, r4, r5, pc}
    e5ae:	bf00      	nop
    e5b0:	20000658 	.word	0x20000658
    e5b4:	20000630 	.word	0x20000630

0000e5b8 <pend>:
{
    e5b8:	b570      	push	{r4, r5, r6, lr}
    e5ba:	4604      	mov	r4, r0
    e5bc:	460d      	mov	r5, r1
    e5be:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
    e5c0:	f7ff ffd4 	bl	e56c <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
    e5c4:	7b63      	ldrb	r3, [r4, #13]
    e5c6:	f043 0302 	orr.w	r3, r3, #2
    e5ca:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    e5cc:	b1ed      	cbz	r5, e60a <pend+0x52>
	return list->head == list;
    e5ce:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    e5d0:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e5d2:	429d      	cmp	r5, r3
    e5d4:	d00c      	beq.n	e5f0 <pend+0x38>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e5d6:	b15b      	cbz	r3, e5f0 <pend+0x38>
	if (t1->base.prio < t2->base.prio) {
    e5d8:	f994 200e 	ldrsb.w	r2, [r4, #14]
    e5dc:	f993 100e 	ldrsb.w	r1, [r3, #14]
    e5e0:	4291      	cmp	r1, r2
    e5e2:	dc0c      	bgt.n	e5fe <pend+0x46>
	return (node == list->tail) ? NULL : node->next;
    e5e4:	6869      	ldr	r1, [r5, #4]
    e5e6:	428b      	cmp	r3, r1
    e5e8:	d002      	beq.n	e5f0 <pend+0x38>
    e5ea:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e5ec:	2b00      	cmp	r3, #0
    e5ee:	d1f5      	bne.n	e5dc <pend+0x24>
	node->prev = list->tail;
    e5f0:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    e5f2:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
    e5f4:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    e5f6:	686b      	ldr	r3, [r5, #4]
    e5f8:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e5fa:	606c      	str	r4, [r5, #4]
    e5fc:	e005      	b.n	e60a <pend+0x52>
	node->prev = successor->prev;
    e5fe:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e600:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    e604:	685a      	ldr	r2, [r3, #4]
    e606:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    e608:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
    e60a:	1c73      	adds	r3, r6, #1
    e60c:	d013      	beq.n	e636 <pend+0x7e>
    e60e:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    e612:	f240 30e7 	movw	r0, #999	; 0x3e7
    e616:	2100      	movs	r1, #0
    e618:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e61c:	fbc5 0106 	smlal	r0, r1, r5, r6
    e620:	2300      	movs	r3, #0
    e622:	f7fd fefd 	bl	c420 <__aeabi_ldivmod>

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    e626:	4904      	ldr	r1, [pc, #16]	; (e638 <pend+0x80>)
    e628:	1c42      	adds	r2, r0, #1
    e62a:	f104 0018 	add.w	r0, r4, #24
}
    e62e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e632:	f000 b93f 	b.w	e8b4 <z_add_timeout>
    e636:	bd70      	pop	{r4, r5, r6, pc}
    e638:	0001011b 	.word	0x0001011b

0000e63c <z_pend_curr>:
{
    e63c:	b510      	push	{r4, lr}
    e63e:	460c      	mov	r4, r1
    e640:	4611      	mov	r1, r2
	pending_current = _current;
    e642:	4a06      	ldr	r2, [pc, #24]	; (e65c <z_pend_curr+0x20>)
    e644:	6890      	ldr	r0, [r2, #8]
    e646:	4a06      	ldr	r2, [pc, #24]	; (e660 <z_pend_curr+0x24>)
    e648:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
    e64a:	461a      	mov	r2, r3
    e64c:	f7ff ffb4 	bl	e5b8 <pend>
    e650:	4620      	mov	r0, r4
}
    e652:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e656:	f7fe be8d 	b.w	d374 <z_arch_swap>
    e65a:	bf00      	nop
    e65c:	20000630 	.word	0x20000630
    e660:	20000660 	.word	0x20000660

0000e664 <z_set_prio>:
{
    e664:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e668:	4604      	mov	r4, r0
	__asm__ volatile(
    e66a:	f04f 0320 	mov.w	r3, #32
    e66e:	f3ef 8911 	mrs	r9, BASEPRI
    e672:	f383 8811 	msr	BASEPRI, r3
    e676:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
    e67a:	f001 fcfd 	bl	10078 <z_is_thread_ready>
    e67e:	b24e      	sxtb	r6, r1
		if (need_sched) {
    e680:	4680      	mov	r8, r0
    e682:	b368      	cbz	r0, e6e0 <z_set_prio+0x7c>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
    e684:	4d17      	ldr	r5, [pc, #92]	; (e6e4 <z_set_prio+0x80>)
    e686:	4621      	mov	r1, r4
    e688:	f105 0728 	add.w	r7, r5, #40	; 0x28
    e68c:	4638      	mov	r0, r7
    e68e:	f7ff fe6b 	bl	e368 <z_priq_dumb_remove>
	return list->head == list;
    e692:	6aab      	ldr	r3, [r5, #40]	; 0x28
				thread->base.prio = prio;
    e694:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e696:	42bb      	cmp	r3, r7
    e698:	462a      	mov	r2, r5
    e69a:	d00a      	beq.n	e6b2 <z_set_prio+0x4e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e69c:	b14b      	cbz	r3, e6b2 <z_set_prio+0x4e>
    e69e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    e6a0:	f993 000e 	ldrsb.w	r0, [r3, #14]
    e6a4:	42b0      	cmp	r0, r6
    e6a6:	dc0b      	bgt.n	e6c0 <z_set_prio+0x5c>
	return (node == list->tail) ? NULL : node->next;
    e6a8:	4299      	cmp	r1, r3
    e6aa:	d002      	beq.n	e6b2 <z_set_prio+0x4e>
    e6ac:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e6ae:	2b00      	cmp	r3, #0
    e6b0:	d1f6      	bne.n	e6a0 <z_set_prio+0x3c>
	node->prev = list->tail;
    e6b2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    e6b4:	6027      	str	r7, [r4, #0]
	node->prev = list->tail;
    e6b6:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    e6b8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e6ba:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e6bc:	62d4      	str	r4, [r2, #44]	; 0x2c
    e6be:	e005      	b.n	e6cc <z_set_prio+0x68>
	node->prev = successor->prev;
    e6c0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e6c2:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    e6c6:	685a      	ldr	r2, [r3, #4]
    e6c8:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    e6ca:	605c      	str	r4, [r3, #4]
			update_cache(1);
    e6cc:	2001      	movs	r0, #1
    e6ce:	f7ff fe61 	bl	e394 <update_cache>
	__asm__ volatile(
    e6d2:	f389 8811 	msr	BASEPRI, r9
    e6d6:	f3bf 8f6f 	isb	sy
}
    e6da:	4640      	mov	r0, r8
    e6dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			thread->base.prio = prio;
    e6e0:	73a6      	strb	r6, [r4, #14]
    e6e2:	e7f6      	b.n	e6d2 <z_set_prio+0x6e>
    e6e4:	20000630 	.word	0x20000630

0000e6e8 <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    e6e8:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
    e6ea:	4b04      	ldr	r3, [pc, #16]	; (e6fc <z_sched_init+0x14>)
    e6ec:	4608      	mov	r0, r1
    e6ee:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    e6f2:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    e6f6:	f7ff bdf7 	b.w	e2e8 <k_sched_time_slice_set>
    e6fa:	bf00      	nop
    e6fc:	20000630 	.word	0x20000630

0000e700 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    e700:	4b01      	ldr	r3, [pc, #4]	; (e708 <z_impl_k_current_get+0x8>)
    e702:	6898      	ldr	r0, [r3, #8]
    e704:	4770      	bx	lr
    e706:	bf00      	nop
    e708:	20000630 	.word	0x20000630

0000e70c <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    e70c:	b510      	push	{r4, lr}
    e70e:	4602      	mov	r2, r0
	__asm__ volatile(
    e710:	f04f 0320 	mov.w	r3, #32
    e714:	f3ef 8411 	mrs	r4, BASEPRI
    e718:	f383 8811 	msr	BASEPRI, r3
    e71c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    e720:	7b43      	ldrb	r3, [r0, #13]
    e722:	0759      	lsls	r1, r3, #29
    e724:	d404      	bmi.n	e730 <z_impl_k_thread_start+0x24>
	__asm__ volatile(
    e726:	f384 8811 	msr	BASEPRI, r4
    e72a:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    e72e:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    e730:	f023 0304 	bic.w	r3, r3, #4
    e734:	7343      	strb	r3, [r0, #13]
	if (z_is_thread_ready(thread)) {
    e736:	f001 fd4e 	bl	101d6 <z_is_thread_ready>
    e73a:	b110      	cbz	r0, e742 <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    e73c:	4610      	mov	r0, r2
    e73e:	f7ff fe63 	bl	e408 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    e742:	4621      	mov	r1, r4
}
    e744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    e748:	4801      	ldr	r0, [pc, #4]	; (e750 <z_impl_k_thread_start+0x44>)
    e74a:	f001 bcb7 	b.w	100bc <z_reschedule>
    e74e:	bf00      	nop
    e750:	2000068d 	.word	0x2000068d

0000e754 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    e754:	b530      	push	{r4, r5, lr}
    e756:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e758:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
    e75a:	4604      	mov	r4, r0
	z_arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e75c:	9504      	str	r5, [sp, #16]
    e75e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    e760:	9503      	str	r5, [sp, #12]
    e762:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    e764:	9502      	str	r5, [sp, #8]
    e766:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    e768:	9501      	str	r5, [sp, #4]
    e76a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    e76c:	9500      	str	r5, [sp, #0]
    e76e:	f7fe fe43 	bl	d3f8 <z_arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    e772:	4b04      	ldr	r3, [pc, #16]	; (e784 <z_setup_new_thread+0x30>)
    e774:	689b      	ldr	r3, [r3, #8]
    e776:	b913      	cbnz	r3, e77e <z_setup_new_thread+0x2a>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    e778:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    e77a:	b007      	add	sp, #28
    e77c:	bd30      	pop	{r4, r5, pc}
	new_thread->resource_pool = _current->resource_pool;
    e77e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    e780:	e7fa      	b.n	e778 <z_setup_new_thread+0x24>
    e782:	bf00      	nop
    e784:	20000630 	.word	0x20000630

0000e788 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    e788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    e78c:	4e28      	ldr	r6, [pc, #160]	; (e830 <z_init_static_threads+0xa8>)
    e78e:	4d29      	ldr	r5, [pc, #164]	; (e834 <z_init_static_threads+0xac>)
    e790:	46b0      	mov	r8, r6
{
    e792:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    e794:	42b5      	cmp	r5, r6
    e796:	f105 0430 	add.w	r4, r5, #48	; 0x30
    e79a:	d310      	bcc.n	e7be <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    e79c:	f7ff fdd0 	bl	e340 <k_sched_lock>
    e7a0:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    e7a4:	f240 36e7 	movw	r6, #999	; 0x3e7
    e7a8:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
    e7aa:	4c22      	ldr	r4, [pc, #136]	; (e834 <z_init_static_threads+0xac>)
    e7ac:	f8df a088 	ldr.w	sl, [pc, #136]	; e838 <z_init_static_threads+0xb0>
    e7b0:	4544      	cmp	r4, r8
    e7b2:	d321      	bcc.n	e7f8 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    e7b4:	b007      	add	sp, #28
    e7b6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    e7ba:	f7ff be09 	b.w	e3d0 <k_sched_unlock>
		z_setup_new_thread(
    e7be:	f854 3c04 	ldr.w	r3, [r4, #-4]
    e7c2:	9305      	str	r3, [sp, #20]
    e7c4:	f854 3c10 	ldr.w	r3, [r4, #-16]
    e7c8:	9304      	str	r3, [sp, #16]
    e7ca:	f854 3c14 	ldr.w	r3, [r4, #-20]
    e7ce:	9303      	str	r3, [sp, #12]
    e7d0:	f854 3c18 	ldr.w	r3, [r4, #-24]
    e7d4:	9302      	str	r3, [sp, #8]
    e7d6:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    e7da:	9301      	str	r3, [sp, #4]
    e7dc:	f854 3c20 	ldr.w	r3, [r4, #-32]
    e7e0:	9300      	str	r3, [sp, #0]
    e7e2:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    e7e6:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    e7ea:	f7ff ffb3 	bl	e754 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    e7ee:	f854 3c30 	ldr.w	r3, [r4, #-48]
    e7f2:	64dd      	str	r5, [r3, #76]	; 0x4c
    e7f4:	4625      	mov	r5, r4
    e7f6:	e7cd      	b.n	e794 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    e7f8:	6a61      	ldr	r1, [r4, #36]	; 0x24
    e7fa:	1c4b      	adds	r3, r1, #1
    e7fc:	d004      	beq.n	e808 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
    e7fe:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    e800:	b921      	cbnz	r1, e80c <z_init_static_threads+0x84>
	z_impl_k_thread_start(thread);
    e802:	4628      	mov	r0, r5
    e804:	f7ff ff82 	bl	e70c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    e808:	3430      	adds	r4, #48	; 0x30
    e80a:	e7d1      	b.n	e7b0 <z_init_static_threads+0x28>
    e80c:	46b3      	mov	fp, r6
    e80e:	46bc      	mov	ip, r7
    e810:	fbc9 bc01 	smlal	fp, ip, r9, r1
    e814:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e818:	2300      	movs	r3, #0
    e81a:	4658      	mov	r0, fp
    e81c:	4661      	mov	r1, ip
    e81e:	f7fd fdff 	bl	c420 <__aeabi_ldivmod>
    e822:	4651      	mov	r1, sl
    e824:	1c42      	adds	r2, r0, #1
    e826:	f105 0018 	add.w	r0, r5, #24
    e82a:	f000 f843 	bl	e8b4 <z_add_timeout>
    e82e:	e7eb      	b.n	e808 <z_init_static_threads+0x80>
    e830:	200014cc 	.word	0x200014cc
    e834:	200014cc 	.word	0x200014cc
    e838:	0001011b 	.word	0x0001011b

0000e83c <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    e83c:	4b03      	ldr	r3, [pc, #12]	; (e84c <elapsed+0x10>)
    e83e:	681b      	ldr	r3, [r3, #0]
    e840:	b90b      	cbnz	r3, e846 <elapsed+0xa>
    e842:	f7fe b9d5 	b.w	cbf0 <z_clock_elapsed>
}
    e846:	2000      	movs	r0, #0
    e848:	4770      	bx	lr
    e84a:	bf00      	nop
    e84c:	2000066c 	.word	0x2000066c

0000e850 <remove_timeout>:
{
    e850:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    e852:	b140      	cbz	r0, e866 <remove_timeout+0x16>
    e854:	4a08      	ldr	r2, [pc, #32]	; (e878 <remove_timeout+0x28>)
	return (node == list->tail) ? NULL : node->next;
    e856:	6852      	ldr	r2, [r2, #4]
    e858:	4290      	cmp	r0, r2
    e85a:	d004      	beq.n	e866 <remove_timeout+0x16>
	if (next(t) != NULL) {
    e85c:	b11b      	cbz	r3, e866 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    e85e:	689a      	ldr	r2, [r3, #8]
    e860:	6881      	ldr	r1, [r0, #8]
    e862:	440a      	add	r2, r1
    e864:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    e866:	6842      	ldr	r2, [r0, #4]
    e868:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    e86a:	6803      	ldr	r3, [r0, #0]
    e86c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    e86e:	2300      	movs	r3, #0
	node->prev = NULL;
    e870:	e9c0 3300 	strd	r3, r3, [r0]
}
    e874:	4770      	bx	lr
    e876:	bf00      	nop
    e878:	2000140c 	.word	0x2000140c

0000e87c <next_timeout>:
	return list->head == list;
    e87c:	4b0b      	ldr	r3, [pc, #44]	; (e8ac <next_timeout+0x30>)

static s32_t next_timeout(void)
{
    e87e:	b510      	push	{r4, lr}
    e880:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e882:	429c      	cmp	r4, r3
    e884:	bf08      	it	eq
    e886:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    e888:	f7ff ffd8 	bl	e83c <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    e88c:	b154      	cbz	r4, e8a4 <next_timeout+0x28>
    e88e:	68a3      	ldr	r3, [r4, #8]
    e890:	1a18      	subs	r0, r3, r0
    e892:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    e896:	4b06      	ldr	r3, [pc, #24]	; (e8b0 <next_timeout+0x34>)
    e898:	691b      	ldr	r3, [r3, #16]
    e89a:	b113      	cbz	r3, e8a2 <next_timeout+0x26>
    e89c:	4298      	cmp	r0, r3
    e89e:	bfa8      	it	ge
    e8a0:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    e8a2:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    e8a4:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    e8a8:	e7f5      	b.n	e896 <next_timeout+0x1a>
    e8aa:	bf00      	nop
    e8ac:	2000140c 	.word	0x2000140c
    e8b0:	20000630 	.word	0x20000630

0000e8b4 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    e8b4:	b570      	push	{r4, r5, r6, lr}
    e8b6:	4604      	mov	r4, r0
    e8b8:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    e8ba:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    e8bc:	f04f 0320 	mov.w	r3, #32
    e8c0:	f3ef 8511 	mrs	r5, BASEPRI
    e8c4:	f383 8811 	msr	BASEPRI, r3
    e8c8:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    e8cc:	f7ff ffb6 	bl	e83c <elapsed>
    e8d0:	2e01      	cmp	r6, #1
    e8d2:	bfac      	ite	ge
    e8d4:	1980      	addge	r0, r0, r6
    e8d6:	3001      	addlt	r0, #1
	return list->head == list;
    e8d8:	4b17      	ldr	r3, [pc, #92]	; (e938 <z_add_timeout+0x84>)
    e8da:	60a0      	str	r0, [r4, #8]
    e8dc:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e8de:	429a      	cmp	r2, r3
    e8e0:	d001      	beq.n	e8e6 <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    e8e2:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    e8e4:	b932      	cbnz	r2, e8f4 <z_add_timeout+0x40>
	node->prev = list->tail;
    e8e6:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    e8e8:	6023      	str	r3, [r4, #0]
	node->prev = list->tail;
    e8ea:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    e8ec:	685a      	ldr	r2, [r3, #4]
    e8ee:	6014      	str	r4, [r2, #0]
	list->tail = node;
    e8f0:	605c      	str	r4, [r3, #4]
    e8f2:	e00b      	b.n	e90c <z_add_timeout+0x58>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    e8f4:	6890      	ldr	r0, [r2, #8]
    e8f6:	68a1      	ldr	r1, [r4, #8]
    e8f8:	4288      	cmp	r0, r1
    e8fa:	dd16      	ble.n	e92a <z_add_timeout+0x76>
				t->dticks -= to->dticks;
    e8fc:	1a41      	subs	r1, r0, r1
    e8fe:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    e900:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    e902:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    e906:	6851      	ldr	r1, [r2, #4]
    e908:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    e90a:	6054      	str	r4, [r2, #4]
	return list->head == list;
    e90c:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e90e:	429a      	cmp	r2, r3
    e910:	d006      	beq.n	e920 <z_add_timeout+0x6c>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    e912:	4294      	cmp	r4, r2
    e914:	d104      	bne.n	e920 <z_add_timeout+0x6c>
			z_clock_set_timeout(next_timeout(), false);
    e916:	f7ff ffb1 	bl	e87c <next_timeout>
    e91a:	2100      	movs	r1, #0
    e91c:	f7fe f91a 	bl	cb54 <z_clock_set_timeout>
	__asm__ volatile(
    e920:	f385 8811 	msr	BASEPRI, r5
    e924:	f3bf 8f6f 	isb	sy
		}
	}
}
    e928:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    e92a:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    e92c:	4296      	cmp	r6, r2
    e92e:	60a1      	str	r1, [r4, #8]
    e930:	d0d9      	beq.n	e8e6 <z_add_timeout+0x32>
    e932:	6812      	ldr	r2, [r2, #0]
    e934:	e7d6      	b.n	e8e4 <z_add_timeout+0x30>
    e936:	bf00      	nop
    e938:	2000140c 	.word	0x2000140c

0000e93c <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    e93c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    e940:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    e942:	f7ff fddd 	bl	e500 <z_time_slice>
	__asm__ volatile(
    e946:	f04f 0320 	mov.w	r3, #32
    e94a:	f3ef 8511 	mrs	r5, BASEPRI
    e94e:	f383 8811 	msr	BASEPRI, r3
    e952:	f3bf 8f6f 	isb	sy
    e956:	4f21      	ldr	r7, [pc, #132]	; (e9dc <z_clock_announce+0xa0>)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    e958:	4e21      	ldr	r6, [pc, #132]	; (e9e0 <z_clock_announce+0xa4>)
    e95a:	46b8      	mov	r8, r7
	return list->head == list;
    e95c:	f8df 9084 	ldr.w	r9, [pc, #132]	; e9e4 <z_clock_announce+0xa8>
    e960:	6034      	str	r4, [r6, #0]
    e962:	f8d9 4000 	ldr.w	r4, [r9]
    e966:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e968:	454c      	cmp	r4, r9
    e96a:	e9d7 bc00 	ldrd	fp, ip, [r7]
    e96e:	d005      	beq.n	e97c <z_clock_announce+0x40>

	while (first() != NULL && first()->dticks <= announce_remaining) {
    e970:	b124      	cbz	r4, e97c <z_clock_announce+0x40>
    e972:	68a3      	ldr	r3, [r4, #8]
    e974:	4293      	cmp	r3, r2
    e976:	dd14      	ble.n	e9a2 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    e978:	1a9b      	subs	r3, r3, r2
    e97a:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    e97c:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    e97e:	eb1b 0002 	adds.w	r0, fp, r2
    e982:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
    e986:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    e98a:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    e98c:	f7ff ff76 	bl	e87c <next_timeout>
    e990:	4621      	mov	r1, r4
    e992:	f7fe f8df 	bl	cb54 <z_clock_set_timeout>
	__asm__ volatile(
    e996:	f385 8811 	msr	BASEPRI, r5
    e99a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    e99e:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    e9a2:	eb1b 0003 	adds.w	r0, fp, r3
    e9a6:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    e9aa:	1ad3      	subs	r3, r2, r3
    e9ac:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    e9ae:	2300      	movs	r3, #0
		curr_tick += dt;
    e9b0:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    e9b4:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    e9b6:	4620      	mov	r0, r4
    e9b8:	f7ff ff4a 	bl	e850 <remove_timeout>
    e9bc:	f385 8811 	msr	BASEPRI, r5
    e9c0:	f3bf 8f6f 	isb	sy
		t->fn(t);
    e9c4:	68e3      	ldr	r3, [r4, #12]
    e9c6:	4798      	blx	r3
	__asm__ volatile(
    e9c8:	f04f 0320 	mov.w	r3, #32
    e9cc:	f3ef 8511 	mrs	r5, BASEPRI
    e9d0:	f383 8811 	msr	BASEPRI, r3
    e9d4:	f3bf 8f6f 	isb	sy
    e9d8:	e7c3      	b.n	e962 <z_clock_announce+0x26>
    e9da:	bf00      	nop
    e9dc:	20000000 	.word	0x20000000
    e9e0:	2000066c 	.word	0x2000066c
    e9e4:	2000140c 	.word	0x2000140c

0000e9e8 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    e9e8:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    e9ea:	4c07      	ldr	r4, [pc, #28]	; (ea08 <init_static_pools+0x20>)
    e9ec:	4d07      	ldr	r5, [pc, #28]	; (ea0c <init_static_pools+0x24>)
    e9ee:	42ac      	cmp	r4, r5
    e9f0:	d301      	bcc.n	e9f6 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    e9f2:	2000      	movs	r0, #0
    e9f4:	bd38      	pop	{r3, r4, r5, pc}
    e9f6:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    e9fa:	4620      	mov	r0, r4
	list->tail = (sys_dnode_t *)list;
    e9fc:	e9c4 3305 	strd	r3, r3, [r4, #20]
    ea00:	f000 feee 	bl	f7e0 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    ea04:	341c      	adds	r4, #28
    ea06:	e7f2      	b.n	e9ee <init_static_pools+0x6>
    ea08:	200014cc 	.word	0x200014cc
    ea0c:	200014cc 	.word	0x200014cc

0000ea10 <CC_PalMemCopyPlat>:
    ea10:	f001 ba50 	b.w	feb4 <memmove>

0000ea14 <CC_PalMemSetZeroPlat>:
    ea14:	460a      	mov	r2, r1
    ea16:	2100      	movs	r1, #0
    ea18:	f001 ba90 	b.w	ff3c <memset>

0000ea1c <CC_PalInit>:
    ea1c:	b510      	push	{r4, lr}
    ea1e:	4811      	ldr	r0, [pc, #68]	; (ea64 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4>)
    ea20:	f000 f848 	bl	eab4 <CC_PalMutexCreate>
    ea24:	b100      	cbz	r0, ea28 <CC_PalInit+0xc>
    ea26:	bd10      	pop	{r4, pc}
    ea28:	480f      	ldr	r0, [pc, #60]	; (ea68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x8>)
    ea2a:	f000 f843 	bl	eab4 <CC_PalMutexCreate>
    ea2e:	2800      	cmp	r0, #0
    ea30:	d1f9      	bne.n	ea26 <CC_PalInit+0xa>
    ea32:	4c0e      	ldr	r4, [pc, #56]	; (ea6c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xc>)
    ea34:	4620      	mov	r0, r4
    ea36:	f000 f83d 	bl	eab4 <CC_PalMutexCreate>
    ea3a:	2800      	cmp	r0, #0
    ea3c:	d1f3      	bne.n	ea26 <CC_PalInit+0xa>
    ea3e:	4b0c      	ldr	r3, [pc, #48]	; (ea70 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x10>)
    ea40:	480c      	ldr	r0, [pc, #48]	; (ea74 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x14>)
    ea42:	601c      	str	r4, [r3, #0]
    ea44:	f000 f836 	bl	eab4 <CC_PalMutexCreate>
    ea48:	4601      	mov	r1, r0
    ea4a:	2800      	cmp	r0, #0
    ea4c:	d1eb      	bne.n	ea26 <CC_PalInit+0xa>
    ea4e:	f000 f82d 	bl	eaac <CC_PalDmaInit>
    ea52:	4604      	mov	r4, r0
    ea54:	b108      	cbz	r0, ea5a <CC_PalInit+0x3e>
    ea56:	4620      	mov	r0, r4
    ea58:	bd10      	pop	{r4, pc}
    ea5a:	f000 f851 	bl	eb00 <CC_PalPowerSaveModeInit>
    ea5e:	4620      	mov	r0, r4
    ea60:	e7fa      	b.n	ea58 <CC_PalInit+0x3c>
    ea62:	bf00      	nop
    ea64:	20001420 	.word	0x20001420
    ea68:	20001414 	.word	0x20001414
    ea6c:	2000141c 	.word	0x2000141c
    ea70:	20001424 	.word	0x20001424
    ea74:	20001418 	.word	0x20001418

0000ea78 <CC_PalTerminate>:
    ea78:	b508      	push	{r3, lr}
    ea7a:	4808      	ldr	r0, [pc, #32]	; (ea9c <CC_PalTerminate+0x24>)
    ea7c:	f000 f824 	bl	eac8 <CC_PalMutexDestroy>
    ea80:	4807      	ldr	r0, [pc, #28]	; (eaa0 <CC_PalTerminate+0x28>)
    ea82:	f000 f821 	bl	eac8 <CC_PalMutexDestroy>
    ea86:	4807      	ldr	r0, [pc, #28]	; (eaa4 <CC_PalTerminate+0x2c>)
    ea88:	f000 f81e 	bl	eac8 <CC_PalMutexDestroy>
    ea8c:	4806      	ldr	r0, [pc, #24]	; (eaa8 <CC_PalTerminate+0x30>)
    ea8e:	f000 f81b 	bl	eac8 <CC_PalMutexDestroy>
    ea92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ea96:	f000 b80b 	b.w	eab0 <CC_PalDmaTerminate>
    ea9a:	bf00      	nop
    ea9c:	20001420 	.word	0x20001420
    eaa0:	20001414 	.word	0x20001414
    eaa4:	2000141c 	.word	0x2000141c
    eaa8:	20001418 	.word	0x20001418

0000eaac <CC_PalDmaInit>:
    eaac:	2000      	movs	r0, #0
    eaae:	4770      	bx	lr

0000eab0 <CC_PalDmaTerminate>:
    eab0:	4770      	bx	lr
    eab2:	bf00      	nop

0000eab4 <CC_PalMutexCreate>:
    eab4:	b508      	push	{r3, lr}
    eab6:	4b03      	ldr	r3, [pc, #12]	; (eac4 <CC_PalMutexCreate+0x10>)
    eab8:	6802      	ldr	r2, [r0, #0]
    eaba:	681b      	ldr	r3, [r3, #0]
    eabc:	6810      	ldr	r0, [r2, #0]
    eabe:	4798      	blx	r3
    eac0:	2000      	movs	r0, #0
    eac2:	bd08      	pop	{r3, pc}
    eac4:	20001430 	.word	0x20001430

0000eac8 <CC_PalMutexDestroy>:
    eac8:	b508      	push	{r3, lr}
    eaca:	4b03      	ldr	r3, [pc, #12]	; (ead8 <CC_PalMutexDestroy+0x10>)
    eacc:	6802      	ldr	r2, [r0, #0]
    eace:	685b      	ldr	r3, [r3, #4]
    ead0:	6810      	ldr	r0, [r2, #0]
    ead2:	4798      	blx	r3
    ead4:	2000      	movs	r0, #0
    ead6:	bd08      	pop	{r3, pc}
    ead8:	20001430 	.word	0x20001430

0000eadc <CC_PalMutexLock>:
    eadc:	6802      	ldr	r2, [r0, #0]
    eade:	4b02      	ldr	r3, [pc, #8]	; (eae8 <CC_PalMutexLock+0xc>)
    eae0:	6810      	ldr	r0, [r2, #0]
    eae2:	689b      	ldr	r3, [r3, #8]
    eae4:	4718      	bx	r3
    eae6:	bf00      	nop
    eae8:	20001430 	.word	0x20001430

0000eaec <CC_PalMutexUnlock>:
    eaec:	b508      	push	{r3, lr}
    eaee:	4b03      	ldr	r3, [pc, #12]	; (eafc <CC_PalMutexUnlock+0x10>)
    eaf0:	6802      	ldr	r2, [r0, #0]
    eaf2:	68db      	ldr	r3, [r3, #12]
    eaf4:	6810      	ldr	r0, [r2, #0]
    eaf6:	4798      	blx	r3
    eaf8:	2000      	movs	r0, #0
    eafa:	bd08      	pop	{r3, pc}
    eafc:	20001430 	.word	0x20001430

0000eb00 <CC_PalPowerSaveModeInit>:
    eb00:	b570      	push	{r4, r5, r6, lr}
    eb02:	4c09      	ldr	r4, [pc, #36]	; (eb28 <CC_PalPowerSaveModeInit+0x28>)
    eb04:	4d09      	ldr	r5, [pc, #36]	; (eb2c <CC_PalPowerSaveModeInit+0x2c>)
    eb06:	6920      	ldr	r0, [r4, #16]
    eb08:	68ab      	ldr	r3, [r5, #8]
    eb0a:	4798      	blx	r3
    eb0c:	b118      	cbz	r0, eb16 <CC_PalPowerSaveModeInit+0x16>
    eb0e:	4b08      	ldr	r3, [pc, #32]	; (eb30 <CC_PalPowerSaveModeInit+0x30>)
    eb10:	4808      	ldr	r0, [pc, #32]	; (eb34 <CC_PalPowerSaveModeInit+0x34>)
    eb12:	685b      	ldr	r3, [r3, #4]
    eb14:	4798      	blx	r3
    eb16:	2100      	movs	r1, #0
    eb18:	4a07      	ldr	r2, [pc, #28]	; (eb38 <CC_PalPowerSaveModeInit+0x38>)
    eb1a:	68eb      	ldr	r3, [r5, #12]
    eb1c:	6011      	str	r1, [r2, #0]
    eb1e:	6920      	ldr	r0, [r4, #16]
    eb20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    eb24:	4718      	bx	r3
    eb26:	bf00      	nop
    eb28:	20001440 	.word	0x20001440
    eb2c:	20001430 	.word	0x20001430
    eb30:	20001428 	.word	0x20001428
    eb34:	000107d4 	.word	0x000107d4
    eb38:	20000670 	.word	0x20000670

0000eb3c <CC_PalPowerSaveModeSelect>:
    eb3c:	b570      	push	{r4, r5, r6, lr}
    eb3e:	4c14      	ldr	r4, [pc, #80]	; (eb90 <CC_PalPowerSaveModeSelect+0x54>)
    eb40:	4d14      	ldr	r5, [pc, #80]	; (eb94 <CC_PalPowerSaveModeSelect+0x58>)
    eb42:	4606      	mov	r6, r0
    eb44:	68ab      	ldr	r3, [r5, #8]
    eb46:	6920      	ldr	r0, [r4, #16]
    eb48:	4798      	blx	r3
    eb4a:	b9f0      	cbnz	r0, eb8a <CC_PalPowerSaveModeSelect+0x4e>
    eb4c:	4a12      	ldr	r2, [pc, #72]	; (eb98 <CC_PalPowerSaveModeSelect+0x5c>)
    eb4e:	6813      	ldr	r3, [r2, #0]
    eb50:	b95e      	cbnz	r6, eb6a <CC_PalPowerSaveModeSelect+0x2e>
    eb52:	b91b      	cbnz	r3, eb5c <CC_PalPowerSaveModeSelect+0x20>
    eb54:	2001      	movs	r0, #1
    eb56:	4911      	ldr	r1, [pc, #68]	; (eb9c <CC_PalPowerSaveModeSelect+0x60>)
    eb58:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
    eb5c:	3301      	adds	r3, #1
    eb5e:	6013      	str	r3, [r2, #0]
    eb60:	68eb      	ldr	r3, [r5, #12]
    eb62:	6920      	ldr	r0, [r4, #16]
    eb64:	4798      	blx	r3
    eb66:	2000      	movs	r0, #0
    eb68:	bd70      	pop	{r4, r5, r6, pc}
    eb6a:	2b00      	cmp	r3, #0
    eb6c:	d0f8      	beq.n	eb60 <CC_PalPowerSaveModeSelect+0x24>
    eb6e:	2b01      	cmp	r3, #1
    eb70:	bf08      	it	eq
    eb72:	490a      	ldreq	r1, [pc, #40]	; (eb9c <CC_PalPowerSaveModeSelect+0x60>)
    eb74:	f103 33ff 	add.w	r3, r3, #4294967295
    eb78:	bf08      	it	eq
    eb7a:	f8c1 0500 	streq.w	r0, [r1, #1280]	; 0x500
    eb7e:	6920      	ldr	r0, [r4, #16]
    eb80:	6013      	str	r3, [r2, #0]
    eb82:	68eb      	ldr	r3, [r5, #12]
    eb84:	4798      	blx	r3
    eb86:	2000      	movs	r0, #0
    eb88:	e7ee      	b.n	eb68 <CC_PalPowerSaveModeSelect+0x2c>
    eb8a:	4805      	ldr	r0, [pc, #20]	; (eba0 <CC_PalPowerSaveModeSelect+0x64>)
    eb8c:	bd70      	pop	{r4, r5, r6, pc}
    eb8e:	bf00      	nop
    eb90:	20001440 	.word	0x20001440
    eb94:	20001430 	.word	0x20001430
    eb98:	20000670 	.word	0x20000670
    eb9c:	50840000 	.word	0x50840000
    eba0:	ffff8fe9 	.word	0xffff8fe9

0000eba4 <CC_HalInit>:
    eba4:	2000      	movs	r0, #0
    eba6:	4770      	bx	lr

0000eba8 <CC_HalTerminate>:
    eba8:	2000      	movs	r0, #0
    ebaa:	4770      	bx	lr

0000ebac <CC_HalClearInterruptBit>:
    ebac:	0543      	lsls	r3, r0, #21
    ebae:	d503      	bpl.n	ebb8 <CC_HalClearInterruptBit+0xc>
    ebb0:	f04f 32ff 	mov.w	r2, #4294967295
    ebb4:	4b02      	ldr	r3, [pc, #8]	; (ebc0 <CC_HalClearInterruptBit+0x14>)
    ebb6:	601a      	str	r2, [r3, #0]
    ebb8:	4b02      	ldr	r3, [pc, #8]	; (ebc4 <CC_HalClearInterruptBit+0x18>)
    ebba:	6018      	str	r0, [r3, #0]
    ebbc:	4770      	bx	lr
    ebbe:	bf00      	nop
    ebc0:	50841108 	.word	0x50841108
    ebc4:	50841a08 	.word	0x50841a08

0000ebc8 <CC_HalMaskInterrupt>:
    ebc8:	4b01      	ldr	r3, [pc, #4]	; (ebd0 <CC_HalMaskInterrupt+0x8>)
    ebca:	6018      	str	r0, [r3, #0]
    ebcc:	4770      	bx	lr
    ebce:	bf00      	nop
    ebd0:	50841a04 	.word	0x50841a04

0000ebd4 <CC_HalWaitInterruptRND>:
    ebd4:	b108      	cbz	r0, ebda <CC_HalWaitInterruptRND+0x6>
    ebd6:	f000 b803 	b.w	ebe0 <CC_PalWaitInterruptRND>
    ebda:	f44f 0075 	mov.w	r0, #16056320	; 0xf50000
    ebde:	4770      	bx	lr

0000ebe0 <CC_PalWaitInterruptRND>:
    ebe0:	4602      	mov	r2, r0
    ebe2:	4807      	ldr	r0, [pc, #28]	; (ec00 <CC_PalWaitInterruptRND+0x20>)
    ebe4:	6803      	ldr	r3, [r0, #0]
    ebe6:	4213      	tst	r3, r2
    ebe8:	d0fc      	beq.n	ebe4 <CC_PalWaitInterruptRND+0x4>
    ebea:	b121      	cbz	r1, ebf6 <CC_PalWaitInterruptRND+0x16>
    ebec:	4b05      	ldr	r3, [pc, #20]	; (ec04 <CC_PalWaitInterruptRND+0x24>)
    ebee:	4806      	ldr	r0, [pc, #24]	; (ec08 <CC_PalWaitInterruptRND+0x28>)
    ebf0:	681b      	ldr	r3, [r3, #0]
    ebf2:	600b      	str	r3, [r1, #0]
    ebf4:	6003      	str	r3, [r0, #0]
    ebf6:	4b05      	ldr	r3, [pc, #20]	; (ec0c <CC_PalWaitInterruptRND+0x2c>)
    ebf8:	2000      	movs	r0, #0
    ebfa:	601a      	str	r2, [r3, #0]
    ebfc:	4770      	bx	lr
    ebfe:	bf00      	nop
    ec00:	50841a00 	.word	0x50841a00
    ec04:	50841104 	.word	0x50841104
    ec08:	50841108 	.word	0x50841108
    ec0c:	50841a08 	.word	0x50841a08

0000ec10 <mbedtls_platform_setup>:
    ec10:	f000 b8a0 	b.w	ed54 <nrf_cc310_platform_init>

0000ec14 <mbedtls_platform_zeroize>:
    ec14:	b130      	cbz	r0, ec24 <mbedtls_platform_zeroize+0x10>
    ec16:	b129      	cbz	r1, ec24 <mbedtls_platform_zeroize+0x10>
    ec18:	2300      	movs	r3, #0
    ec1a:	4401      	add	r1, r0
    ec1c:	7003      	strb	r3, [r0, #0]
    ec1e:	3001      	adds	r0, #1
    ec20:	4281      	cmp	r1, r0
    ec22:	d1fb      	bne.n	ec1c <mbedtls_platform_zeroize+0x8>
    ec24:	4770      	bx	lr
    ec26:	bf00      	nop

0000ec28 <mbedtls_hardware_poll>:
    ec28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ec2c:	f5ad 7d1a 	sub.w	sp, sp, #616	; 0x268
    ec30:	460f      	mov	r7, r1
    ec32:	9205      	str	r2, [sp, #20]
    ec34:	2100      	movs	r1, #0
    ec36:	4614      	mov	r4, r2
    ec38:	a812      	add	r0, sp, #72	; 0x48
    ec3a:	f44f 7208 	mov.w	r2, #544	; 0x220
    ec3e:	461e      	mov	r6, r3
    ec40:	f001 f97c 	bl	ff3c <memset>
    ec44:	2300      	movs	r3, #0
    ec46:	a808      	add	r0, sp, #32
    ec48:	4619      	mov	r1, r3
    ec4a:	2228      	movs	r2, #40	; 0x28
    ec4c:	9306      	str	r3, [sp, #24]
    ec4e:	f001 f975 	bl	ff3c <memset>
    ec52:	2f00      	cmp	r7, #0
    ec54:	d03c      	beq.n	ecd0 <mbedtls_hardware_poll+0xa8>
    ec56:	2e00      	cmp	r6, #0
    ec58:	d03a      	beq.n	ecd0 <mbedtls_hardware_poll+0xa8>
    ec5a:	2c00      	cmp	r4, #0
    ec5c:	d038      	beq.n	ecd0 <mbedtls_hardware_poll+0xa8>
    ec5e:	2104      	movs	r1, #4
    ec60:	a806      	add	r0, sp, #24
    ec62:	f7ff fed7 	bl	ea14 <CC_PalMemSetZeroPlat>
    ec66:	a808      	add	r0, sp, #32
    ec68:	2128      	movs	r1, #40	; 0x28
    ec6a:	f7ff fed3 	bl	ea14 <CC_PalMemSetZeroPlat>
    ec6e:	a808      	add	r0, sp, #32
    ec70:	f000 f832 	bl	ecd8 <RNG_PLAT_SetUserRngParameters>
    ec74:	b178      	cbz	r0, ec96 <mbedtls_hardware_poll+0x6e>
    ec76:	f04f 35ff 	mov.w	r5, #4294967295
    ec7a:	a812      	add	r0, sp, #72	; 0x48
    ec7c:	f44f 7108 	mov.w	r1, #544	; 0x220
    ec80:	f7ff ffc8 	bl	ec14 <mbedtls_platform_zeroize>
    ec84:	a806      	add	r0, sp, #24
    ec86:	2104      	movs	r1, #4
    ec88:	f7ff ffc4 	bl	ec14 <mbedtls_platform_zeroize>
    ec8c:	4628      	mov	r0, r5
    ec8e:	f50d 7d1a 	add.w	sp, sp, #616	; 0x268
    ec92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ec96:	ab12      	add	r3, sp, #72	; 0x48
    ec98:	f10d 081c 	add.w	r8, sp, #28
    ec9c:	9003      	str	r0, [sp, #12]
    ec9e:	e9cd 6301 	strd	r6, r3, [sp, #4]
    eca2:	4602      	mov	r2, r0
    eca4:	ab05      	add	r3, sp, #20
    eca6:	a908      	add	r1, sp, #32
    eca8:	f8cd 8000 	str.w	r8, [sp]
    ecac:	a806      	add	r0, sp, #24
    ecae:	f000 fce9 	bl	f684 <LLF_RND_GetTrngSource>
    ecb2:	2800      	cmp	r0, #0
    ecb4:	d1df      	bne.n	ec76 <mbedtls_hardware_poll+0x4e>
    ecb6:	6833      	ldr	r3, [r6, #0]
    ecb8:	42a3      	cmp	r3, r4
    ecba:	d3dc      	bcc.n	ec76 <mbedtls_hardware_poll+0x4e>
    ecbc:	f8d8 1000 	ldr.w	r1, [r8]
    ecc0:	4605      	mov	r5, r0
    ecc2:	3108      	adds	r1, #8
    ecc4:	4638      	mov	r0, r7
    ecc6:	4622      	mov	r2, r4
    ecc8:	f7ff fea2 	bl	ea10 <CC_PalMemCopyPlat>
    eccc:	6034      	str	r4, [r6, #0]
    ecce:	e7d4      	b.n	ec7a <mbedtls_hardware_poll+0x52>
    ecd0:	f04f 35ff 	mov.w	r5, #4294967295
    ecd4:	e7da      	b.n	ec8c <mbedtls_hardware_poll+0x64>
    ecd6:	bf00      	nop

0000ecd8 <RNG_PLAT_SetUserRngParameters>:
    ecd8:	231c      	movs	r3, #28
    ecda:	b530      	push	{r4, r5, lr}
    ecdc:	b083      	sub	sp, #12
    ecde:	a902      	add	r1, sp, #8
    ece0:	f841 3d04 	str.w	r3, [r1, #-4]!
    ece4:	4604      	mov	r4, r0
    ece6:	f000 f9b1 	bl	f04c <CC_PalTrngParamGet>
    ecea:	4605      	mov	r5, r0
    ecec:	b9d8      	cbnz	r0, ed26 <RNG_PLAT_SetUserRngParameters+0x4e>
    ecee:	9b01      	ldr	r3, [sp, #4]
    ecf0:	2b1c      	cmp	r3, #28
    ecf2:	d11b      	bne.n	ed2c <RNG_PLAT_SetUserRngParameters+0x54>
    ecf4:	e9d4 3200 	ldrd	r3, r2, [r4]
    ecf8:	2101      	movs	r1, #1
    ecfa:	3300      	adds	r3, #0
    ecfc:	61e1      	str	r1, [r4, #28]
    ecfe:	bf18      	it	ne
    ed00:	2301      	movne	r3, #1
    ed02:	b10a      	cbz	r2, ed08 <RNG_PLAT_SetUserRngParameters+0x30>
    ed04:	f043 0302 	orr.w	r3, r3, #2
    ed08:	68a2      	ldr	r2, [r4, #8]
    ed0a:	b932      	cbnz	r2, ed1a <RNG_PLAT_SetUserRngParameters+0x42>
    ed0c:	68e2      	ldr	r2, [r4, #12]
    ed0e:	b9aa      	cbnz	r2, ed3c <RNG_PLAT_SetUserRngParameters+0x64>
    ed10:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ed14:	b93b      	cbnz	r3, ed26 <RNG_PLAT_SetUserRngParameters+0x4e>
    ed16:	4d0d      	ldr	r5, [pc, #52]	; (ed4c <RNG_PLAT_SetUserRngParameters+0x74>)
    ed18:	e009      	b.n	ed2e <RNG_PLAT_SetUserRngParameters+0x56>
    ed1a:	68e2      	ldr	r2, [r4, #12]
    ed1c:	f043 0304 	orr.w	r3, r3, #4
    ed20:	b962      	cbnz	r2, ed3c <RNG_PLAT_SetUserRngParameters+0x64>
    ed22:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ed26:	4628      	mov	r0, r5
    ed28:	b003      	add	sp, #12
    ed2a:	bd30      	pop	{r4, r5, pc}
    ed2c:	4d08      	ldr	r5, [pc, #32]	; (ed50 <RNG_PLAT_SetUserRngParameters+0x78>)
    ed2e:	4620      	mov	r0, r4
    ed30:	211c      	movs	r1, #28
    ed32:	f7ff fe6f 	bl	ea14 <CC_PalMemSetZeroPlat>
    ed36:	4628      	mov	r0, r5
    ed38:	b003      	add	sp, #12
    ed3a:	bd30      	pop	{r4, r5, pc}
    ed3c:	2200      	movs	r2, #0
    ed3e:	4628      	mov	r0, r5
    ed40:	f043 0308 	orr.w	r3, r3, #8
    ed44:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ed48:	b003      	add	sp, #12
    ed4a:	bd30      	pop	{r4, r5, pc}
    ed4c:	00f00c0e 	.word	0x00f00c0e
    ed50:	00f00c37 	.word	0x00f00c37

0000ed54 <nrf_cc310_platform_init>:
    ed54:	b510      	push	{r4, lr}
    ed56:	4c0c      	ldr	r4, [pc, #48]	; (ed88 <nrf_cc310_platform_init+0x34>)
    ed58:	6823      	ldr	r3, [r4, #0]
    ed5a:	b113      	cbz	r3, ed62 <nrf_cc310_platform_init+0xe>
    ed5c:	4b0b      	ldr	r3, [pc, #44]	; (ed8c <nrf_cc310_platform_init+0x38>)
    ed5e:	681b      	ldr	r3, [r3, #0]
    ed60:	b96b      	cbnz	r3, ed7e <nrf_cc310_platform_init+0x2a>
    ed62:	f000 f931 	bl	efc8 <CC_LibInit>
    ed66:	b138      	cbz	r0, ed78 <nrf_cc310_platform_init+0x24>
    ed68:	3801      	subs	r0, #1
    ed6a:	2806      	cmp	r0, #6
    ed6c:	bf96      	itet	ls
    ed6e:	4b08      	ldrls	r3, [pc, #32]	; (ed90 <nrf_cc310_platform_init+0x3c>)
    ed70:	4808      	ldrhi	r0, [pc, #32]	; (ed94 <nrf_cc310_platform_init+0x40>)
    ed72:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    ed76:	bd10      	pop	{r4, pc}
    ed78:	2201      	movs	r2, #1
    ed7a:	4b04      	ldr	r3, [pc, #16]	; (ed8c <nrf_cc310_platform_init+0x38>)
    ed7c:	601a      	str	r2, [r3, #0]
    ed7e:	2301      	movs	r3, #1
    ed80:	2000      	movs	r0, #0
    ed82:	6023      	str	r3, [r4, #0]
    ed84:	bd10      	pop	{r4, pc}
    ed86:	bf00      	nop
    ed88:	20000674 	.word	0x20000674
    ed8c:	20000678 	.word	0x20000678
    ed90:	000107f4 	.word	0x000107f4
    ed94:	ffff8ffe 	.word	0xffff8ffe

0000ed98 <nrf_cc310_platform_init_no_rng>:
    ed98:	b510      	push	{r4, lr}
    ed9a:	4c09      	ldr	r4, [pc, #36]	; (edc0 <nrf_cc310_platform_init_no_rng+0x28>)
    ed9c:	6823      	ldr	r3, [r4, #0]
    ed9e:	b11b      	cbz	r3, eda8 <nrf_cc310_platform_init_no_rng+0x10>
    eda0:	2301      	movs	r3, #1
    eda2:	2000      	movs	r0, #0
    eda4:	6023      	str	r3, [r4, #0]
    eda6:	bd10      	pop	{r4, pc}
    eda8:	f000 f87c 	bl	eea4 <CC_LibInitNoRng>
    edac:	2800      	cmp	r0, #0
    edae:	d0f7      	beq.n	eda0 <nrf_cc310_platform_init_no_rng+0x8>
    edb0:	3801      	subs	r0, #1
    edb2:	2806      	cmp	r0, #6
    edb4:	bf96      	itet	ls
    edb6:	4b03      	ldrls	r3, [pc, #12]	; (edc4 <nrf_cc310_platform_init_no_rng+0x2c>)
    edb8:	4803      	ldrhi	r0, [pc, #12]	; (edc8 <nrf_cc310_platform_init_no_rng+0x30>)
    edba:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    edbe:	bd10      	pop	{r4, pc}
    edc0:	20000674 	.word	0x20000674
    edc4:	000107f4 	.word	0x000107f4
    edc8:	ffff8ffe 	.word	0xffff8ffe

0000edcc <nrf_cc310_platform_abort>:
    edcc:	f3bf 8f4f 	dsb	sy
    edd0:	4905      	ldr	r1, [pc, #20]	; (ede8 <nrf_cc310_platform_abort+0x1c>)
    edd2:	4b06      	ldr	r3, [pc, #24]	; (edec <nrf_cc310_platform_abort+0x20>)
    edd4:	68ca      	ldr	r2, [r1, #12]
    edd6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    edda:	4313      	orrs	r3, r2
    eddc:	60cb      	str	r3, [r1, #12]
    edde:	f3bf 8f4f 	dsb	sy
    ede2:	bf00      	nop
    ede4:	e7fd      	b.n	ede2 <nrf_cc310_platform_abort+0x16>
    ede6:	bf00      	nop
    ede8:	e000ed00 	.word	0xe000ed00
    edec:	05fa0004 	.word	0x05fa0004

0000edf0 <CC_PalAbort>:
    edf0:	4b01      	ldr	r3, [pc, #4]	; (edf8 <CC_PalAbort+0x8>)
    edf2:	685b      	ldr	r3, [r3, #4]
    edf4:	4718      	bx	r3
    edf6:	bf00      	nop
    edf8:	20001428 	.word	0x20001428

0000edfc <nrf_cc310_platform_set_abort>:
    edfc:	4b02      	ldr	r3, [pc, #8]	; (ee08 <nrf_cc310_platform_set_abort+0xc>)
    edfe:	e9d0 1200 	ldrd	r1, r2, [r0]
    ee02:	e9c3 1200 	strd	r1, r2, [r3]
    ee06:	4770      	bx	lr
    ee08:	20001428 	.word	0x20001428

0000ee0c <mutex_free>:
    ee0c:	4770      	bx	lr
    ee0e:	bf00      	nop

0000ee10 <mutex_unlock>:
    ee10:	b510      	push	{r4, lr}
    ee12:	4604      	mov	r4, r0
    ee14:	b120      	cbz	r0, ee20 <mutex_unlock+0x10>
    ee16:	f3bf 8f5f 	dmb	sy
    ee1a:	2000      	movs	r0, #0
    ee1c:	6020      	str	r0, [r4, #0]
    ee1e:	bd10      	pop	{r4, pc}
    ee20:	4803      	ldr	r0, [pc, #12]	; (ee30 <mutex_unlock+0x20>)
    ee22:	f7ff ffe5 	bl	edf0 <CC_PalAbort>
    ee26:	f3bf 8f5f 	dmb	sy
    ee2a:	2000      	movs	r0, #0
    ee2c:	6020      	str	r0, [r4, #0]
    ee2e:	bd10      	pop	{r4, pc}
    ee30:	00010834 	.word	0x00010834

0000ee34 <mutex_init>:
    ee34:	b510      	push	{r4, lr}
    ee36:	4604      	mov	r4, r0
    ee38:	b110      	cbz	r0, ee40 <mutex_init+0xc>
    ee3a:	2300      	movs	r3, #0
    ee3c:	6023      	str	r3, [r4, #0]
    ee3e:	bd10      	pop	{r4, pc}
    ee40:	4802      	ldr	r0, [pc, #8]	; (ee4c <mutex_init+0x18>)
    ee42:	f7ff ffd5 	bl	edf0 <CC_PalAbort>
    ee46:	2300      	movs	r3, #0
    ee48:	6023      	str	r3, [r4, #0]
    ee4a:	bd10      	pop	{r4, pc}
    ee4c:	00010810 	.word	0x00010810

0000ee50 <mutex_lock>:
    ee50:	b150      	cbz	r0, ee68 <mutex_lock+0x18>
    ee52:	2201      	movs	r2, #1
    ee54:	e8d0 3fef 	ldaex	r3, [r0]
    ee58:	e8c0 2fe1 	stlex	r1, r2, [r0]
    ee5c:	2900      	cmp	r1, #0
    ee5e:	d1f9      	bne.n	ee54 <mutex_lock+0x4>
    ee60:	2b01      	cmp	r3, #1
    ee62:	d0f7      	beq.n	ee54 <mutex_lock+0x4>
    ee64:	f3bf 8f5f 	dmb	sy
    ee68:	2000      	movs	r0, #0
    ee6a:	4770      	bx	lr

0000ee6c <nrf_cc310_platform_set_mutexes>:
    ee6c:	b470      	push	{r4, r5, r6}
    ee6e:	4b0b      	ldr	r3, [pc, #44]	; (ee9c <nrf_cc310_platform_set_mutexes+0x30>)
    ee70:	6806      	ldr	r6, [r0, #0]
    ee72:	68c2      	ldr	r2, [r0, #12]
    ee74:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    ee78:	e9c3 4202 	strd	r4, r2, [r3, #8]
    ee7c:	e9c3 6500 	strd	r6, r5, [r3]
    ee80:	e9d1 0203 	ldrd	r0, r2, [r1, #12]
    ee84:	680e      	ldr	r6, [r1, #0]
    ee86:	4b06      	ldr	r3, [pc, #24]	; (eea0 <nrf_cc310_platform_set_mutexes+0x34>)
    ee88:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    ee8c:	e9c3 6500 	strd	r6, r5, [r3]
    ee90:	e9c3 4002 	strd	r4, r0, [r3, #8]
    ee94:	611a      	str	r2, [r3, #16]
    ee96:	bc70      	pop	{r4, r5, r6}
    ee98:	4770      	bx	lr
    ee9a:	bf00      	nop
    ee9c:	20001430 	.word	0x20001430
    eea0:	20001440 	.word	0x20001440

0000eea4 <CC_LibInitNoRng>:
    eea4:	b510      	push	{r4, lr}
    eea6:	f7ff fe7d 	bl	eba4 <CC_HalInit>
    eeaa:	b970      	cbnz	r0, eeca <CC_LibInitNoRng+0x26>
    eeac:	f7ff fdb6 	bl	ea1c <CC_PalInit>
    eeb0:	b980      	cbnz	r0, eed4 <CC_LibInitNoRng+0x30>
    eeb2:	f7ff fe43 	bl	eb3c <CC_PalPowerSaveModeSelect>
    eeb6:	b980      	cbnz	r0, eeda <CC_LibInitNoRng+0x36>
    eeb8:	4b11      	ldr	r3, [pc, #68]	; (ef00 <CC_LibInitNoRng+0x5c>)
    eeba:	681b      	ldr	r3, [r3, #0]
    eebc:	0e1b      	lsrs	r3, r3, #24
    eebe:	2bf0      	cmp	r3, #240	; 0xf0
    eec0:	d00d      	beq.n	eede <CC_LibInitNoRng+0x3a>
    eec2:	2406      	movs	r4, #6
    eec4:	f7ff fe70 	bl	eba8 <CC_HalTerminate>
    eec8:	e000      	b.n	eecc <CC_LibInitNoRng+0x28>
    eeca:	2403      	movs	r4, #3
    eecc:	f7ff fdd4 	bl	ea78 <CC_PalTerminate>
    eed0:	4620      	mov	r0, r4
    eed2:	bd10      	pop	{r4, pc}
    eed4:	2404      	movs	r4, #4
    eed6:	4620      	mov	r0, r4
    eed8:	bd10      	pop	{r4, pc}
    eeda:	2400      	movs	r4, #0
    eedc:	e7f2      	b.n	eec4 <CC_LibInitNoRng+0x20>
    eede:	4a09      	ldr	r2, [pc, #36]	; (ef04 <CC_LibInitNoRng+0x60>)
    eee0:	4b09      	ldr	r3, [pc, #36]	; (ef08 <CC_LibInitNoRng+0x64>)
    eee2:	6812      	ldr	r2, [r2, #0]
    eee4:	429a      	cmp	r2, r3
    eee6:	d001      	beq.n	eeec <CC_LibInitNoRng+0x48>
    eee8:	2407      	movs	r4, #7
    eeea:	e7eb      	b.n	eec4 <CC_LibInitNoRng+0x20>
    eeec:	2001      	movs	r0, #1
    eeee:	f7ff fe25 	bl	eb3c <CC_PalPowerSaveModeSelect>
    eef2:	2800      	cmp	r0, #0
    eef4:	d1f1      	bne.n	eeda <CC_LibInitNoRng+0x36>
    eef6:	4b05      	ldr	r3, [pc, #20]	; (ef0c <CC_LibInitNoRng+0x68>)
    eef8:	4604      	mov	r4, r0
    eefa:	6018      	str	r0, [r3, #0]
    eefc:	e7e8      	b.n	eed0 <CC_LibInitNoRng+0x2c>
    eefe:	bf00      	nop
    ef00:	50841928 	.word	0x50841928
    ef04:	50841a24 	.word	0x50841a24
    ef08:	20e00000 	.word	0x20e00000
    ef0c:	50841a0c 	.word	0x50841a0c

0000ef10 <CC_LibInitRngModule>:
    ef10:	b530      	push	{r4, r5, lr}
    ef12:	f5ad 7d15 	sub.w	sp, sp, #596	; 0x254
    ef16:	f44f 7208 	mov.w	r2, #544	; 0x220
    ef1a:	2100      	movs	r1, #0
    ef1c:	a80c      	add	r0, sp, #48	; 0x30
    ef1e:	f001 f80d 	bl	ff3c <memset>
    ef22:	2300      	movs	r3, #0
    ef24:	a802      	add	r0, sp, #8
    ef26:	4619      	mov	r1, r3
    ef28:	2228      	movs	r2, #40	; 0x28
    ef2a:	9301      	str	r3, [sp, #4]
    ef2c:	f001 f806 	bl	ff3c <memset>
    ef30:	a802      	add	r0, sp, #8
    ef32:	f7ff fed1 	bl	ecd8 <RNG_PLAT_SetUserRngParameters>
    ef36:	b118      	cbz	r0, ef40 <CC_LibInitRngModule+0x30>
    ef38:	2005      	movs	r0, #5
    ef3a:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
    ef3e:	bd30      	pop	{r4, r5, pc}
    ef40:	4d1c      	ldr	r5, [pc, #112]	; (efb4 <CC_LibInitRngModule+0xa4>)
    ef42:	f04f 31ff 	mov.w	r1, #4294967295
    ef46:	6828      	ldr	r0, [r5, #0]
    ef48:	f7ff fdc8 	bl	eadc <CC_PalMutexLock>
    ef4c:	4604      	mov	r4, r0
    ef4e:	b9f0      	cbnz	r0, ef8e <CC_LibInitRngModule+0x7e>
    ef50:	2000      	movs	r0, #0
    ef52:	f7ff fdf3 	bl	eb3c <CC_PalPowerSaveModeSelect>
    ef56:	b9b0      	cbnz	r0, ef86 <CC_LibInitRngModule+0x76>
    ef58:	aa0c      	add	r2, sp, #48	; 0x30
    ef5a:	a902      	add	r1, sp, #8
    ef5c:	a801      	add	r0, sp, #4
    ef5e:	f000 fbd5 	bl	f70c <LLF_RND_RunTrngStartupTest>
    ef62:	4604      	mov	r4, r0
    ef64:	2001      	movs	r0, #1
    ef66:	f7ff fde9 	bl	eb3c <CC_PalPowerSaveModeSelect>
    ef6a:	b9f0      	cbnz	r0, efaa <CC_LibInitRngModule+0x9a>
    ef6c:	6828      	ldr	r0, [r5, #0]
    ef6e:	f7ff fdbd 	bl	eaec <CC_PalMutexUnlock>
    ef72:	b110      	cbz	r0, ef7a <CC_LibInitRngModule+0x6a>
    ef74:	4810      	ldr	r0, [pc, #64]	; (efb8 <CC_LibInitRngModule+0xa8>)
    ef76:	f7ff ff3b 	bl	edf0 <CC_PalAbort>
    ef7a:	4620      	mov	r0, r4
    ef7c:	2c00      	cmp	r4, #0
    ef7e:	d1db      	bne.n	ef38 <CC_LibInitRngModule+0x28>
    ef80:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
    ef84:	bd30      	pop	{r4, r5, pc}
    ef86:	480d      	ldr	r0, [pc, #52]	; (efbc <CC_LibInitRngModule+0xac>)
    ef88:	f7ff ff32 	bl	edf0 <CC_PalAbort>
    ef8c:	e7e4      	b.n	ef58 <CC_LibInitRngModule+0x48>
    ef8e:	480c      	ldr	r0, [pc, #48]	; (efc0 <CC_LibInitRngModule+0xb0>)
    ef90:	f7ff ff2e 	bl	edf0 <CC_PalAbort>
    ef94:	2c01      	cmp	r4, #1
    ef96:	d1db      	bne.n	ef50 <CC_LibInitRngModule+0x40>
    ef98:	6828      	ldr	r0, [r5, #0]
    ef9a:	f7ff fda7 	bl	eaec <CC_PalMutexUnlock>
    ef9e:	2800      	cmp	r0, #0
    efa0:	d0ca      	beq.n	ef38 <CC_LibInitRngModule+0x28>
    efa2:	4805      	ldr	r0, [pc, #20]	; (efb8 <CC_LibInitRngModule+0xa8>)
    efa4:	f7ff ff24 	bl	edf0 <CC_PalAbort>
    efa8:	e7c6      	b.n	ef38 <CC_LibInitRngModule+0x28>
    efaa:	4806      	ldr	r0, [pc, #24]	; (efc4 <CC_LibInitRngModule+0xb4>)
    efac:	f7ff ff20 	bl	edf0 <CC_PalAbort>
    efb0:	e7dc      	b.n	ef6c <CC_LibInitRngModule+0x5c>
    efb2:	bf00      	nop
    efb4:	20001424 	.word	0x20001424
    efb8:	0001086c 	.word	0x0001086c
    efbc:	00010884 	.word	0x00010884
    efc0:	00010854 	.word	0x00010854
    efc4:	000108a4 	.word	0x000108a4

0000efc8 <CC_LibInit>:
    efc8:	b508      	push	{r3, lr}
    efca:	f7ff fdeb 	bl	eba4 <CC_HalInit>
    efce:	b118      	cbz	r0, efd8 <CC_LibInit+0x10>
    efd0:	f7ff fd52 	bl	ea78 <CC_PalTerminate>
    efd4:	2003      	movs	r0, #3
    efd6:	bd08      	pop	{r3, pc}
    efd8:	f7ff fd20 	bl	ea1c <CC_PalInit>
    efdc:	b968      	cbnz	r0, effa <CC_LibInit+0x32>
    efde:	f7ff fdad 	bl	eb3c <CC_PalPowerSaveModeSelect>
    efe2:	b960      	cbnz	r0, effe <CC_LibInit+0x36>
    efe4:	4b15      	ldr	r3, [pc, #84]	; (f03c <CC_LibInit+0x74>)
    efe6:	681b      	ldr	r3, [r3, #0]
    efe8:	0e1b      	lsrs	r3, r3, #24
    efea:	2bf0      	cmp	r3, #240	; 0xf0
    efec:	d012      	beq.n	f014 <CC_LibInit+0x4c>
    efee:	f7ff fddb 	bl	eba8 <CC_HalTerminate>
    eff2:	f7ff fd41 	bl	ea78 <CC_PalTerminate>
    eff6:	2006      	movs	r0, #6
    eff8:	bd08      	pop	{r3, pc}
    effa:	2004      	movs	r0, #4
    effc:	bd08      	pop	{r3, pc}
    effe:	f7ff fdd3 	bl	eba8 <CC_HalTerminate>
    f002:	f7ff fd39 	bl	ea78 <CC_PalTerminate>
    f006:	f7ff ff83 	bl	ef10 <CC_LibInitRngModule>
    f00a:	2800      	cmp	r0, #0
    f00c:	bf0c      	ite	eq
    f00e:	2000      	moveq	r0, #0
    f010:	2005      	movne	r0, #5
    f012:	bd08      	pop	{r3, pc}
    f014:	4a0a      	ldr	r2, [pc, #40]	; (f040 <CC_LibInit+0x78>)
    f016:	4b0b      	ldr	r3, [pc, #44]	; (f044 <CC_LibInit+0x7c>)
    f018:	6812      	ldr	r2, [r2, #0]
    f01a:	429a      	cmp	r2, r3
    f01c:	d005      	beq.n	f02a <CC_LibInit+0x62>
    f01e:	f7ff fdc3 	bl	eba8 <CC_HalTerminate>
    f022:	f7ff fd29 	bl	ea78 <CC_PalTerminate>
    f026:	2007      	movs	r0, #7
    f028:	bd08      	pop	{r3, pc}
    f02a:	2001      	movs	r0, #1
    f02c:	f7ff fd86 	bl	eb3c <CC_PalPowerSaveModeSelect>
    f030:	2800      	cmp	r0, #0
    f032:	d1e4      	bne.n	effe <CC_LibInit+0x36>
    f034:	4b04      	ldr	r3, [pc, #16]	; (f048 <CC_LibInit+0x80>)
    f036:	6018      	str	r0, [r3, #0]
    f038:	e7e5      	b.n	f006 <CC_LibInit+0x3e>
    f03a:	bf00      	nop
    f03c:	50841928 	.word	0x50841928
    f040:	50841a24 	.word	0x50841a24
    f044:	20e00000 	.word	0x20e00000
    f048:	50841a0c 	.word	0x50841a0c

0000f04c <CC_PalTrngParamGet>:
    f04c:	b118      	cbz	r0, f056 <CC_PalTrngParamGet+0xa>
    f04e:	b111      	cbz	r1, f056 <CC_PalTrngParamGet+0xa>
    f050:	680b      	ldr	r3, [r1, #0]
    f052:	2b1c      	cmp	r3, #28
    f054:	d001      	beq.n	f05a <CC_PalTrngParamGet+0xe>
    f056:	2001      	movs	r0, #1
    f058:	4770      	bx	lr
    f05a:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f05e:	4a3a      	ldr	r2, [pc, #232]	; (f148 <CC_PalTrngParamGet+0xfc>)
    f060:	f8d3 1c10 	ldr.w	r1, [r3, #3088]	; 0xc10
    f064:	4291      	cmp	r1, r2
    f066:	d05a      	beq.n	f11e <CC_PalTrngParamGet+0xd2>
    f068:	f8d3 2c10 	ldr.w	r2, [r3, #3088]	; 0xc10
    f06c:	3201      	adds	r2, #1
    f06e:	d056      	beq.n	f11e <CC_PalTrngParamGet+0xd2>
    f070:	f8d3 2c10 	ldr.w	r2, [r3, #3088]	; 0xc10
    f074:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f078:	6002      	str	r2, [r0, #0]
    f07a:	f8d3 1c14 	ldr.w	r1, [r3, #3092]	; 0xc14
    f07e:	4a33      	ldr	r2, [pc, #204]	; (f14c <CC_PalTrngParamGet+0x100>)
    f080:	4291      	cmp	r1, r2
    f082:	d05e      	beq.n	f142 <CC_PalTrngParamGet+0xf6>
    f084:	f8d3 2c14 	ldr.w	r2, [r3, #3092]	; 0xc14
    f088:	3201      	adds	r2, #1
    f08a:	d05a      	beq.n	f142 <CC_PalTrngParamGet+0xf6>
    f08c:	f8d3 2c14 	ldr.w	r2, [r3, #3092]	; 0xc14
    f090:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f094:	6042      	str	r2, [r0, #4]
    f096:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f09a:	f512 7f94 	cmn.w	r2, #296	; 0x128
    f09e:	d04d      	beq.n	f13c <CC_PalTrngParamGet+0xf0>
    f0a0:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f0a4:	3201      	adds	r2, #1
    f0a6:	d049      	beq.n	f13c <CC_PalTrngParamGet+0xf0>
    f0a8:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f0ac:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f0b0:	6082      	str	r2, [r0, #8]
    f0b2:	f8d3 1c1c 	ldr.w	r1, [r3, #3100]	; 0xc1c
    f0b6:	4a26      	ldr	r2, [pc, #152]	; (f150 <CC_PalTrngParamGet+0x104>)
    f0b8:	4291      	cmp	r1, r2
    f0ba:	d03c      	beq.n	f136 <CC_PalTrngParamGet+0xea>
    f0bc:	f8d3 2c1c 	ldr.w	r2, [r3, #3100]	; 0xc1c
    f0c0:	3201      	adds	r2, #1
    f0c2:	d038      	beq.n	f136 <CC_PalTrngParamGet+0xea>
    f0c4:	f8d3 2c1c 	ldr.w	r2, [r3, #3100]	; 0xc1c
    f0c8:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f0cc:	60c2      	str	r2, [r0, #12]
    f0ce:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f0d2:	3270      	adds	r2, #112	; 0x70
    f0d4:	d02d      	beq.n	f132 <CC_PalTrngParamGet+0xe6>
    f0d6:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f0da:	3201      	adds	r2, #1
    f0dc:	d029      	beq.n	f132 <CC_PalTrngParamGet+0xe6>
    f0de:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f0e2:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f0e6:	6102      	str	r2, [r0, #16]
    f0e8:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0ec:	32af      	adds	r2, #175	; 0xaf
    f0ee:	d01e      	beq.n	f12e <CC_PalTrngParamGet+0xe2>
    f0f0:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0f4:	3201      	adds	r2, #1
    f0f6:	d01a      	beq.n	f12e <CC_PalTrngParamGet+0xe2>
    f0f8:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0fc:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f100:	6142      	str	r2, [r0, #20]
    f102:	f8d3 1c08 	ldr.w	r1, [r3, #3080]	; 0xc08
    f106:	4a13      	ldr	r2, [pc, #76]	; (f154 <CC_PalTrngParamGet+0x108>)
    f108:	4291      	cmp	r1, r2
    f10a:	d00b      	beq.n	f124 <CC_PalTrngParamGet+0xd8>
    f10c:	f8d3 2c08 	ldr.w	r2, [r3, #3080]	; 0xc08
    f110:	3201      	adds	r2, #1
    f112:	d007      	beq.n	f124 <CC_PalTrngParamGet+0xd8>
    f114:	f8d3 3c08 	ldr.w	r3, [r3, #3080]	; 0xc08
    f118:	6183      	str	r3, [r0, #24]
    f11a:	2000      	movs	r0, #0
    f11c:	4770      	bx	lr
    f11e:	f640 02fc 	movw	r2, #2300	; 0x8fc
    f122:	e7a7      	b.n	f074 <CC_PalTrngParamGet+0x28>
    f124:	f240 3337 	movw	r3, #823	; 0x337
    f128:	6183      	str	r3, [r0, #24]
    f12a:	2000      	movs	r0, #0
    f12c:	4770      	bx	lr
    f12e:	2251      	movs	r2, #81	; 0x51
    f130:	e7e4      	b.n	f0fc <CC_PalTrngParamGet+0xb0>
    f132:	2290      	movs	r2, #144	; 0x90
    f134:	e7d5      	b.n	f0e2 <CC_PalTrngParamGet+0x96>
    f136:	f642 1204 	movw	r2, #10500	; 0x2904
    f13a:	e7c5      	b.n	f0c8 <CC_PalTrngParamGet+0x7c>
    f13c:	f640 62d8 	movw	r2, #3800	; 0xed8
    f140:	e7b4      	b.n	f0ac <CC_PalTrngParamGet+0x60>
    f142:	f242 02d0 	movw	r2, #8400	; 0x20d0
    f146:	e7a3      	b.n	f090 <CC_PalTrngParamGet+0x44>
    f148:	fffff8fc 	.word	0xfffff8fc
    f14c:	ffff20d0 	.word	0xffff20d0
    f150:	ffff2904 	.word	0xffff2904
    f154:	fffff337 	.word	0xfffff337

0000f158 <LLF_RND_AdaptiveProportionTest>:
    f158:	b3a8      	cbz	r0, f1c6 <LLF_RND_AdaptiveProportionTest+0x6e>
    f15a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f15e:	1e4c      	subs	r4, r1, #1
    f160:	f5b4 7f04 	cmp.w	r4, #528	; 0x210
    f164:	d22c      	bcs.n	f1c0 <LLF_RND_AdaptiveProportionTest+0x68>
    f166:	b35b      	cbz	r3, f1c0 <LLF_RND_AdaptiveProportionTest+0x68>
    f168:	b352      	cbz	r2, f1c0 <LLF_RND_AdaptiveProportionTest+0x68>
    f16a:	f04f 0c00 	mov.w	ip, #0
    f16e:	00c9      	lsls	r1, r1, #3
    f170:	46e6      	mov	lr, ip
    f172:	4665      	mov	r5, ip
    f174:	4664      	mov	r4, ip
    f176:	1e4f      	subs	r7, r1, #1
    f178:	f103 38ff 	add.w	r8, r3, #4294967295
    f17c:	e00c      	b.n	f198 <LLF_RND_AdaptiveProportionTest+0x40>
    f17e:	42ab      	cmp	r3, r5
    f180:	d016      	beq.n	f1b0 <LLF_RND_AdaptiveProportionTest+0x58>
    f182:	458e      	cmp	lr, r1
    f184:	d101      	bne.n	f18a <LLF_RND_AdaptiveProportionTest+0x32>
    f186:	f10c 0c01 	add.w	ip, ip, #1
    f18a:	45a8      	cmp	r8, r5
    f18c:	d016      	beq.n	f1bc <LLF_RND_AdaptiveProportionTest+0x64>
    f18e:	3401      	adds	r4, #1
    f190:	42bc      	cmp	r4, r7
    f192:	f105 0501 	add.w	r5, r5, #1
    f196:	d818      	bhi.n	f1ca <LLF_RND_AdaptiveProportionTest+0x72>
    f198:	0961      	lsrs	r1, r4, #5
    f19a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    f19e:	f004 061f 	and.w	r6, r4, #31
    f1a2:	40f1      	lsrs	r1, r6
    f1a4:	2e1f      	cmp	r6, #31
    f1a6:	bf18      	it	ne
    f1a8:	f001 0101 	andne.w	r1, r1, #1
    f1ac:	2c00      	cmp	r4, #0
    f1ae:	d1e6      	bne.n	f17e <LLF_RND_AdaptiveProportionTest+0x26>
    f1b0:	2500      	movs	r5, #0
    f1b2:	45a8      	cmp	r8, r5
    f1b4:	468e      	mov	lr, r1
    f1b6:	f04f 0c01 	mov.w	ip, #1
    f1ba:	d1e8      	bne.n	f18e <LLF_RND_AdaptiveProportionTest+0x36>
    f1bc:	4562      	cmp	r2, ip
    f1be:	d2e6      	bcs.n	f18e <LLF_RND_AdaptiveProportionTest+0x36>
    f1c0:	4803      	ldr	r0, [pc, #12]	; (f1d0 <LLF_RND_AdaptiveProportionTest+0x78>)
    f1c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f1c6:	4802      	ldr	r0, [pc, #8]	; (f1d0 <LLF_RND_AdaptiveProportionTest+0x78>)
    f1c8:	4770      	bx	lr
    f1ca:	2000      	movs	r0, #0
    f1cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f1d0:	00f10c37 	.word	0x00f10c37

0000f1d4 <getTrngSource>:
    f1d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f1d8:	b08f      	sub	sp, #60	; 0x3c
    f1da:	460d      	mov	r5, r1
    f1dc:	e9dd 4119 	ldrd	r4, r1, [sp, #100]	; 0x64
    f1e0:	4683      	mov	fp, r0
    f1e2:	2900      	cmp	r1, #0
    f1e4:	d157      	bne.n	f296 <getTrngSource+0xc2>
    f1e6:	6929      	ldr	r1, [r5, #16]
    f1e8:	9103      	str	r1, [sp, #12]
    f1ea:	2100      	movs	r1, #0
    f1ec:	601c      	str	r4, [r3, #0]
    f1ee:	9b18      	ldr	r3, [sp, #96]	; 0x60
    f1f0:	6019      	str	r1, [r3, #0]
    f1f2:	2a00      	cmp	r2, #0
    f1f4:	f000 8122 	beq.w	f43c <getTrngSource+0x268>
    f1f8:	4a81      	ldr	r2, [pc, #516]	; (f400 <getTrngSource+0x22c>)
    f1fa:	4b82      	ldr	r3, [pc, #520]	; (f404 <getTrngSource+0x230>)
    f1fc:	6811      	ldr	r1, [r2, #0]
    f1fe:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f200:	681b      	ldr	r3, [r3, #0]
    f202:	429a      	cmp	r2, r3
    f204:	d157      	bne.n	f2b6 <getTrngSource+0xe2>
    f206:	290a      	cmp	r1, #10
    f208:	d155      	bne.n	f2b6 <getTrngSource+0xe2>
    f20a:	f89b 3003 	ldrb.w	r3, [fp, #3]
    f20e:	9306      	str	r3, [sp, #24]
    f210:	9903      	ldr	r1, [sp, #12]
    f212:	2304      	movs	r3, #4
    f214:	4608      	mov	r0, r1
    f216:	4a7c      	ldr	r2, [pc, #496]	; (f408 <getTrngSource+0x234>)
    f218:	9302      	str	r3, [sp, #8]
    f21a:	fba2 0200 	umull	r0, r2, r2, r0
    f21e:	0892      	lsrs	r2, r2, #2
    f220:	00cb      	lsls	r3, r1, #3
    f222:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f226:	f104 0008 	add.w	r0, r4, #8
    f22a:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
    f22e:	3b01      	subs	r3, #1
    f230:	f8df 91d0 	ldr.w	r9, [pc, #464]	; f404 <getTrngSource+0x230>
    f234:	f8df a200 	ldr.w	sl, [pc, #512]	; f438 <getTrngSource+0x264>
    f238:	9004      	str	r0, [sp, #16]
    f23a:	9200      	str	r2, [sp, #0]
    f23c:	9305      	str	r3, [sp, #20]
    f23e:	9b18      	ldr	r3, [sp, #96]	; 0x60
    f240:	9c03      	ldr	r4, [sp, #12]
    f242:	601c      	str	r4, [r3, #0]
    f244:	2c00      	cmp	r4, #0
    f246:	f000 80cc 	beq.w	f3e2 <getTrngSource+0x20e>
    f24a:	2600      	movs	r6, #0
    f24c:	9f04      	ldr	r7, [sp, #16]
    f24e:	f000 faa9 	bl	f7a4 <LLF_RND_TurnOffTrng>
    f252:	2300      	movs	r3, #0
    f254:	9307      	str	r3, [sp, #28]
    f256:	9b06      	ldr	r3, [sp, #24]
    f258:	f1bb 0f00 	cmp.w	fp, #0
    f25c:	d03a      	beq.n	f2d4 <getTrngSource+0x100>
    f25e:	2d00      	cmp	r5, #0
    f260:	d034      	beq.n	f2cc <getTrngSource+0xf8>
    f262:	bb53      	cbnz	r3, f2ba <getTrngSource+0xe6>
    f264:	005b      	lsls	r3, r3, #1
    f266:	9306      	str	r3, [sp, #24]
    f268:	f1bb 0f00 	cmp.w	fp, #0
    f26c:	d036      	beq.n	f2dc <getTrngSource+0x108>
    f26e:	2d00      	cmp	r5, #0
    f270:	d034      	beq.n	f2dc <getTrngSource+0x108>
    f272:	b1e3      	cbz	r3, f2ae <getTrngSource+0xda>
    f274:	a906      	add	r1, sp, #24
    f276:	4628      	mov	r0, r5
    f278:	f000 fa84 	bl	f784 <LLF_RND_GetFastestRosc>
    f27c:	2800      	cmp	r0, #0
    f27e:	f000 817d 	beq.w	f57c <getTrngSource+0x3a8>
    f282:	4b62      	ldr	r3, [pc, #392]	; (f40c <getTrngSource+0x238>)
    f284:	4298      	cmp	r0, r3
    f286:	d012      	beq.n	f2ae <getTrngSource+0xda>
    f288:	9000      	str	r0, [sp, #0]
    f28a:	f000 fa8b 	bl	f7a4 <LLF_RND_TurnOffTrng>
    f28e:	9800      	ldr	r0, [sp, #0]
    f290:	b00f      	add	sp, #60	; 0x3c
    f292:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f296:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
    f29a:	f8d1 0c0c 	ldr.w	r0, [r1, #3084]	; 0xc0c
    f29e:	3001      	adds	r0, #1
    f2a0:	bf0c      	ite	eq
    f2a2:	f44f 7104 	moveq.w	r1, #528	; 0x210
    f2a6:	f8d1 1c0c 	ldrne.w	r1, [r1, #3084]	; 0xc0c
    f2aa:	9103      	str	r1, [sp, #12]
    f2ac:	e79d      	b.n	f1ea <getTrngSource+0x16>
    f2ae:	6a2b      	ldr	r3, [r5, #32]
    f2b0:	b973      	cbnz	r3, f2d0 <getTrngSource+0xfc>
    f2b2:	4856      	ldr	r0, [pc, #344]	; (f40c <getTrngSource+0x238>)
    f2b4:	e7e8      	b.n	f288 <getTrngSource+0xb4>
    f2b6:	4856      	ldr	r0, [pc, #344]	; (f410 <getTrngSource+0x23c>)
    f2b8:	e7e6      	b.n	f288 <getTrngSource+0xb4>
    f2ba:	a906      	add	r1, sp, #24
    f2bc:	4628      	mov	r0, r5
    f2be:	f000 fa61 	bl	f784 <LLF_RND_GetFastestRosc>
    f2c2:	b168      	cbz	r0, f2e0 <getTrngSource+0x10c>
    f2c4:	4b53      	ldr	r3, [pc, #332]	; (f414 <getTrngSource+0x240>)
    f2c6:	4298      	cmp	r0, r3
    f2c8:	d0de      	beq.n	f288 <getTrngSource+0xb4>
    f2ca:	9b06      	ldr	r3, [sp, #24]
    f2cc:	2b08      	cmp	r3, #8
    f2ce:	d1c9      	bne.n	f264 <getTrngSource+0x90>
    f2d0:	4851      	ldr	r0, [pc, #324]	; (f418 <getTrngSource+0x244>)
    f2d2:	e7d9      	b.n	f288 <getTrngSource+0xb4>
    f2d4:	2b08      	cmp	r3, #8
    f2d6:	d0fb      	beq.n	f2d0 <getTrngSource+0xfc>
    f2d8:	005b      	lsls	r3, r3, #1
    f2da:	9306      	str	r3, [sp, #24]
    f2dc:	484f      	ldr	r0, [pc, #316]	; (f41c <getTrngSource+0x248>)
    f2de:	e7d3      	b.n	f288 <getTrngSource+0xb4>
    f2e0:	4629      	mov	r1, r5
    f2e2:	9806      	ldr	r0, [sp, #24]
    f2e4:	f000 fa30 	bl	f748 <LLF_RND_GetRoscSampleCnt>
    f2e8:	2800      	cmp	r0, #0
    f2ea:	d1eb      	bne.n	f2c4 <getTrngSource+0xf0>
    f2ec:	9b06      	ldr	r3, [sp, #24]
    f2ee:	2b08      	cmp	r3, #8
    f2f0:	f000 810e 	beq.w	f510 <getTrngSource+0x33c>
    f2f4:	2b04      	cmp	r3, #4
    f2f6:	f000 8131 	beq.w	f55c <getTrngSource+0x388>
    f2fa:	f1a3 0302 	sub.w	r3, r3, #2
    f2fe:	fab3 f383 	clz	r3, r3
    f302:	095b      	lsrs	r3, r3, #5
    f304:	9301      	str	r3, [sp, #4]
    f306:	2301      	movs	r3, #1
    f308:	4619      	mov	r1, r3
    f30a:	4a45      	ldr	r2, [pc, #276]	; (f420 <getTrngSource+0x24c>)
    f30c:	6013      	str	r3, [r2, #0]
    f30e:	f842 3c84 	str.w	r3, [r2, #-132]
    f312:	4b43      	ldr	r3, [pc, #268]	; (f420 <getTrngSource+0x24c>)
    f314:	6019      	str	r1, [r3, #0]
    f316:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f318:	f8c9 3000 	str.w	r3, [r9]
    f31c:	f8d9 2000 	ldr.w	r2, [r9]
    f320:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f322:	429a      	cmp	r2, r3
    f324:	d1f5      	bne.n	f312 <getTrngSource+0x13e>
    f326:	f04f 0800 	mov.w	r8, #0
    f32a:	f04f 30ff 	mov.w	r0, #4294967295
    f32e:	f8ca 8000 	str.w	r8, [sl]
    f332:	f7ff fc3b 	bl	ebac <CC_HalClearInterruptBit>
    f336:	4a3b      	ldr	r2, [pc, #236]	; (f424 <getTrngSource+0x250>)
    f338:	4b3b      	ldr	r3, [pc, #236]	; (f428 <getTrngSource+0x254>)
    f33a:	4640      	mov	r0, r8
    f33c:	601a      	str	r2, [r3, #0]
    f33e:	f7ff fc43 	bl	ebc8 <CC_HalMaskInterrupt>
    f342:	220a      	movs	r2, #10
    f344:	9801      	ldr	r0, [sp, #4]
    f346:	4939      	ldr	r1, [pc, #228]	; (f42c <getTrngSource+0x258>)
    f348:	4b2d      	ldr	r3, [pc, #180]	; (f400 <getTrngSource+0x22c>)
    f34a:	6008      	str	r0, [r1, #0]
    f34c:	601a      	str	r2, [r3, #0]
    f34e:	692a      	ldr	r2, [r5, #16]
    f350:	f1a8 3855 	sub.w	r8, r8, #1431655765	; 0x55555555
    f354:	fba8 1202 	umull	r1, r2, r8, r2
    f358:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f35a:	0912      	lsrs	r2, r2, #4
    f35c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f360:	03db      	lsls	r3, r3, #15
    f362:	fb03 f302 	mul.w	r3, r3, r2
    f366:	4a32      	ldr	r2, [pc, #200]	; (f430 <getTrngSource+0x25c>)
    f368:	099b      	lsrs	r3, r3, #6
    f36a:	6013      	str	r3, [r2, #0]
    f36c:	2301      	movs	r3, #1
    f36e:	f8ca 3000 	str.w	r3, [sl]
    f372:	9906      	ldr	r1, [sp, #24]
    f374:	f8db 2000 	ldr.w	r2, [fp]
    f378:	020b      	lsls	r3, r1, #8
    f37a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f37e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    f382:	4313      	orrs	r3, r2
    f384:	f8cb 3000 	str.w	r3, [fp]
    f388:	a807      	add	r0, sp, #28
    f38a:	f000 f9cd 	bl	f728 <LLF_RND_WaitRngInterrupt>
    f38e:	2800      	cmp	r0, #0
    f390:	d198      	bne.n	f2c4 <getTrngSource+0xf0>
    f392:	4b28      	ldr	r3, [pc, #160]	; (f434 <getTrngSource+0x260>)
    f394:	fba8 2804 	umull	r2, r8, r8, r4
    f398:	681a      	ldr	r2, [r3, #0]
    f39a:	3314      	adds	r3, #20
    f39c:	9208      	str	r2, [sp, #32]
    f39e:	f853 2c10 	ldr.w	r2, [r3, #-16]
    f3a2:	ebb6 0f98 	cmp.w	r6, r8, lsr #2
    f3a6:	9209      	str	r2, [sp, #36]	; 0x24
    f3a8:	f853 2c0c 	ldr.w	r2, [r3, #-12]
    f3ac:	920a      	str	r2, [sp, #40]	; 0x28
    f3ae:	f853 2c08 	ldr.w	r2, [r3, #-8]
    f3b2:	920b      	str	r2, [sp, #44]	; 0x2c
    f3b4:	f853 2c04 	ldr.w	r2, [r3, #-4]
    f3b8:	920c      	str	r2, [sp, #48]	; 0x30
    f3ba:	681b      	ldr	r3, [r3, #0]
    f3bc:	930d      	str	r3, [sp, #52]	; 0x34
    f3be:	d101      	bne.n	f3c4 <getTrngSource+0x1f0>
    f3c0:	9b00      	ldr	r3, [sp, #0]
    f3c2:	b99b      	cbnz	r3, f3ec <getTrngSource+0x218>
    f3c4:	4638      	mov	r0, r7
    f3c6:	2218      	movs	r2, #24
    f3c8:	a908      	add	r1, sp, #32
    f3ca:	f7ff fb21 	bl	ea10 <CC_PalMemCopyPlat>
    f3ce:	3c18      	subs	r4, #24
    f3d0:	3718      	adds	r7, #24
    f3d2:	3601      	adds	r6, #1
    f3d4:	2c00      	cmp	r4, #0
    f3d6:	f47f af3a 	bne.w	f24e <getTrngSource+0x7a>
    f3da:	9b04      	ldr	r3, [sp, #16]
    f3dc:	2b00      	cmp	r3, #0
    f3de:	f040 809a 	bne.w	f516 <getTrngSource+0x342>
    f3e2:	2300      	movs	r3, #0
    f3e4:	9a18      	ldr	r2, [sp, #96]	; 0x60
    f3e6:	6013      	str	r3, [r2, #0]
    f3e8:	9b06      	ldr	r3, [sp, #24]
    f3ea:	e76f      	b.n	f2cc <getTrngSource+0xf8>
    f3ec:	461a      	mov	r2, r3
    f3ee:	4638      	mov	r0, r7
    f3f0:	a908      	add	r1, sp, #32
    f3f2:	1ae4      	subs	r4, r4, r3
    f3f4:	f7ff fb0c 	bl	ea10 <CC_PalMemCopyPlat>
    f3f8:	9b00      	ldr	r3, [sp, #0]
    f3fa:	441f      	add	r7, r3
    f3fc:	e7e9      	b.n	f3d2 <getTrngSource+0x1fe>
    f3fe:	bf00      	nop
    f400:	50841138 	.word	0x50841138
    f404:	50841130 	.word	0x50841130
    f408:	aaaaaaab 	.word	0xaaaaaaab
    f40c:	00f10c31 	.word	0x00f10c31
    f410:	00f10c30 	.word	0x00f10c30
    f414:	00f10c02 	.word	0x00f10c02
    f418:	00f10c32 	.word	0x00f10c32
    f41c:	00f10c35 	.word	0x00f10c35
    f420:	508411c4 	.word	0x508411c4
    f424:	0ffffffe 	.word	0x0ffffffe
    f428:	50841100 	.word	0x50841100
    f42c:	5084110c 	.word	0x5084110c
    f430:	508411d8 	.word	0x508411d8
    f434:	50841114 	.word	0x50841114
    f438:	5084112c 	.word	0x5084112c
    f43c:	f1bb 0f00 	cmp.w	fp, #0
    f440:	f43f af4c 	beq.w	f2dc <getTrngSource+0x108>
    f444:	2d00      	cmp	r5, #0
    f446:	f43f af49 	beq.w	f2dc <getTrngSource+0x108>
    f44a:	2301      	movs	r3, #1
    f44c:	a90e      	add	r1, sp, #56	; 0x38
    f44e:	f841 3d20 	str.w	r3, [r1, #-32]!
    f452:	f8cb 2000 	str.w	r2, [fp]
    f456:	4628      	mov	r0, r5
    f458:	f000 f994 	bl	f784 <LLF_RND_GetFastestRosc>
    f45c:	2800      	cmp	r0, #0
    f45e:	f47f af13 	bne.w	f288 <getTrngSource+0xb4>
    f462:	4629      	mov	r1, r5
    f464:	9806      	ldr	r0, [sp, #24]
    f466:	f000 f96f 	bl	f748 <LLF_RND_GetRoscSampleCnt>
    f46a:	2800      	cmp	r0, #0
    f46c:	f47f af0c 	bne.w	f288 <getTrngSource+0xb4>
    f470:	9f06      	ldr	r7, [sp, #24]
    f472:	2f08      	cmp	r7, #8
    f474:	f000 80eb 	beq.w	f64e <getTrngSource+0x47a>
    f478:	2f04      	cmp	r7, #4
    f47a:	f000 80ea 	beq.w	f652 <getTrngSource+0x47e>
    f47e:	f1a7 0702 	sub.w	r7, r7, #2
    f482:	fab7 f787 	clz	r7, r7
    f486:	097f      	lsrs	r7, r7, #5
    f488:	2201      	movs	r2, #1
    f48a:	4616      	mov	r6, r2
    f48c:	4b73      	ldr	r3, [pc, #460]	; (f65c <getTrngSource+0x488>)
    f48e:	4974      	ldr	r1, [pc, #464]	; (f660 <getTrngSource+0x48c>)
    f490:	601a      	str	r2, [r3, #0]
    f492:	4618      	mov	r0, r3
    f494:	600a      	str	r2, [r1, #0]
    f496:	3b94      	subs	r3, #148	; 0x94
    f498:	6006      	str	r6, [r0, #0]
    f49a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f49c:	601a      	str	r2, [r3, #0]
    f49e:	6819      	ldr	r1, [r3, #0]
    f4a0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f4a2:	4291      	cmp	r1, r2
    f4a4:	d1f8      	bne.n	f498 <getTrngSource+0x2c4>
    f4a6:	f04f 0800 	mov.w	r8, #0
    f4aa:	4b6e      	ldr	r3, [pc, #440]	; (f664 <getTrngSource+0x490>)
    f4ac:	f04f 30ff 	mov.w	r0, #4294967295
    f4b0:	f8c3 8000 	str.w	r8, [r3]
    f4b4:	f7ff fb7a 	bl	ebac <CC_HalClearInterruptBit>
    f4b8:	4b6b      	ldr	r3, [pc, #428]	; (f668 <getTrngSource+0x494>)
    f4ba:	4a6c      	ldr	r2, [pc, #432]	; (f66c <getTrngSource+0x498>)
    f4bc:	4640      	mov	r0, r8
    f4be:	601a      	str	r2, [r3, #0]
    f4c0:	f7ff fb82 	bl	ebc8 <CC_HalMaskInterrupt>
    f4c4:	220a      	movs	r2, #10
    f4c6:	496a      	ldr	r1, [pc, #424]	; (f670 <getTrngSource+0x49c>)
    f4c8:	4b6a      	ldr	r3, [pc, #424]	; (f674 <getTrngSource+0x4a0>)
    f4ca:	600f      	str	r7, [r1, #0]
    f4cc:	601a      	str	r2, [r3, #0]
    f4ce:	991a      	ldr	r1, [sp, #104]	; 0x68
    f4d0:	692b      	ldr	r3, [r5, #16]
    f4d2:	2901      	cmp	r1, #1
    f4d4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f4d6:	f000 80b1 	beq.w	f63c <getTrngSource+0x468>
    f4da:	4967      	ldr	r1, [pc, #412]	; (f678 <getTrngSource+0x4a4>)
    f4dc:	fba1 1303 	umull	r1, r3, r1, r3
    f4e0:	091b      	lsrs	r3, r3, #4
    f4e2:	2101      	movs	r1, #1
    f4e4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f4e8:	03d2      	lsls	r2, r2, #15
    f4ea:	fb03 f302 	mul.w	r3, r3, r2
    f4ee:	4a63      	ldr	r2, [pc, #396]	; (f67c <getTrngSource+0x4a8>)
    f4f0:	099b      	lsrs	r3, r3, #6
    f4f2:	6013      	str	r3, [r2, #0]
    f4f4:	4b5b      	ldr	r3, [pc, #364]	; (f664 <getTrngSource+0x490>)
    f4f6:	6019      	str	r1, [r3, #0]
    f4f8:	9906      	ldr	r1, [sp, #24]
    f4fa:	f8db 2000 	ldr.w	r2, [fp]
    f4fe:	020b      	lsls	r3, r1, #8
    f500:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f504:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    f508:	4313      	orrs	r3, r2
    f50a:	f8cb 3000 	str.w	r3, [fp]
    f50e:	e67f      	b.n	f210 <getTrngSource+0x3c>
    f510:	2303      	movs	r3, #3
    f512:	9301      	str	r3, [sp, #4]
    f514:	e6f7      	b.n	f306 <getTrngSource+0x132>
    f516:	9b03      	ldr	r3, [sp, #12]
    f518:	f5b3 7f04 	cmp.w	r3, #528	; 0x210
    f51c:	f63f af61 	bhi.w	f3e2 <getTrngSource+0x20e>
    f520:	e9dd 7c04 	ldrd	r7, ip, [sp, #16]
    f524:	4620      	mov	r0, r4
    f526:	4623      	mov	r3, r4
    f528:	696e      	ldr	r6, [r5, #20]
    f52a:	e004      	b.n	f536 <getTrngSource+0x362>
    f52c:	2001      	movs	r0, #1
    f52e:	3301      	adds	r3, #1
    f530:	4563      	cmp	r3, ip
    f532:	4614      	mov	r4, r2
    f534:	d815      	bhi.n	f562 <getTrngSource+0x38e>
    f536:	095a      	lsrs	r2, r3, #5
    f538:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
    f53c:	f003 011f 	and.w	r1, r3, #31
    f540:	40ca      	lsrs	r2, r1
    f542:	291f      	cmp	r1, #31
    f544:	bf18      	it	ne
    f546:	f002 0201 	andne.w	r2, r2, #1
    f54a:	2b00      	cmp	r3, #0
    f54c:	d0ee      	beq.n	f52c <getTrngSource+0x358>
    f54e:	42a2      	cmp	r2, r4
    f550:	d1ec      	bne.n	f52c <getTrngSource+0x358>
    f552:	3001      	adds	r0, #1
    f554:	4286      	cmp	r6, r0
    f556:	d1ea      	bne.n	f52e <getTrngSource+0x35a>
    f558:	4849      	ldr	r0, [pc, #292]	; (f680 <getTrngSource+0x4ac>)
    f55a:	e00b      	b.n	f574 <getTrngSource+0x3a0>
    f55c:	2302      	movs	r3, #2
    f55e:	9301      	str	r3, [sp, #4]
    f560:	e6d1      	b.n	f306 <getTrngSource+0x132>
    f562:	f44f 6380 	mov.w	r3, #1024	; 0x400
    f566:	e9dd 1003 	ldrd	r1, r0, [sp, #12]
    f56a:	69aa      	ldr	r2, [r5, #24]
    f56c:	f7ff fdf4 	bl	f158 <LLF_RND_AdaptiveProportionTest>
    f570:	2800      	cmp	r0, #0
    f572:	d05d      	beq.n	f630 <getTrngSource+0x45c>
    f574:	2300      	movs	r3, #0
    f576:	9a18      	ldr	r2, [sp, #96]	; 0x60
    f578:	6013      	str	r3, [r2, #0]
    f57a:	e6a3      	b.n	f2c4 <getTrngSource+0xf0>
    f57c:	4629      	mov	r1, r5
    f57e:	9806      	ldr	r0, [sp, #24]
    f580:	f000 f8e2 	bl	f748 <LLF_RND_GetRoscSampleCnt>
    f584:	2800      	cmp	r0, #0
    f586:	f47f ae7c 	bne.w	f282 <getTrngSource+0xae>
    f58a:	9c06      	ldr	r4, [sp, #24]
    f58c:	2c08      	cmp	r4, #8
    f58e:	d051      	beq.n	f634 <getTrngSource+0x460>
    f590:	2c04      	cmp	r4, #4
    f592:	d051      	beq.n	f638 <getTrngSource+0x464>
    f594:	f1a4 0402 	sub.w	r4, r4, #2
    f598:	fab4 f484 	clz	r4, r4
    f59c:	0964      	lsrs	r4, r4, #5
    f59e:	2301      	movs	r3, #1
    f5a0:	461e      	mov	r6, r3
    f5a2:	4619      	mov	r1, r3
    f5a4:	4a2d      	ldr	r2, [pc, #180]	; (f65c <getTrngSource+0x488>)
    f5a6:	6013      	str	r3, [r2, #0]
    f5a8:	f842 3c84 	str.w	r3, [r2, #-132]
    f5ac:	4b2b      	ldr	r3, [pc, #172]	; (f65c <getTrngSource+0x488>)
    f5ae:	6019      	str	r1, [r3, #0]
    f5b0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f5b2:	f8c9 3000 	str.w	r3, [r9]
    f5b6:	f8d9 2000 	ldr.w	r2, [r9]
    f5ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f5bc:	429a      	cmp	r2, r3
    f5be:	d1f5      	bne.n	f5ac <getTrngSource+0x3d8>
    f5c0:	2700      	movs	r7, #0
    f5c2:	f04f 30ff 	mov.w	r0, #4294967295
    f5c6:	f8ca 7000 	str.w	r7, [sl]
    f5ca:	f7ff faef 	bl	ebac <CC_HalClearInterruptBit>
    f5ce:	4b26      	ldr	r3, [pc, #152]	; (f668 <getTrngSource+0x494>)
    f5d0:	4a26      	ldr	r2, [pc, #152]	; (f66c <getTrngSource+0x498>)
    f5d2:	4638      	mov	r0, r7
    f5d4:	601a      	str	r2, [r3, #0]
    f5d6:	f7ff faf7 	bl	ebc8 <CC_HalMaskInterrupt>
    f5da:	220a      	movs	r2, #10
    f5dc:	4924      	ldr	r1, [pc, #144]	; (f670 <getTrngSource+0x49c>)
    f5de:	4b25      	ldr	r3, [pc, #148]	; (f674 <getTrngSource+0x4a0>)
    f5e0:	600c      	str	r4, [r1, #0]
    f5e2:	601a      	str	r2, [r3, #0]
    f5e4:	692a      	ldr	r2, [r5, #16]
    f5e6:	4924      	ldr	r1, [pc, #144]	; (f678 <getTrngSource+0x4a4>)
    f5e8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f5ea:	fba1 1202 	umull	r1, r2, r1, r2
    f5ee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f5f2:	0912      	lsrs	r2, r2, #4
    f5f4:	03db      	lsls	r3, r3, #15
    f5f6:	fb03 f302 	mul.w	r3, r3, r2
    f5fa:	4a20      	ldr	r2, [pc, #128]	; (f67c <getTrngSource+0x4a8>)
    f5fc:	099b      	lsrs	r3, r3, #6
    f5fe:	6013      	str	r3, [r2, #0]
    f600:	f8ca 6000 	str.w	r6, [sl]
    f604:	9b06      	ldr	r3, [sp, #24]
    f606:	f8db 1000 	ldr.w	r1, [fp]
    f60a:	021a      	lsls	r2, r3, #8
    f60c:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
    f610:	f021 427f 	bic.w	r2, r1, #4278190080	; 0xff000000
    f614:	431a      	orrs	r2, r3
    f616:	0a13      	lsrs	r3, r2, #8
    f618:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    f61c:	4313      	orrs	r3, r2
    f61e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    f622:	f8cb 3000 	str.w	r3, [fp]
    f626:	9b02      	ldr	r3, [sp, #8]
    f628:	3b01      	subs	r3, #1
    f62a:	9302      	str	r3, [sp, #8]
    f62c:	f47f ae07 	bne.w	f23e <getTrngSource+0x6a>
    f630:	2000      	movs	r0, #0
    f632:	e629      	b.n	f288 <getTrngSource+0xb4>
    f634:	2403      	movs	r4, #3
    f636:	e7b2      	b.n	f59e <getTrngSource+0x3ca>
    f638:	2402      	movs	r4, #2
    f63a:	e7b0      	b.n	f59e <getTrngSource+0x3ca>
    f63c:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f640:	f8d3 1c0c 	ldr.w	r1, [r3, #3084]	; 0xc0c
    f644:	3101      	adds	r1, #1
    f646:	d006      	beq.n	f656 <getTrngSource+0x482>
    f648:	f8d3 3c0c 	ldr.w	r3, [r3, #3084]	; 0xc0c
    f64c:	e745      	b.n	f4da <getTrngSource+0x306>
    f64e:	2703      	movs	r7, #3
    f650:	e71a      	b.n	f488 <getTrngSource+0x2b4>
    f652:	2702      	movs	r7, #2
    f654:	e718      	b.n	f488 <getTrngSource+0x2b4>
    f656:	2316      	movs	r3, #22
    f658:	e743      	b.n	f4e2 <getTrngSource+0x30e>
    f65a:	bf00      	nop
    f65c:	508411c4 	.word	0x508411c4
    f660:	50841140 	.word	0x50841140
    f664:	5084112c 	.word	0x5084112c
    f668:	50841100 	.word	0x50841100
    f66c:	0ffffffe 	.word	0x0ffffffe
    f670:	5084110c 	.word	0x5084110c
    f674:	50841138 	.word	0x50841138
    f678:	aaaaaaab 	.word	0xaaaaaaab
    f67c:	508411d8 	.word	0x508411d8
    f680:	00f10c36 	.word	0x00f10c36

0000f684 <LLF_RND_GetTrngSource>:
    f684:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f688:	4c1b      	ldr	r4, [pc, #108]	; (f6f8 <LLF_RND_GetTrngSource+0x74>)
    f68a:	b085      	sub	sp, #20
    f68c:	4607      	mov	r7, r0
    f68e:	e9dd 560d 	ldrd	r5, r6, [sp, #52]	; 0x34
    f692:	4688      	mov	r8, r1
    f694:	6820      	ldr	r0, [r4, #0]
    f696:	f04f 31ff 	mov.w	r1, #4294967295
    f69a:	4691      	mov	r9, r2
    f69c:	f7ff fa1e 	bl	eadc <CC_PalMutexLock>
    f6a0:	bb28      	cbnz	r0, f6ee <LLF_RND_GetTrngSource+0x6a>
    f6a2:	2000      	movs	r0, #0
    f6a4:	f7ff fa4a 	bl	eb3c <CC_PalPowerSaveModeSelect>
    f6a8:	b9e8      	cbnz	r0, f6e6 <LLF_RND_GetTrngSource+0x62>
    f6aa:	2300      	movs	r3, #0
    f6ac:	e9cd 5600 	strd	r5, r6, [sp]
    f6b0:	9302      	str	r3, [sp, #8]
    f6b2:	464a      	mov	r2, r9
    f6b4:	4641      	mov	r1, r8
    f6b6:	4638      	mov	r0, r7
    f6b8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f6ba:	f7ff fd8b 	bl	f1d4 <getTrngSource>
    f6be:	4605      	mov	r5, r0
    f6c0:	2001      	movs	r0, #1
    f6c2:	f7ff fa3b 	bl	eb3c <CC_PalPowerSaveModeSelect>
    f6c6:	b950      	cbnz	r0, f6de <LLF_RND_GetTrngSource+0x5a>
    f6c8:	6820      	ldr	r0, [r4, #0]
    f6ca:	f7ff fa0f 	bl	eaec <CC_PalMutexUnlock>
    f6ce:	b110      	cbz	r0, f6d6 <LLF_RND_GetTrngSource+0x52>
    f6d0:	480a      	ldr	r0, [pc, #40]	; (f6fc <LLF_RND_GetTrngSource+0x78>)
    f6d2:	f7ff fb8d 	bl	edf0 <CC_PalAbort>
    f6d6:	4628      	mov	r0, r5
    f6d8:	b005      	add	sp, #20
    f6da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f6de:	4808      	ldr	r0, [pc, #32]	; (f700 <LLF_RND_GetTrngSource+0x7c>)
    f6e0:	f7ff fb86 	bl	edf0 <CC_PalAbort>
    f6e4:	e7f0      	b.n	f6c8 <LLF_RND_GetTrngSource+0x44>
    f6e6:	4807      	ldr	r0, [pc, #28]	; (f704 <LLF_RND_GetTrngSource+0x80>)
    f6e8:	f7ff fb82 	bl	edf0 <CC_PalAbort>
    f6ec:	e7dd      	b.n	f6aa <LLF_RND_GetTrngSource+0x26>
    f6ee:	4806      	ldr	r0, [pc, #24]	; (f708 <LLF_RND_GetTrngSource+0x84>)
    f6f0:	f7ff fb7e 	bl	edf0 <CC_PalAbort>
    f6f4:	e7d5      	b.n	f6a2 <LLF_RND_GetTrngSource+0x1e>
    f6f6:	bf00      	nop
    f6f8:	20001424 	.word	0x20001424
    f6fc:	0001086c 	.word	0x0001086c
    f700:	000108a4 	.word	0x000108a4
    f704:	00010884 	.word	0x00010884
    f708:	00010854 	.word	0x00010854

0000f70c <LLF_RND_RunTrngStartupTest>:
    f70c:	b510      	push	{r4, lr}
    f70e:	2401      	movs	r4, #1
    f710:	b086      	sub	sp, #24
    f712:	ab05      	add	r3, sp, #20
    f714:	e9cd 2401 	strd	r2, r4, [sp, #4]
    f718:	9300      	str	r3, [sp, #0]
    f71a:	2200      	movs	r2, #0
    f71c:	ab04      	add	r3, sp, #16
    f71e:	f7ff fd59 	bl	f1d4 <getTrngSource>
    f722:	b006      	add	sp, #24
    f724:	bd10      	pop	{r4, pc}
    f726:	bf00      	nop

0000f728 <LLF_RND_WaitRngInterrupt>:
    f728:	b508      	push	{r3, lr}
    f72a:	4601      	mov	r1, r0
    f72c:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f730:	f7ff fa50 	bl	ebd4 <CC_HalWaitInterruptRND>
    f734:	2300      	movs	r3, #0
    f736:	4902      	ldr	r1, [pc, #8]	; (f740 <LLF_RND_WaitRngInterrupt+0x18>)
    f738:	4a02      	ldr	r2, [pc, #8]	; (f744 <LLF_RND_WaitRngInterrupt+0x1c>)
    f73a:	600b      	str	r3, [r1, #0]
    f73c:	6013      	str	r3, [r2, #0]
    f73e:	bd08      	pop	{r3, pc}
    f740:	508411c8 	.word	0x508411c8
    f744:	5084112c 	.word	0x5084112c

0000f748 <LLF_RND_GetRoscSampleCnt>:
    f748:	3801      	subs	r0, #1
    f74a:	2807      	cmp	r0, #7
    f74c:	d815      	bhi.n	f77a <LLF_RND_GetRoscSampleCnt+0x32>
    f74e:	e8df f000 	tbb	[pc, r0]
    f752:	0c10      	.short	0x0c10
    f754:	14140814 	.word	0x14140814
    f758:	0414      	.short	0x0414
    f75a:	68cb      	ldr	r3, [r1, #12]
    f75c:	2000      	movs	r0, #0
    f75e:	624b      	str	r3, [r1, #36]	; 0x24
    f760:	4770      	bx	lr
    f762:	688b      	ldr	r3, [r1, #8]
    f764:	2000      	movs	r0, #0
    f766:	624b      	str	r3, [r1, #36]	; 0x24
    f768:	4770      	bx	lr
    f76a:	684b      	ldr	r3, [r1, #4]
    f76c:	2000      	movs	r0, #0
    f76e:	624b      	str	r3, [r1, #36]	; 0x24
    f770:	4770      	bx	lr
    f772:	680b      	ldr	r3, [r1, #0]
    f774:	2000      	movs	r0, #0
    f776:	624b      	str	r3, [r1, #36]	; 0x24
    f778:	4770      	bx	lr
    f77a:	4801      	ldr	r0, [pc, #4]	; (f780 <LLF_RND_GetRoscSampleCnt+0x38>)
    f77c:	4770      	bx	lr
    f77e:	bf00      	nop
    f780:	00f10c31 	.word	0x00f10c31

0000f784 <LLF_RND_GetFastestRosc>:
    f784:	680b      	ldr	r3, [r1, #0]
    f786:	e002      	b.n	f78e <LLF_RND_GetFastestRosc+0xa>
    f788:	2b08      	cmp	r3, #8
    f78a:	600b      	str	r3, [r1, #0]
    f78c:	d806      	bhi.n	f79c <LLF_RND_GetFastestRosc+0x18>
    f78e:	6a02      	ldr	r2, [r0, #32]
    f790:	4213      	tst	r3, r2
    f792:	ea4f 0343 	mov.w	r3, r3, lsl #1
    f796:	d0f7      	beq.n	f788 <LLF_RND_GetFastestRosc+0x4>
    f798:	2000      	movs	r0, #0
    f79a:	4770      	bx	lr
    f79c:	4800      	ldr	r0, [pc, #0]	; (f7a0 <LLF_RND_GetFastestRosc+0x1c>)
    f79e:	4770      	bx	lr
    f7a0:	00f10c31 	.word	0x00f10c31

0000f7a4 <LLF_RND_TurnOffTrng>:
    f7a4:	2300      	movs	r3, #0
    f7a6:	4904      	ldr	r1, [pc, #16]	; (f7b8 <LLF_RND_TurnOffTrng+0x14>)
    f7a8:	4a04      	ldr	r2, [pc, #16]	; (f7bc <LLF_RND_TurnOffTrng+0x18>)
    f7aa:	600b      	str	r3, [r1, #0]
    f7ac:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f7b0:	6013      	str	r3, [r2, #0]
    f7b2:	f7ff b9fb 	b.w	ebac <CC_HalClearInterruptBit>
    f7b6:	bf00      	nop
    f7b8:	5084112c 	.word	0x5084112c
    f7bc:	508411c4 	.word	0x508411c4

0000f7c0 <main>:
 *  0 kB  |---------------------|
 */


void main(void)
{
    f7c0:	b508      	push	{r3, lr}
	spm_config();
    f7c2:	f7fd facb 	bl	cd5c <spm_config>
	spm_jump();
}
    f7c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	spm_jump();
    f7ca:	f7fd ba59 	b.w	cc80 <spm_jump>

0000f7ce <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
    f7ce:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
    f7d2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    f7d6:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
    f7d8:	bf08      	it	eq
    f7da:	f06f 0015 	mvneq.w	r0, #21
    f7de:	4770      	bx	lr

0000f7e0 <z_sys_mem_pool_base_init>:
{
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;
    f7e0:	23ff      	movs	r3, #255	; 0xff
{
    f7e2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7e6:	6845      	ldr	r5, [r0, #4]

	for (i = 0; i < p->n_levels; i++) {
    f7e8:	2200      	movs	r2, #0
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7ea:	4629      	mov	r1, r5
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
    f7ec:	f04f 0a0c 	mov.w	sl, #12

		if (nblocks <= sizeof(p->levels[i].bits)*8) {
			p->max_inline_level = i;
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
    f7f0:	f04f 0b20 	mov.w	fp, #32
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7f4:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    f7f6:	6804      	ldr	r4, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7f8:	fb05 fc07 	mul.w	ip, r5, r7
	p->max_inline_level = -1;
    f7fc:	72c3      	strb	r3, [r0, #11]
	for (i = 0; i < p->n_levels; i++) {
    f7fe:	7a83      	ldrb	r3, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    f800:	4464      	add	r4, ip
	for (i = 0; i < p->n_levels; i++) {
    f802:	9301      	str	r3, [sp, #4]
    f804:	9b01      	ldr	r3, [sp, #4]
    f806:	4293      	cmp	r3, r2
    f808:	dc08      	bgt.n	f81c <z_sys_mem_pool_base_init+0x3c>
    f80a:	2300      	movs	r3, #0
		}

		sz = WB_DN(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
    f80c:	4619      	mov	r1, r3
    f80e:	428f      	cmp	r7, r1
    f810:	eb05 0c03 	add.w	ip, r5, r3
    f814:	dc21      	bgt.n	f85a <z_sys_mem_pool_base_init+0x7a>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
	}
}
    f816:	b003      	add	sp, #12
    f818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
    f81c:	fbbc f3f1 	udiv	r3, ip, r1
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    f820:	2b20      	cmp	r3, #32
			bits += (nblocks + 31)/32;
    f822:	bf84      	itt	hi
    f824:	331f      	addhi	r3, #31
    f826:	fb93 f3fb 	sdivhi	r3, r3, fp
		sys_dlist_init(&p->levels[i].free_list);
    f82a:	fb0a fe02 	mul.w	lr, sl, r2
    f82e:	f8d0 800c 	ldr.w	r8, [r0, #12]
		sz = WB_DN(sz / 4);
    f832:	ea4f 0191 	mov.w	r1, r1, lsr #2
		sys_dlist_init(&p->levels[i].free_list);
    f836:	eb08 060e 	add.w	r6, r8, lr
    f83a:	f106 0904 	add.w	r9, r6, #4
    f83e:	e9c6 9901 	strd	r9, r9, [r6, #4]
		sz = WB_DN(sz / 4);
    f842:	f021 0103 	bic.w	r1, r1, #3
			p->max_inline_level = i;
    f846:	bf94      	ite	ls
    f848:	72c2      	strbls	r2, [r0, #11]
			p->levels[i].bits_p = bits;
    f84a:	f848 400e 	strhi.w	r4, [r8, lr]
	for (i = 0; i < p->n_levels; i++) {
    f84e:	f102 0201 	add.w	r2, r2, #1
			bits += (nblocks + 31)/32;
    f852:	bf88      	it	hi
    f854:	eb04 0483 	addhi.w	r4, r4, r3, lsl #2
    f858:	e7d4      	b.n	f804 <z_sys_mem_pool_base_init+0x24>
		sys_dlist_append(&p->levels[0].free_list, block);
    f85a:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
    f85c:	6806      	ldr	r6, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
    f85e:	f102 0e04 	add.w	lr, r2, #4
	return (u8_t *)p->buf + lsz * block;
    f862:	18f4      	adds	r4, r6, r3
	node->next = list;
    f864:	f846 e003 	str.w	lr, [r6, r3]
	node->prev = list->tail;
    f868:	6893      	ldr	r3, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
    f86a:	3101      	adds	r1, #1
    f86c:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    f86e:	6893      	ldr	r3, [r2, #8]
    f870:	601c      	str	r4, [r3, #0]
	list->tail = node;
    f872:	6094      	str	r4, [r2, #8]
    f874:	4663      	mov	r3, ip
    f876:	e7ca      	b.n	f80e <z_sys_mem_pool_base_init+0x2e>

0000f878 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    f878:	4604      	mov	r4, r0
    f87a:	b508      	push	{r3, lr}
    f87c:	4608      	mov	r0, r1
    f87e:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    f880:	461a      	mov	r2, r3
    f882:	47a0      	blx	r4
	return z_impl_k_current_get();
    f884:	f7fe ff3c 	bl	e700 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    f888:	f7fd ff32 	bl	d6f0 <z_impl_k_thread_abort>

0000f88c <z_arch_printk_char_out>:
}
    f88c:	2000      	movs	r0, #0
    f88e:	4770      	bx	lr

0000f890 <print_err>:
{
    f890:	b570      	push	{r4, r5, r6, lr}
    f892:	460d      	mov	r5, r1
    f894:	4604      	mov	r4, r0
	out('E', ctx);
    f896:	2045      	movs	r0, #69	; 0x45
    f898:	47a0      	blx	r4
	out('R', ctx);
    f89a:	4629      	mov	r1, r5
    f89c:	2052      	movs	r0, #82	; 0x52
    f89e:	47a0      	blx	r4
	out('R', ctx);
    f8a0:	4629      	mov	r1, r5
    f8a2:	4623      	mov	r3, r4
}
    f8a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
    f8a8:	2052      	movs	r0, #82	; 0x52
    f8aa:	4718      	bx	r3

0000f8ac <z_vprintk>:
{
    f8ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
    f8b0:	2700      	movs	r7, #0
{
    f8b2:	4605      	mov	r5, r0
    f8b4:	460e      	mov	r6, r1
    f8b6:	4692      	mov	sl, r2
    f8b8:	461c      	mov	r4, r3
	int min_width = -1;
    f8ba:	f04f 39ff 	mov.w	r9, #4294967295
	enum pad_type padding = PAD_NONE;
    f8be:	46b8      	mov	r8, r7
	int might_format = 0; /* 1 if encountered a '%' */
    f8c0:	46bb      	mov	fp, r7
{
    f8c2:	b089      	sub	sp, #36	; 0x24
	while (*fmt) {
    f8c4:	f89a 0000 	ldrb.w	r0, [sl]
    f8c8:	b910      	cbnz	r0, f8d0 <z_vprintk+0x24>
}
    f8ca:	b009      	add	sp, #36	; 0x24
    f8cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
    f8d0:	f1bb 0f00 	cmp.w	fp, #0
    f8d4:	d107      	bne.n	f8e6 <z_vprintk+0x3a>
			if (*fmt != '%') {
    f8d6:	2825      	cmp	r0, #37	; 0x25
    f8d8:	f000 814e 	beq.w	fb78 <z_vprintk+0x2cc>
				out((int)*fmt, ctx);
    f8dc:	4631      	mov	r1, r6
    f8de:	47a8      	blx	r5
		++fmt;
    f8e0:	f10a 0a01 	add.w	sl, sl, #1
    f8e4:	e7ee      	b.n	f8c4 <z_vprintk+0x18>
			switch (*fmt) {
    f8e6:	2864      	cmp	r0, #100	; 0x64
    f8e8:	d068      	beq.n	f9bc <z_vprintk+0x110>
    f8ea:	d81a      	bhi.n	f922 <z_vprintk+0x76>
    f8ec:	2839      	cmp	r0, #57	; 0x39
    f8ee:	d80b      	bhi.n	f908 <z_vprintk+0x5c>
    f8f0:	2831      	cmp	r0, #49	; 0x31
    f8f2:	d25a      	bcs.n	f9aa <z_vprintk+0xfe>
    f8f4:	282d      	cmp	r0, #45	; 0x2d
    f8f6:	f000 8146 	beq.w	fb86 <z_vprintk+0x2da>
    f8fa:	2830      	cmp	r0, #48	; 0x30
    f8fc:	d046      	beq.n	f98c <z_vprintk+0xe0>
    f8fe:	2825      	cmp	r0, #37	; 0x25
    f900:	d108      	bne.n	f914 <z_vprintk+0x68>
				out((int)'%', ctx);
    f902:	4631      	mov	r1, r6
				out((int)*fmt, ctx);
    f904:	47a8      	blx	r5
    f906:	e07a      	b.n	f9fe <z_vprintk+0x152>
			switch (*fmt) {
    f908:	2858      	cmp	r0, #88	; 0x58
    f90a:	f000 80b4 	beq.w	fa76 <z_vprintk+0x1ca>
    f90e:	2863      	cmp	r0, #99	; 0x63
    f910:	f000 812c 	beq.w	fb6c <z_vprintk+0x2c0>
				out((int)'%', ctx);
    f914:	4631      	mov	r1, r6
    f916:	2025      	movs	r0, #37	; 0x25
    f918:	47a8      	blx	r5
				out((int)*fmt, ctx);
    f91a:	4631      	mov	r1, r6
    f91c:	f89a 0000 	ldrb.w	r0, [sl]
    f920:	e7f0      	b.n	f904 <z_vprintk+0x58>
			switch (*fmt) {
    f922:	2870      	cmp	r0, #112	; 0x70
    f924:	f000 809d 	beq.w	fa62 <z_vprintk+0x1b6>
    f928:	d80d      	bhi.n	f946 <z_vprintk+0x9a>
    f92a:	2869      	cmp	r0, #105	; 0x69
    f92c:	d046      	beq.n	f9bc <z_vprintk+0x110>
    f92e:	286c      	cmp	r0, #108	; 0x6c
    f930:	d103      	bne.n	f93a <z_vprintk+0x8e>
				} else if (*fmt == 'l' && length_mod == 'l') {
    f932:	2f6c      	cmp	r7, #108	; 0x6c
    f934:	d126      	bne.n	f984 <z_vprintk+0xd8>
					length_mod = 'L';
    f936:	274c      	movs	r7, #76	; 0x4c
    f938:	e7d2      	b.n	f8e0 <z_vprintk+0x34>
			switch (*fmt) {
    f93a:	2868      	cmp	r0, #104	; 0x68
    f93c:	d1ea      	bne.n	f914 <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
    f93e:	2f68      	cmp	r7, #104	; 0x68
    f940:	d120      	bne.n	f984 <z_vprintk+0xd8>
					length_mod = 'H';
    f942:	2748      	movs	r7, #72	; 0x48
    f944:	e7cc      	b.n	f8e0 <z_vprintk+0x34>
			switch (*fmt) {
    f946:	2875      	cmp	r0, #117	; 0x75
    f948:	d070      	beq.n	fa2c <z_vprintk+0x180>
    f94a:	d817      	bhi.n	f97c <z_vprintk+0xd0>
    f94c:	2873      	cmp	r0, #115	; 0x73
    f94e:	d1e1      	bne.n	f914 <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
    f950:	6822      	ldr	r2, [r4, #0]
    f952:	f104 0b04 	add.w	fp, r4, #4
    f956:	4611      	mov	r1, r2
				while (*s) {
    f958:	460c      	mov	r4, r1
    f95a:	f814 0b01 	ldrb.w	r0, [r4], #1
    f95e:	2800      	cmp	r0, #0
    f960:	f040 80f9 	bne.w	fb56 <z_vprintk+0x2aa>
				if (padding == PAD_SPACE_AFTER) {
    f964:	f1b8 0f03 	cmp.w	r8, #3
    f968:	f040 8113 	bne.w	fb92 <z_vprintk+0x2e6>
					int remaining = min_width - (s - start);
    f96c:	1a8c      	subs	r4, r1, r2
    f96e:	eba9 0404 	sub.w	r4, r9, r4
					while (remaining-- > 0) {
    f972:	2c00      	cmp	r4, #0
    f974:	f300 80f5 	bgt.w	fb62 <z_vprintk+0x2b6>
				int c = va_arg(ap, int);
    f978:	465c      	mov	r4, fp
    f97a:	e040      	b.n	f9fe <z_vprintk+0x152>
			switch (*fmt) {
    f97c:	2878      	cmp	r0, #120	; 0x78
    f97e:	d07a      	beq.n	fa76 <z_vprintk+0x1ca>
    f980:	287a      	cmp	r0, #122	; 0x7a
    f982:	d1c7      	bne.n	f914 <z_vprintk+0x68>
				} else if (length_mod == 0) {
    f984:	2f00      	cmp	r7, #0
    f986:	d1c5      	bne.n	f914 <z_vprintk+0x68>
    f988:	4607      	mov	r7, r0
    f98a:	e7a9      	b.n	f8e0 <z_vprintk+0x34>
				if (min_width < 0 && padding == PAD_NONE) {
    f98c:	f1b9 0f00 	cmp.w	r9, #0
    f990:	da0e      	bge.n	f9b0 <z_vprintk+0x104>
    f992:	f1b8 0f00 	cmp.w	r8, #0
    f996:	f000 80f9 	beq.w	fb8c <z_vprintk+0x2e0>
					min_width = *fmt - '0';
    f99a:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    f99e:	f1b8 0f00 	cmp.w	r8, #0
    f9a2:	bf08      	it	eq
    f9a4:	f04f 0802 	moveq.w	r8, #2
    f9a8:	e79a      	b.n	f8e0 <z_vprintk+0x34>
				if (min_width < 0) {
    f9aa:	f1b9 0f00 	cmp.w	r9, #0
    f9ae:	dbf4      	blt.n	f99a <z_vprintk+0xee>
					min_width = 10 * min_width + *fmt - '0';
    f9b0:	220a      	movs	r2, #10
    f9b2:	fb02 0909 	mla	r9, r2, r9, r0
    f9b6:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
    f9ba:	e7f0      	b.n	f99e <z_vprintk+0xf2>
				if (length_mod == 'z') {
    f9bc:	2f7a      	cmp	r7, #122	; 0x7a
    f9be:	d103      	bne.n	f9c8 <z_vprintk+0x11c>
					d = va_arg(ap, int);
    f9c0:	f8d4 b000 	ldr.w	fp, [r4]
    f9c4:	3404      	adds	r4, #4
    f9c6:	e01e      	b.n	fa06 <z_vprintk+0x15a>
				} else if (length_mod == 'l') {
    f9c8:	2f6c      	cmp	r7, #108	; 0x6c
    f9ca:	d0f9      	beq.n	f9c0 <z_vprintk+0x114>
				} else if (length_mod == 'L') {
    f9cc:	2f4c      	cmp	r7, #76	; 0x4c
    f9ce:	d1f7      	bne.n	f9c0 <z_vprintk+0x114>
					if (lld > __LONG_MAX__ ||
    f9d0:	f04f 0c00 	mov.w	ip, #0
    f9d4:	f04f 3bff 	mov.w	fp, #4294967295
					long long lld = va_arg(ap, long long);
    f9d8:	3407      	adds	r4, #7
    f9da:	f024 0307 	bic.w	r3, r4, #7
    f9de:	f103 0408 	add.w	r4, r3, #8
    f9e2:	e9d3 2300 	ldrd	r2, r3, [r3]
					if (lld > __LONG_MAX__ ||
    f9e6:	f112 4000 	adds.w	r0, r2, #2147483648	; 0x80000000
    f9ea:	f143 0100 	adc.w	r1, r3, #0
    f9ee:	458c      	cmp	ip, r1
    f9f0:	bf08      	it	eq
    f9f2:	4583      	cmpeq	fp, r0
    f9f4:	d206      	bcs.n	fa04 <z_vprintk+0x158>
						print_err(out, ctx);
    f9f6:	4631      	mov	r1, r6
    f9f8:	4628      	mov	r0, r5
    f9fa:	f7ff ff49 	bl	f890 <print_err>
			might_format = 0;
    f9fe:	f04f 0b00 	mov.w	fp, #0
				break;
    fa02:	e76d      	b.n	f8e0 <z_vprintk+0x34>
					d = lld;
    fa04:	4693      	mov	fp, r2
				if (d < 0) {
    fa06:	f1bb 0f00 	cmp.w	fp, #0
    fa0a:	da06      	bge.n	fa1a <z_vprintk+0x16e>
					out((int)'-', ctx);
    fa0c:	4631      	mov	r1, r6
    fa0e:	202d      	movs	r0, #45	; 0x2d
    fa10:	47a8      	blx	r5
					d = -d;
    fa12:	f1cb 0b00 	rsb	fp, fp, #0
					min_width--;
    fa16:	f109 39ff 	add.w	r9, r9, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
    fa1a:	4643      	mov	r3, r8
    fa1c:	465a      	mov	r2, fp
    fa1e:	f8cd 9000 	str.w	r9, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
    fa22:	4631      	mov	r1, r6
    fa24:	4628      	mov	r0, r5
    fa26:	f7fc ff69 	bl	c8fc <_printk_dec_ulong>
    fa2a:	e7e8      	b.n	f9fe <z_vprintk+0x152>
				if (length_mod == 'z') {
    fa2c:	2f7a      	cmp	r7, #122	; 0x7a
    fa2e:	d102      	bne.n	fa36 <z_vprintk+0x18a>
					u = va_arg(ap, unsigned int);
    fa30:	6822      	ldr	r2, [r4, #0]
    fa32:	3404      	adds	r4, #4
    fa34:	e011      	b.n	fa5a <z_vprintk+0x1ae>
				} else if (length_mod == 'l') {
    fa36:	2f6c      	cmp	r7, #108	; 0x6c
    fa38:	d0fa      	beq.n	fa30 <z_vprintk+0x184>
				} else if (length_mod == 'L') {
    fa3a:	2f4c      	cmp	r7, #76	; 0x4c
    fa3c:	d1f8      	bne.n	fa30 <z_vprintk+0x184>
					if (llu > ~0UL) {
    fa3e:	2100      	movs	r1, #0
    fa40:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
    fa44:	3407      	adds	r4, #7
    fa46:	f024 0307 	bic.w	r3, r4, #7
    fa4a:	f103 0408 	add.w	r4, r3, #8
    fa4e:	e9d3 2300 	ldrd	r2, r3, [r3]
					if (llu > ~0UL) {
    fa52:	4299      	cmp	r1, r3
    fa54:	bf08      	it	eq
    fa56:	4290      	cmpeq	r0, r2
    fa58:	d3cd      	bcc.n	f9f6 <z_vprintk+0x14a>
				_printk_dec_ulong(out, ctx, u, padding,
    fa5a:	f8cd 9000 	str.w	r9, [sp]
    fa5e:	4643      	mov	r3, r8
    fa60:	e7df      	b.n	fa22 <z_vprintk+0x176>
				  out('0', ctx);
    fa62:	4631      	mov	r1, r6
    fa64:	2030      	movs	r0, #48	; 0x30
    fa66:	47a8      	blx	r5
				  out('x', ctx);
    fa68:	4631      	mov	r1, r6
    fa6a:	2078      	movs	r0, #120	; 0x78
    fa6c:	47a8      	blx	r5
				  min_width = 8;
    fa6e:	f04f 0908 	mov.w	r9, #8
				  padding = PAD_ZERO_BEFORE;
    fa72:	f04f 0801 	mov.w	r8, #1
				if (*fmt == 'p') {
    fa76:	f89a 2000 	ldrb.w	r2, [sl]
    fa7a:	2a70      	cmp	r2, #112	; 0x70
    fa7c:	d105      	bne.n	fa8a <z_vprintk+0x1de>
					x = va_arg(ap, unsigned int);
    fa7e:	6823      	ldr	r3, [r4, #0]
    fa80:	3404      	adds	r4, #4
    fa82:	9304      	str	r3, [sp, #16]
    fa84:	2300      	movs	r3, #0
    fa86:	9302      	str	r3, [sp, #8]
    fa88:	e00c      	b.n	faa4 <z_vprintk+0x1f8>
				} else if (length_mod == 'l') {
    fa8a:	2f6c      	cmp	r7, #108	; 0x6c
    fa8c:	d0f7      	beq.n	fa7e <z_vprintk+0x1d2>
				} else if (length_mod == 'L') {
    fa8e:	2f4c      	cmp	r7, #76	; 0x4c
    fa90:	d1f5      	bne.n	fa7e <z_vprintk+0x1d2>
					x = va_arg(ap, unsigned long long);
    fa92:	3407      	adds	r4, #7
    fa94:	f024 0207 	bic.w	r2, r4, #7
    fa98:	6813      	ldr	r3, [r2, #0]
    fa9a:	f102 0408 	add.w	r4, r2, #8
    fa9e:	9304      	str	r3, [sp, #16]
    faa0:	6853      	ldr	r3, [r2, #4]
    faa2:	9302      	str	r3, [sp, #8]
	int digits = 0;
    faa4:	2200      	movs	r2, #0
	int remaining = 16; /* 16 digits max */
    faa6:	2310      	movs	r3, #16
	int digits = 0;
    faa8:	9203      	str	r2, [sp, #12]
	int found_largest_digit = 0;
    faaa:	9205      	str	r2, [sp, #20]
	int shift = sizeof(num) * 8;
    faac:	2240      	movs	r2, #64	; 0x40
		shift -= 4;
    faae:	3a04      	subs	r2, #4
		nibble = (num >> shift) & 0xf;
    fab0:	9902      	ldr	r1, [sp, #8]
    fab2:	9804      	ldr	r0, [sp, #16]
    fab4:	f1c2 0c20 	rsb	ip, r2, #32
    fab8:	f1a2 0e20 	sub.w	lr, r2, #32
    fabc:	40d0      	lsrs	r0, r2
    fabe:	fa01 fc0c 	lsl.w	ip, r1, ip
    fac2:	ea40 000c 	orr.w	r0, r0, ip
    fac6:	fa21 fe0e 	lsr.w	lr, r1, lr
    faca:	ea40 000e 	orr.w	r0, r0, lr
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    face:	f010 000f 	ands.w	r0, r0, #15
    fad2:	d108      	bne.n	fae6 <z_vprintk+0x23a>
    fad4:	9905      	ldr	r1, [sp, #20]
    fad6:	b901      	cbnz	r1, fada <z_vprintk+0x22e>
    fad8:	bb42      	cbnz	r2, fb2c <z_vprintk+0x280>
			nibble += nibble > 9 ? 87 : 48;
    fada:	f04f 0c30 	mov.w	ip, #48	; 0x30
    fade:	e008      	b.n	faf2 <z_vprintk+0x246>
			found_largest_digit = 1;
    fae0:	f8cd b014 	str.w	fp, [sp, #20]
    fae4:	e7e3      	b.n	faae <z_vprintk+0x202>
			nibble += nibble > 9 ? 87 : 48;
    fae6:	2809      	cmp	r0, #9
    fae8:	bf8c      	ite	hi
    faea:	f04f 0c57 	movhi.w	ip, #87	; 0x57
    faee:	f04f 0c30 	movls.w	ip, #48	; 0x30
			out((int)nibble, ctx);
    faf2:	4631      	mov	r1, r6
    faf4:	4460      	add	r0, ip
    faf6:	e9cd 2305 	strd	r2, r3, [sp, #20]
    fafa:	47a8      	blx	r5
			digits++;
    fafc:	9b03      	ldr	r3, [sp, #12]
    fafe:	3301      	adds	r3, #1
    fb00:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
    fb02:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    fb06:	2a00      	cmp	r2, #0
    fb08:	d1ea      	bne.n	fae0 <z_vprintk+0x234>
	if (padding == PAD_SPACE_AFTER) {
    fb0a:	f1b8 0f03 	cmp.w	r8, #3
    fb0e:	f47f af76 	bne.w	f9fe <z_vprintk+0x152>
		remaining = min_width * 2 - digits;
    fb12:	9b03      	ldr	r3, [sp, #12]
    fb14:	ebc3 0b49 	rsb	fp, r3, r9, lsl #1
		while (remaining-- > 0) {
    fb18:	f1bb 0f00 	cmp.w	fp, #0
    fb1c:	f77f af6f 	ble.w	f9fe <z_vprintk+0x152>
			out(' ', ctx);
    fb20:	4631      	mov	r1, r6
    fb22:	2020      	movs	r0, #32
    fb24:	47a8      	blx	r5
    fb26:	f10b 3bff 	add.w	fp, fp, #4294967295
    fb2a:	e7f5      	b.n	fb18 <z_vprintk+0x26c>
		if (remaining-- <= min_width) {
    fb2c:	1e59      	subs	r1, r3, #1
    fb2e:	4599      	cmp	r9, r3
    fb30:	9106      	str	r1, [sp, #24]
    fb32:	db07      	blt.n	fb44 <z_vprintk+0x298>
			if (padding == PAD_ZERO_BEFORE) {
    fb34:	f1b8 0f01 	cmp.w	r8, #1
    fb38:	d106      	bne.n	fb48 <z_vprintk+0x29c>
				out('0', ctx);
    fb3a:	4631      	mov	r1, r6
    fb3c:	2030      	movs	r0, #48	; 0x30
    fb3e:	9207      	str	r2, [sp, #28]
				out(' ', ctx);
    fb40:	47a8      	blx	r5
    fb42:	9a07      	ldr	r2, [sp, #28]
					x = va_arg(ap, unsigned int);
    fb44:	9b06      	ldr	r3, [sp, #24]
    fb46:	e7b2      	b.n	faae <z_vprintk+0x202>
			} else if (padding == PAD_SPACE_BEFORE) {
    fb48:	f1b8 0f02 	cmp.w	r8, #2
    fb4c:	d1fa      	bne.n	fb44 <z_vprintk+0x298>
    fb4e:	9207      	str	r2, [sp, #28]
				out(' ', ctx);
    fb50:	4631      	mov	r1, r6
    fb52:	2020      	movs	r0, #32
    fb54:	e7f4      	b.n	fb40 <z_vprintk+0x294>
					out((int)(*s++), ctx);
    fb56:	4631      	mov	r1, r6
    fb58:	9202      	str	r2, [sp, #8]
    fb5a:	47a8      	blx	r5
    fb5c:	4621      	mov	r1, r4
    fb5e:	9a02      	ldr	r2, [sp, #8]
    fb60:	e6fa      	b.n	f958 <z_vprintk+0xac>
						out(' ', ctx);
    fb62:	4631      	mov	r1, r6
    fb64:	2020      	movs	r0, #32
    fb66:	47a8      	blx	r5
    fb68:	3c01      	subs	r4, #1
    fb6a:	e702      	b.n	f972 <z_vprintk+0xc6>
				out(c, ctx);
    fb6c:	4631      	mov	r1, r6
    fb6e:	6820      	ldr	r0, [r4, #0]
				int c = va_arg(ap, int);
    fb70:	f104 0b04 	add.w	fp, r4, #4
				out(c, ctx);
    fb74:	47a8      	blx	r5
    fb76:	e6ff      	b.n	f978 <z_vprintk+0xcc>
				length_mod = 0;
    fb78:	465f      	mov	r7, fp
				padding = PAD_NONE;
    fb7a:	46d8      	mov	r8, fp
				min_width = -1;
    fb7c:	f04f 39ff 	mov.w	r9, #4294967295
				might_format = 1;
    fb80:	f04f 0b01 	mov.w	fp, #1
    fb84:	e6ac      	b.n	f8e0 <z_vprintk+0x34>
				padding = PAD_SPACE_AFTER;
    fb86:	f04f 0803 	mov.w	r8, #3
    fb8a:	e6a9      	b.n	f8e0 <z_vprintk+0x34>
					padding = PAD_ZERO_BEFORE;
    fb8c:	f04f 0801 	mov.w	r8, #1
    fb90:	e6a6      	b.n	f8e0 <z_vprintk+0x34>
				char *s = va_arg(ap, char *);
    fb92:	465c      	mov	r4, fp
			might_format = 0;
    fb94:	4683      	mov	fp, r0
    fb96:	e6a3      	b.n	f8e0 <z_vprintk+0x34>

0000fb98 <printk>:
{
    fb98:	b40f      	push	{r0, r1, r2, r3}
    fb9a:	b507      	push	{r0, r1, r2, lr}
    fb9c:	a904      	add	r1, sp, #16
    fb9e:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    fba2:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    fba4:	f7fc fefc 	bl	c9a0 <vprintk>
}
    fba8:	b003      	add	sp, #12
    fbaa:	f85d eb04 	ldr.w	lr, [sp], #4
    fbae:	b004      	add	sp, #16
    fbb0:	4770      	bx	lr

0000fbb2 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    fbb2:	4770      	bx	lr

0000fbb4 <z_platform_init>:
	nrfx_coredep_delay_us(time_us);
}

void z_platform_init(void)
{
	SystemInit();
    fbb4:	f7fe b870 	b.w	dc98 <SystemInit>

0000fbb8 <get_status>:
	struct nrf_clock_control *data = dev->driver_data;
    fbb8:	6883      	ldr	r3, [r0, #8]
	if (data->started) {
    fbba:	7a5a      	ldrb	r2, [r3, #9]
    fbbc:	b932      	cbnz	r2, fbcc <get_status+0x14>
	if (data->ref > 0) {
    fbbe:	f993 0008 	ldrsb.w	r0, [r3, #8]
		return CLOCK_CONTROL_STATUS_ON;
    fbc2:	2800      	cmp	r0, #0
    fbc4:	bfcc      	ite	gt
    fbc6:	2000      	movgt	r0, #0
    fbc8:	2001      	movle	r0, #1
    fbca:	4770      	bx	lr
    fbcc:	2002      	movs	r0, #2
}
    fbce:	4770      	bx	lr

0000fbd0 <clock_stop>:
	const struct nrf_clock_control_config *config =
    fbd0:	6802      	ldr	r2, [r0, #0]
{
    fbd2:	b570      	push	{r4, r5, r6, lr}
	const struct nrf_clock_control_config *config =
    fbd4:	6895      	ldr	r5, [r2, #8]
	struct nrf_clock_control *data = dev->driver_data;
    fbd6:	6884      	ldr	r4, [r0, #8]
    fbd8:	f04f 0320 	mov.w	r3, #32
    fbdc:	f3ef 8611 	mrs	r6, BASEPRI
    fbe0:	f383 8811 	msr	BASEPRI, r3
    fbe4:	f3bf 8f6f 	isb	sy
	data->ref--;
    fbe8:	7a23      	ldrb	r3, [r4, #8]
    fbea:	3b01      	subs	r3, #1
    fbec:	b25b      	sxtb	r3, r3
	if (data->ref == 0) {
    fbee:	2b00      	cmp	r3, #0
	data->ref--;
    fbf0:	7223      	strb	r3, [r4, #8]
	if (data->ref == 0) {
    fbf2:	d118      	bne.n	fc26 <clock_stop+0x56>
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    fbf4:	e9c4 3300 	strd	r3, r3, [r4]
		do_stop =  (config->stop_handler) ?
    fbf8:	686b      	ldr	r3, [r5, #4]
				config->stop_handler(dev) : true;
    fbfa:	b983      	cbnz	r3, fc1e <clock_stop+0x4e>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = 0x1UL;
    fbfc:	2201      	movs	r2, #1
    fbfe:	7aeb      	ldrb	r3, [r5, #11]
    fc00:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fc04:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    fc06:	2200      	movs	r2, #0
    fc08:	892b      	ldrh	r3, [r5, #8]
    fc0a:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fc0e:	601a      	str	r2, [r3, #0]
		data->started = false;
    fc10:	2000      	movs	r0, #0
    fc12:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
    fc14:	f386 8811 	msr	BASEPRI, r6
    fc18:	f3bf 8f6f 	isb	sy
}
    fc1c:	bd70      	pop	{r4, r5, r6, pc}
				config->stop_handler(dev) : true;
    fc1e:	4798      	blx	r3
    fc20:	2800      	cmp	r0, #0
    fc22:	d1eb      	bne.n	fbfc <clock_stop+0x2c>
    fc24:	e7f4      	b.n	fc10 <clock_stop+0x40>
    fc26:	f04f 0000 	mov.w	r0, #0
		data->ref = 0;
    fc2a:	bfbc      	itt	lt
    fc2c:	7220      	strblt	r0, [r4, #8]
		err = -EALREADY;
    fc2e:	f06f 0044 	mvnlt.w	r0, #68	; 0x44
    fc32:	e7ef      	b.n	fc14 <clock_stop+0x44>

0000fc34 <clock_async_start>:
{
    fc34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct nrf_clock_control_config *config =
    fc36:	6803      	ldr	r3, [r0, #0]
{
    fc38:	4606      	mov	r6, r0
    fc3a:	4614      	mov	r4, r2
	const struct nrf_clock_control_config *config =
    fc3c:	689f      	ldr	r7, [r3, #8]
	struct nrf_clock_control *clk_data = dev->driver_data;
    fc3e:	6885      	ldr	r5, [r0, #8]
	__asm__ volatile(
    fc40:	f04f 0320 	mov.w	r3, #32
    fc44:	f3ef 8211 	mrs	r2, BASEPRI
    fc48:	f383 8811 	msr	BASEPRI, r3
    fc4c:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
    fc50:	7a2b      	ldrb	r3, [r5, #8]
    fc52:	3301      	adds	r3, #1
    fc54:	b25b      	sxtb	r3, r3
    fc56:	722b      	strb	r3, [r5, #8]
	__asm__ volatile(
    fc58:	f382 8811 	msr	BASEPRI, r2
    fc5c:	f3bf 8f6f 	isb	sy
	if (clk_data->started) {
    fc60:	7a6a      	ldrb	r2, [r5, #9]
    fc62:	b132      	cbz	r2, fc72 <clock_async_start+0x3e>
		if (data) {
    fc64:	b90c      	cbnz	r4, fc6a <clock_async_start+0x36>
	return 0;
    fc66:	2000      	movs	r0, #0
}
    fc68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			data->cb(dev, data->user_data);
    fc6a:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    fc6e:	4798      	blx	r3
    fc70:	e7f9      	b.n	fc66 <clock_async_start+0x32>
		if (ref == 1) {
    fc72:	2b01      	cmp	r3, #1
    fc74:	d106      	bne.n	fc84 <clock_async_start+0x50>
			do_start =  (config->start_handler) ?
    fc76:	683b      	ldr	r3, [r7, #0]
					config->start_handler(dev) : true;
    fc78:	b933      	cbnz	r3, fc88 <clock_async_start+0x54>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = 0x1UL;
    fc7a:	2201      	movs	r2, #1
    fc7c:	7abb      	ldrb	r3, [r7, #10]
    fc7e:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fc82:	601a      	str	r2, [r3, #0]
		if (data) {
    fc84:	b94c      	cbnz	r4, fc9a <clock_async_start+0x66>
    fc86:	e7ee      	b.n	fc66 <clock_async_start+0x32>
					config->start_handler(dev) : true;
    fc88:	4798      	blx	r3
    fc8a:	2800      	cmp	r0, #0
    fc8c:	d1f5      	bne.n	fc7a <clock_async_start+0x46>
			} else if (data) {
    fc8e:	2c00      	cmp	r4, #0
    fc90:	d0e9      	beq.n	fc66 <clock_async_start+0x32>
				data->cb(dev, data->user_data);
    fc92:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    fc96:	4630      	mov	r0, r6
    fc98:	4798      	blx	r3
	sys_snode_t *item = sys_slist_peek_head(list);
    fc9a:	682b      	ldr	r3, [r5, #0]
		if (item == node) {
    fc9c:	429c      	cmp	r4, r3
    fc9e:	d00d      	beq.n	fcbc <clock_async_start+0x88>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    fca0:	b113      	cbz	r3, fca8 <clock_async_start+0x74>
	return node->next;
    fca2:	681b      	ldr	r3, [r3, #0]
	} while (item);
    fca4:	2b00      	cmp	r3, #0
    fca6:	d1f9      	bne.n	fc9c <clock_async_start+0x68>
	parent->next = child;
    fca8:	2000      	movs	r0, #0
    fcaa:	6020      	str	r0, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    fcac:	686b      	ldr	r3, [r5, #4]
    fcae:	b913      	cbnz	r3, fcb6 <clock_async_start+0x82>
	list->head = node;
    fcb0:	e9c5 4400 	strd	r4, r4, [r5]
    fcb4:	e7d7      	b.n	fc66 <clock_async_start+0x32>
	parent->next = child;
    fcb6:	601c      	str	r4, [r3, #0]
	list->tail = node;
    fcb8:	606c      	str	r4, [r5, #4]
    fcba:	e7d5      	b.n	fc68 <clock_async_start+0x34>
				return -EALREADY;
    fcbc:	f06f 0044 	mvn.w	r0, #68	; 0x44
    fcc0:	e7d2      	b.n	fc68 <clock_async_start+0x34>

0000fcc2 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
    fcc2:	2200      	movs	r2, #0
    fcc4:	f7ff bfb6 	b.w	fc34 <clock_async_start>

0000fcc8 <lfclk_init>:
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
    fcc8:	6883      	ldr	r3, [r0, #8]
	list->head = NULL;
    fcca:	2000      	movs	r0, #0
	list->tail = NULL;
    fccc:	e9c3 0000 	strd	r0, r0, [r3]
}
    fcd0:	4770      	bx	lr

0000fcd2 <hfclk_init>:
{
    fcd2:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    fcd4:	2200      	movs	r2, #0
{
    fcd6:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    fcd8:	2101      	movs	r1, #1
    fcda:	2005      	movs	r0, #5
    fcdc:	f7fd fb74 	bl	d3c8 <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
    fce0:	2005      	movs	r0, #5
    fce2:	f7fd fb61 	bl	d3a8 <z_arch_irq_enable>
}

__STATIC_INLINE void nrf_clock_lf_src_set(nrf_clock_lfclk_t source)
{
    NRF_CLOCK->LFCLKSRC = (uint32_t)(source);
    fce6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    fcea:	2202      	movs	r2, #2
    fcec:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    NRF_CLOCK->INTENSET = int_mask;
    fcf0:	2203      	movs	r2, #3
	list->head = NULL;
    fcf2:	2000      	movs	r0, #0
    fcf4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
    fcf8:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
    fcfa:	e9c3 0000 	strd	r0, r0, [r3]
}
    fcfe:	bd10      	pop	{r4, pc}

0000fd00 <clkstarted_handle>:
{
    fd00:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control *data = dev->driver_data;
    fd02:	6884      	ldr	r4, [r0, #8]
{
    fd04:	4605      	mov	r5, r0
Z_GENLIST_IS_EMPTY(slist)
    fd06:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    fd08:	b12b      	cbz	r3, fd16 <clkstarted_handle+0x16>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fd0a:	6861      	ldr	r1, [r4, #4]
	return node->next;
    fd0c:	681a      	ldr	r2, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fd0e:	428b      	cmp	r3, r1
	list->head = node;
    fd10:	6022      	str	r2, [r4, #0]
	list->tail = node;
    fd12:	bf08      	it	eq
    fd14:	6062      	streq	r2, [r4, #4]
	data->started = true;
    fd16:	2201      	movs	r2, #1
    fd18:	7262      	strb	r2, [r4, #9]
	while (node != NULL) {
    fd1a:	b903      	cbnz	r3, fd1e <clkstarted_handle+0x1e>
}
    fd1c:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
    fd1e:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    fd22:	4628      	mov	r0, r5
    fd24:	4790      	blx	r2
Z_GENLIST_IS_EMPTY(slist)
    fd26:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
    fd28:	2b00      	cmp	r3, #0
    fd2a:	d0f7      	beq.n	fd1c <clkstarted_handle+0x1c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fd2c:	6861      	ldr	r1, [r4, #4]
	return node->next;
    fd2e:	681a      	ldr	r2, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fd30:	428b      	cmp	r3, r1
	list->head = node;
    fd32:	6022      	str	r2, [r4, #0]
	list->tail = node;
    fd34:	bf08      	it	eq
    fd36:	6062      	streq	r2, [r4, #4]
    fd38:	e7ef      	b.n	fd1a <clkstarted_handle+0x1a>

0000fd3a <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    fd3a:	4770      	bx	lr

0000fd3c <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    fd3c:	4770      	bx	lr

0000fd3e <spm_secure_services_init>:
	mbedtls_platform_context platform_ctx = {0};
    fd3e:	2300      	movs	r3, #0
{
    fd40:	b507      	push	{r0, r1, r2, lr}
	mbedtls_platform_context platform_ctx = {0};
    fd42:	a802      	add	r0, sp, #8
    fd44:	f800 3d04 	strb.w	r3, [r0, #-4]!
	err = mbedtls_platform_setup(&platform_ctx);
    fd48:	f7fe ff62 	bl	ec10 <mbedtls_platform_setup>
}
    fd4c:	b003      	add	sp, #12
    fd4e:	f85d fb04 	ldr.w	pc, [sp], #4

0000fd52 <__acle_se_spm_request_random_number>:
	if (len != MBEDTLS_ENTROPY_MAX_GATHER) {
    fd52:	2990      	cmp	r1, #144	; 0x90
{
    fd54:	b508      	push	{r3, lr}
    fd56:	4613      	mov	r3, r2
	if (len != MBEDTLS_ENTROPY_MAX_GATHER) {
    fd58:	d139      	bne.n	fdce <__acle_se_spm_request_random_number+0x7c>
	err = mbedtls_hardware_poll(NULL, output, len, olen);
    fd5a:	460a      	mov	r2, r1
    fd5c:	4601      	mov	r1, r0
    fd5e:	2000      	movs	r0, #0
    fd60:	f7fe ff62 	bl	ec28 <mbedtls_hardware_poll>
}
    fd64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    fd68:	4671      	mov	r1, lr
    fd6a:	4672      	mov	r2, lr
    fd6c:	4673      	mov	r3, lr
    fd6e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fd72:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    fd76:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    fd7a:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    fd7e:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    fd82:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    fd86:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    fd8a:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    fd8e:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    fd92:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    fd96:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    fd9a:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    fd9e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    fda2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    fda6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    fdaa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    fdae:	f38e 8c00 	msr	CPSR_fs, lr
    fdb2:	b410      	push	{r4}
    fdb4:	eef1 ca10 	vmrs	ip, fpscr
    fdb8:	f64f 7460 	movw	r4, #65376	; 0xff60
    fdbc:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    fdc0:	ea0c 0c04 	and.w	ip, ip, r4
    fdc4:	eee1 ca10 	vmsr	fpscr, ip
    fdc8:	bc10      	pop	{r4}
    fdca:	46f4      	mov	ip, lr
    fdcc:	4774      	bxns	lr
		return -EINVAL;
    fdce:	f06f 0015 	mvn.w	r0, #21
    fdd2:	e7c7      	b.n	fd64 <__acle_se_spm_request_random_number+0x12>

0000fdd4 <abort_function>:
{
    fdd4:	e7fe      	b.n	fdd4 <abort_function>

0000fdd6 <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	z_arm_reserved();
    fdd6:	f7fd ba97 	b.w	d308 <z_arm_bus_fault>

0000fdda <irq_target_state_set>:
 * @param secure_state 1 if target state is Secure, 0 otherwise.
 *
 * @return N/A
 */
void irq_target_state_set(unsigned int irq, int secure_state)
{
    fdda:	b243      	sxtb	r3, r0
	if (secure_state) {
    fddc:	b1a9      	cbz	r1, fe0a <irq_target_state_set+0x30>
  if ((int32_t)(IRQn) >= 0)
    fdde:	2b00      	cmp	r3, #0
    fde0:	db12      	blt.n	fe08 <irq_target_state_set+0x2e>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
    fde2:	2101      	movs	r1, #1
    fde4:	095b      	lsrs	r3, r3, #5
    fde6:	009b      	lsls	r3, r3, #2
    fde8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    fdec:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    fdf0:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
    fdf4:	f000 001f 	and.w	r0, r0, #31
    fdf8:	fa01 f000 	lsl.w	r0, r1, r0
    fdfc:	ea22 0000 	bic.w	r0, r2, r0
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
    fe00:	f8c3 0280 	str.w	r0, [r3, #640]	; 0x280
    return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
    fe04:	f8d3 3280 	ldr.w	r3, [r3, #640]	; 0x280
		/* Set target state to Non-Secure */
		if (NVIC_SetTargetState(irq) != 1) {
			__ASSERT(0, "NVIC SetTargetState error");
		}
	}
}
    fe08:	4770      	bx	lr
  if ((int32_t)(IRQn) >= 0)
    fe0a:	2b00      	cmp	r3, #0
    fe0c:	dbfc      	blt.n	fe08 <irq_target_state_set+0x2e>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
    fe0e:	2201      	movs	r2, #1
    fe10:	095b      	lsrs	r3, r3, #5
    fe12:	009b      	lsls	r3, r3, #2
    fe14:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    fe18:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    fe1c:	f8d3 1280 	ldr.w	r1, [r3, #640]	; 0x280
    fe20:	f000 001f 	and.w	r0, r0, #31
    fe24:	fa02 f000 	lsl.w	r0, r2, r0
    fe28:	4308      	orrs	r0, r1
    fe2a:	e7e9      	b.n	fe00 <irq_target_state_set+0x26>

0000fe2c <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    fe2c:	f000 b8fb 	b.w	10026 <z_fatal_error>

0000fe30 <z_do_kernel_oops>:
}

void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    fe30:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    fe32:	6800      	ldr	r0, [r0, #0]
    fe34:	f000 b8f7 	b.w	10026 <z_fatal_error>

0000fe38 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    fe38:	b508      	push	{r3, lr}
	handler();
    fe3a:	f7fd fa77 	bl	d32c <z_SysNmiOnReset>
	z_arm_exc_exit();
}
    fe3e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
    fe42:	f7fd ba0d 	b.w	d260 <z_arm_exc_exit>

0000fe46 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    fe46:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    fe48:	2100      	movs	r1, #0
    fe4a:	a801      	add	r0, sp, #4
    fe4c:	f7fd fde6 	bl	da1c <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    fe50:	b003      	add	sp, #12
    fe52:	f85d fb04 	ldr.w	pc, [sp], #4

0000fe56 <mpu_configure_region>:
{
    fe56:	b530      	push	{r4, r5, lr}
    fe58:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
    fe5a:	f89d 2008 	ldrb.w	r2, [sp, #8]
    fe5e:	890d      	ldrh	r5, [r1, #8]
	region_conf.base = new_region->start;
    fe60:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    fe62:	684c      	ldr	r4, [r1, #4]
	p_attr->mair_idx = attr->mair_idx;
    fe64:	8949      	ldrh	r1, [r1, #10]
	p_attr->rbar = attr->rbar &
    fe66:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->mair_idx = attr->mair_idx;
    fe6a:	f361 1247 	bfi	r2, r1, #5, #3
	region_conf.base = new_region->start;
    fe6e:	9300      	str	r3, [sp, #0]
    fe70:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    fe74:	f023 031f 	bic.w	r3, r3, #31
    fe78:	1e62      	subs	r2, r4, #1
    fe7a:	4413      	add	r3, r2
    fe7c:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
    fe80:	280f      	cmp	r0, #15
    fe82:	9303      	str	r3, [sp, #12]
    fe84:	4604      	mov	r4, r0
    fe86:	d805      	bhi.n	fe94 <mpu_configure_region+0x3e>
	region_init(index, region_conf);
    fe88:	4669      	mov	r1, sp
    fe8a:	f7fd fc81 	bl	d790 <region_init>
}
    fe8e:	4620      	mov	r0, r4
    fe90:	b005      	add	sp, #20
    fe92:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    fe94:	f06f 0415 	mvn.w	r4, #21
	return region_allocate_and_init(index,
    fe98:	e7f9      	b.n	fe8e <mpu_configure_region+0x38>

0000fe9a <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
    fe9a:	3801      	subs	r0, #1
    fe9c:	3901      	subs	r1, #1
	while ((*s1 == *s2) && (*s1 != '\0')) {
    fe9e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    fea2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    fea6:	4293      	cmp	r3, r2
    fea8:	d102      	bne.n	feb0 <strcmp+0x16>
    feaa:	2b00      	cmp	r3, #0
    feac:	d1f7      	bne.n	fe9e <strcmp+0x4>
    feae:	461a      	mov	r2, r3
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    feb0:	1a98      	subs	r0, r3, r2
    feb2:	4770      	bx	lr

0000feb4 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    feb4:	1a43      	subs	r3, r0, r1
    feb6:	4293      	cmp	r3, r2
{
    feb8:	b510      	push	{r4, lr}
    feba:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
    febe:	d308      	bcc.n	fed2 <memmove+0x1e>
	char *dest = d;
    fec0:	4602      	mov	r2, r0
    fec2:	3901      	subs	r1, #1
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    fec4:	429a      	cmp	r2, r3
    fec6:	d00b      	beq.n	fee0 <memmove+0x2c>
			*dest = *src;
    fec8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    fecc:	f802 4b01 	strb.w	r4, [r2], #1
    fed0:	e7f8      	b.n	fec4 <memmove+0x10>
    fed2:	440a      	add	r2, r1
			dest[n] = src[n];
    fed4:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
		while (n > 0) {
    fed8:	428a      	cmp	r2, r1
			dest[n] = src[n];
    feda:	f803 4d01 	strb.w	r4, [r3, #-1]!
		while (n > 0) {
    fede:	d1f9      	bne.n	fed4 <memmove+0x20>
			n--;
		}
	}

	return d;
}
    fee0:	bd10      	pop	{r4, pc}

0000fee2 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    fee2:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    fee4:	ea81 0400 	eor.w	r4, r1, r0
    fee8:	07a5      	lsls	r5, r4, #30
    feea:	4603      	mov	r3, r0
    feec:	d00b      	beq.n	ff06 <memcpy+0x24>
    feee:	3b01      	subs	r3, #1
    fef0:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    fef2:	4291      	cmp	r1, r2
    fef4:	d11d      	bne.n	ff32 <memcpy+0x50>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    fef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
    fef8:	2a00      	cmp	r2, #0
    fefa:	d0fc      	beq.n	fef6 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
    fefc:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
    ff00:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
    ff02:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
    ff06:	079c      	lsls	r4, r3, #30
    ff08:	d1f6      	bne.n	fef8 <memcpy+0x16>
    ff0a:	460c      	mov	r4, r1
    ff0c:	1f1d      	subs	r5, r3, #4
    ff0e:	188f      	adds	r7, r1, r2
		while (n >= sizeof(mem_word_t)) {
    ff10:	1b3e      	subs	r6, r7, r4
    ff12:	2e03      	cmp	r6, #3
    ff14:	d808      	bhi.n	ff28 <memcpy+0x46>
    ff16:	f06f 0503 	mvn.w	r5, #3
    ff1a:	0894      	lsrs	r4, r2, #2
    ff1c:	fb05 2204 	mla	r2, r5, r4, r2
    ff20:	00a4      	lsls	r4, r4, #2
    ff22:	4423      	add	r3, r4
    ff24:	4421      	add	r1, r4
    ff26:	e7e2      	b.n	feee <memcpy+0xc>
			*(d_word++) = *(s_word++);
    ff28:	f854 6b04 	ldr.w	r6, [r4], #4
    ff2c:	f845 6f04 	str.w	r6, [r5, #4]!
    ff30:	e7ee      	b.n	ff10 <memcpy+0x2e>
		*(d_byte++) = *(s_byte++);
    ff32:	f811 4b01 	ldrb.w	r4, [r1], #1
    ff36:	f803 4f01 	strb.w	r4, [r3, #1]!
    ff3a:	e7da      	b.n	fef2 <memcpy+0x10>

0000ff3c <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
    ff3c:	4603      	mov	r3, r0
{
    ff3e:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned char c_byte = (unsigned char)c;
    ff40:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    ff42:	079c      	lsls	r4, r3, #30
    ff44:	d10f      	bne.n	ff66 <memset+0x2a>
	c_word |= c_word << 16;
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    ff46:	461d      	mov	r5, r3
	c_word |= c_word << 8;
    ff48:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
    ff4c:	ea44 4404 	orr.w	r4, r4, r4, lsl #16
    ff50:	189f      	adds	r7, r3, r2
	while (n >= sizeof(mem_word_t)) {
    ff52:	1b7e      	subs	r6, r7, r5
    ff54:	2e03      	cmp	r6, #3
    ff56:	d80c      	bhi.n	ff72 <memset+0x36>
    ff58:	0894      	lsrs	r4, r2, #2
    ff5a:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    ff5e:	4413      	add	r3, r2

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    ff60:	429c      	cmp	r4, r3
    ff62:	d109      	bne.n	ff78 <memset+0x3c>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    ff64:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (n == 0) {
    ff66:	2a00      	cmp	r2, #0
    ff68:	d0fc      	beq.n	ff64 <memset+0x28>
		*(d_byte++) = c_byte;
    ff6a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    ff6e:	3a01      	subs	r2, #1
    ff70:	e7e7      	b.n	ff42 <memset+0x6>
		*(d_word++) = c_word;
    ff72:	f845 4b04 	str.w	r4, [r5], #4
    ff76:	e7ec      	b.n	ff52 <memset+0x16>
		*(d_byte++) = c_byte;
    ff78:	f804 1b01 	strb.w	r1, [r4], #1
    ff7c:	e7f0      	b.n	ff60 <memset+0x24>

0000ff7e <_stdout_hook_default>:
}
    ff7e:	f04f 30ff 	mov.w	r0, #4294967295
    ff82:	4770      	bx	lr

0000ff84 <uarte_nrfx_config_get>:
{
    ff84:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
    ff86:	6882      	ldr	r2, [r0, #8]
    ff88:	e892 0003 	ldmia.w	r2, {r0, r1}
    ff8c:	e883 0003 	stmia.w	r3, {r0, r1}
}
    ff90:	2000      	movs	r0, #0
    ff92:	4770      	bx	lr

0000ff94 <uarte_nrfx_err_check>:
	return dev->config->config_info;
    ff94:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
    ff96:	689b      	ldr	r3, [r3, #8]
    ff98:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ff9a:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
    ff9e:	b118      	cbz	r0, ffa8 <uarte_nrfx_err_check+0x14>
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    ffa0:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    ffa4:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    ffa8:	4770      	bx	lr

0000ffaa <uarte_nrfx_poll_in>:
	return dev->config->config_info;
    ffaa:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
    ffac:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
    ffae:	689b      	ldr	r3, [r3, #8]
    ffb0:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ffb2:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    ffb6:	b138      	cbz	r0, ffc8 <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
    ffb8:	7a12      	ldrb	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ffba:	2000      	movs	r0, #0
    ffbc:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ffbe:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ffc0:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ffc4:	601a      	str	r2, [r3, #0]
	return 0;
    ffc6:	4770      	bx	lr
		return -1;
    ffc8:	f04f 30ff 	mov.w	r0, #4294967295
}
    ffcc:	4770      	bx	lr

0000ffce <uarte_nrfx_poll_out>:
{
    ffce:	b082      	sub	sp, #8
    ffd0:	aa02      	add	r2, sp, #8
    ffd2:	f802 1d01 	strb.w	r1, [r2, #-1]!
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ffd6:	2100      	movs	r1, #0
	return dev->config->config_info;
    ffd8:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
    ffda:	689b      	ldr	r3, [r3, #8]
    ffdc:	681b      	ldr	r3, [r3, #0]
    ffde:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    ffe2:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    ffe6:	2201      	movs	r2, #1
    ffe8:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ffec:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ffee:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    fff2:	2900      	cmp	r1, #0
    fff4:	d0fb      	beq.n	ffee <uarte_nrfx_poll_out+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    fff6:	60da      	str	r2, [r3, #12]
}
    fff8:	b002      	add	sp, #8
    fffa:	4770      	bx	lr

0000fffc <hw_cc310_init>:
#if CONFIG_HW_CC310

#include "nrf_cc310_platform.h"

static int hw_cc310_init(struct device *dev)
{
    fffc:	b508      	push	{r3, lr}
	int res;

	__ASSERT_NO_MSG(dev != NULL);

	/* Set the RTOS abort APIs */
	nrf_cc310_platform_abort_init();
    fffe:	f7fd f899 	bl	d134 <nrf_cc310_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc310_platform_mutex_init();
   10002:	f7fd f917 	bl	d234 <nrf_cc310_platform_mutex_init>
	res = nrf_cc310_platform_init();
#else
	res = nrf_cc310_platform_init_no_rng();
#endif
	return res;
}
   10006:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	res = nrf_cc310_platform_init_no_rng();
   1000a:	f7fe bec5 	b.w	ed98 <nrf_cc310_platform_init_no_rng>

0001000e <z_arch_system_halt>:
	__asm__ volatile(
   1000e:	f04f 0220 	mov.w	r2, #32
   10012:	f3ef 8311 	mrs	r3, BASEPRI
   10016:	f382 8811 	msr	BASEPRI, r2
   1001a:	f3bf 8f6f 	isb	sy
   1001e:	e7fe      	b.n	1001e <z_arch_system_halt+0x10>

00010020 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   10020:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	z_arch_system_halt(reason);
   10022:	f7ff fff4 	bl	1000e <z_arch_system_halt>

00010026 <z_fatal_error>:
	z_arch_system_halt(reason);
}
/* LCOV_EXCL_STOP */

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   10026:	b570      	push	{r4, r5, r6, lr}
   10028:	4605      	mov	r5, r0
   1002a:	460e      	mov	r6, r1
	return z_impl_k_current_get();
   1002c:	f7fe fb68 	bl	e700 <z_impl_k_current_get>
	 */

	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   10030:	4631      	mov	r1, r6
   10032:	4604      	mov	r4, r0
   10034:	4628      	mov	r0, r5
   10036:	f7ff fff3 	bl	10020 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
   1003a:	4620      	mov	r0, r4
		/* FIXME: #17656 */
		__ASSERT(!k_is_in_isr(),
			 "Attempted to recover from a fatal error in ISR");
	}
	k_thread_abort(thread);
}
   1003c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10040:	f7fd bb56 	b.w	d6f0 <z_impl_k_thread_abort>

00010044 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   10044:	f7ff be7a 	b.w	fd3c <z_clock_idle_exit>

00010048 <k_mem_slab_init>:
{
   10048:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   1004a:	2400      	movs	r4, #0
	slab->block_size = block_size;
   1004c:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   10050:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   10054:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   10056:	42a3      	cmp	r3, r4
   10058:	d102      	bne.n	10060 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
   1005a:	e9c0 0000 	strd	r0, r0, [r0]
}
   1005e:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   10060:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   10062:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   10064:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   10066:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   10068:	4411      	add	r1, r2
   1006a:	e7f4      	b.n	10056 <k_mem_slab_init+0xe>

0001006c <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   1006c:	2300      	movs	r3, #0
   1006e:	e9c0 0000 	strd	r0, r0, [r0]
	mutex->lock_count = 0U;
   10072:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   10076:	4770      	bx	lr

00010078 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   10078:	7b43      	ldrb	r3, [r0, #13]
   1007a:	06db      	lsls	r3, r3, #27
   1007c:	bf03      	ittte	eq
   1007e:	6980      	ldreq	r0, [r0, #24]
   10080:	fab0 f080 	clzeq	r0, r0
   10084:	0940      	lsreq	r0, r0, #5
   10086:	2000      	movne	r0, #0
}
   10088:	4770      	bx	lr

0001008a <z_unpend_thread_no_timeout>:
{
   1008a:	b538      	push	{r3, r4, r5, lr}
   1008c:	4604      	mov	r4, r0
   1008e:	f04f 0320 	mov.w	r3, #32
   10092:	f3ef 8511 	mrs	r5, BASEPRI
   10096:	f383 8811 	msr	BASEPRI, r3
   1009a:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1009e:	4601      	mov	r1, r0
   100a0:	6880      	ldr	r0, [r0, #8]
   100a2:	f7fe f961 	bl	e368 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   100a6:	7b63      	ldrb	r3, [r4, #13]
   100a8:	f023 0302 	bic.w	r3, r3, #2
   100ac:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   100ae:	f385 8811 	msr	BASEPRI, r5
   100b2:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   100b6:	2300      	movs	r3, #0
   100b8:	60a3      	str	r3, [r4, #8]
}
   100ba:	bd38      	pop	{r3, r4, r5, pc}

000100bc <z_reschedule>:
{
   100bc:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
   100be:	b939      	cbnz	r1, 100d0 <z_reschedule+0x14>
   100c0:	f7fe f8ea 	bl	e298 <resched.part.15>
	if (resched(key.key)) {
   100c4:	b120      	cbz	r0, 100d0 <z_reschedule+0x14>
}
   100c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   100ca:	4608      	mov	r0, r1
   100cc:	f7fd b952 	b.w	d374 <z_arch_swap>
   100d0:	f381 8811 	msr	BASEPRI, r1
   100d4:	f3bf 8f6f 	isb	sy
   100d8:	bd08      	pop	{r3, pc}

000100da <z_reschedule_irqlock>:
{
   100da:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
   100dc:	4602      	mov	r2, r0
   100de:	b938      	cbnz	r0, 100f0 <z_reschedule_irqlock+0x16>
   100e0:	f7fe f8da 	bl	e298 <resched.part.15>
	if (resched(key)) {
   100e4:	b120      	cbz	r0, 100f0 <z_reschedule_irqlock+0x16>
}
   100e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   100ea:	4610      	mov	r0, r2
   100ec:	f7fd b942 	b.w	d374 <z_arch_swap>
   100f0:	f382 8811 	msr	BASEPRI, r2
   100f4:	f3bf 8f6f 	isb	sy
   100f8:	bd08      	pop	{r3, pc}

000100fa <z_reschedule_unlocked>:
	__asm__ volatile(
   100fa:	f04f 0320 	mov.w	r3, #32
   100fe:	f3ef 8011 	mrs	r0, BASEPRI
   10102:	f383 8811 	msr	BASEPRI, r3
   10106:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(z_arch_irq_lock());
   1010a:	f7ff bfe6 	b.w	100da <z_reschedule_irqlock>

0001010e <z_priq_dumb_best>:
	return list->head == list;
   1010e:	6803      	ldr	r3, [r0, #0]
}
   10110:	4298      	cmp	r0, r3
   10112:	bf14      	ite	ne
   10114:	4618      	movne	r0, r3
   10116:	2000      	moveq	r0, #0
   10118:	4770      	bx	lr

0001011a <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
   1011a:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   1011e:	b570      	push	{r4, r5, r6, lr}
   10120:	4604      	mov	r4, r0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
   10122:	f1a0 0518 	sub.w	r5, r0, #24
	if (th->base.pended_on != NULL) {
   10126:	b1cb      	cbz	r3, 1015c <z_thread_timeout+0x42>
   10128:	f04f 0320 	mov.w	r3, #32
   1012c:	f3ef 8611 	mrs	r6, BASEPRI
   10130:	f383 8811 	msr	BASEPRI, r3
   10134:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   10138:	4629      	mov	r1, r5
   1013a:	f850 0c10 	ldr.w	r0, [r0, #-16]
   1013e:	f7fe f913 	bl	e368 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   10142:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   10146:	f023 0302 	bic.w	r3, r3, #2
   1014a:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   1014e:	f386 8811 	msr	BASEPRI, r6
   10152:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   10156:	2300      	movs	r3, #0
   10158:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1015c:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   10160:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   10162:	f023 0314 	bic.w	r3, r3, #20
   10166:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   1016a:	f7ff ff85 	bl	10078 <z_is_thread_ready>
   1016e:	b120      	cbz	r0, 1017a <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   10170:	4628      	mov	r0, r5
}
   10172:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10176:	f7fe b947 	b.w	e408 <z_add_thread_to_ready_q>
   1017a:	bd70      	pop	{r4, r5, r6, pc}

0001017c <z_unpend_first_thread>:
{
   1017c:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1017e:	f04f 0320 	mov.w	r3, #32
   10182:	f3ef 8211 	mrs	r2, BASEPRI
   10186:	f383 8811 	msr	BASEPRI, r3
   1018a:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1018e:	f7ff ffbe 	bl	1010e <z_priq_dumb_best>
   10192:	4604      	mov	r4, r0
	__asm__ volatile(
   10194:	f382 8811 	msr	BASEPRI, r2
   10198:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   1019c:	b1c8      	cbz	r0, 101d2 <z_unpend_first_thread+0x56>
	__asm__ volatile(
   1019e:	f04f 0320 	mov.w	r3, #32
   101a2:	f3ef 8511 	mrs	r5, BASEPRI
   101a6:	f383 8811 	msr	BASEPRI, r3
   101aa:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   101ae:	4601      	mov	r1, r0
   101b0:	6880      	ldr	r0, [r0, #8]
   101b2:	f7fe f8d9 	bl	e368 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   101b6:	7b63      	ldrb	r3, [r4, #13]
   101b8:	f023 0302 	bic.w	r3, r3, #2
   101bc:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   101be:	f385 8811 	msr	BASEPRI, r5
   101c2:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   101c6:	2300      	movs	r3, #0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   101c8:	f104 0018 	add.w	r0, r4, #24
   101cc:	60a3      	str	r3, [r4, #8]
   101ce:	f000 f832 	bl	10236 <z_abort_timeout>
}
   101d2:	4620      	mov	r0, r4
   101d4:	bd38      	pop	{r3, r4, r5, pc}

000101d6 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   101d6:	7b43      	ldrb	r3, [r0, #13]
   101d8:	06db      	lsls	r3, r3, #27
   101da:	bf03      	ittte	eq
   101dc:	6980      	ldreq	r0, [r0, #24]
   101de:	fab0 f080 	clzeq	r0, r0
   101e2:	0940      	lsreq	r0, r0, #5
   101e4:	2000      	movne	r0, #0
}
   101e6:	4770      	bx	lr

000101e8 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   101e8:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   101ea:	b510      	push	{r4, lr}
   101ec:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   101ee:	b103      	cbz	r3, 101f2 <z_thread_single_abort+0xa>
		thread->fn_abort();
   101f0:	4798      	blx	r3
	if (z_is_thread_ready(thread)) {
   101f2:	4620      	mov	r0, r4
   101f4:	f7ff ffef 	bl	101d6 <z_is_thread_ready>
   101f8:	b138      	cbz	r0, 1020a <z_thread_single_abort+0x22>
		z_remove_thread_from_ready_q(thread);
   101fa:	4620      	mov	r0, r4
   101fc:	f7fe f9b6 	bl	e56c <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_DEAD;
   10200:	7b63      	ldrb	r3, [r4, #13]
   10202:	f043 0308 	orr.w	r3, r3, #8
   10206:	7363      	strb	r3, [r4, #13]
}
   10208:	bd10      	pop	{r4, pc}
		if (z_is_thread_pending(thread)) {
   1020a:	7b63      	ldrb	r3, [r4, #13]
   1020c:	079b      	lsls	r3, r3, #30
   1020e:	d502      	bpl.n	10216 <z_thread_single_abort+0x2e>
			z_unpend_thread_no_timeout(thread);
   10210:	4620      	mov	r0, r4
   10212:	f7ff ff3a 	bl	1008a <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
   10216:	69a3      	ldr	r3, [r4, #24]
   10218:	2b00      	cmp	r3, #0
   1021a:	d0f1      	beq.n	10200 <z_thread_single_abort+0x18>
   1021c:	f104 0018 	add.w	r0, r4, #24
   10220:	f000 f809 	bl	10236 <z_abort_timeout>
   10224:	e7ec      	b.n	10200 <z_thread_single_abort+0x18>

00010226 <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   10226:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
   10228:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   1022a:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
   1022c:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
   1022e:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   10230:	e9c0 3306 	strd	r3, r3, [r0, #24]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   10234:	4770      	bx	lr

00010236 <z_abort_timeout>:
{
   10236:	b510      	push	{r4, lr}
	__asm__ volatile(
   10238:	f04f 0220 	mov.w	r2, #32
   1023c:	f3ef 8411 	mrs	r4, BASEPRI
   10240:	f382 8811 	msr	BASEPRI, r2
   10244:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   10248:	6803      	ldr	r3, [r0, #0]
   1024a:	b13b      	cbz	r3, 1025c <z_abort_timeout+0x26>
			remove_timeout(to);
   1024c:	f7fe fb00 	bl	e850 <remove_timeout>
			ret = 0;
   10250:	2000      	movs	r0, #0
	__asm__ volatile(
   10252:	f384 8811 	msr	BASEPRI, r4
   10256:	f3bf 8f6f 	isb	sy
}
   1025a:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   1025c:	f06f 0015 	mvn.w	r0, #21
   10260:	e7f7      	b.n	10252 <z_abort_timeout+0x1c>

00010262 <z_get_next_timeout_expiry>:
{
   10262:	b510      	push	{r4, lr}
	__asm__ volatile(
   10264:	f04f 0320 	mov.w	r3, #32
   10268:	f3ef 8411 	mrs	r4, BASEPRI
   1026c:	f383 8811 	msr	BASEPRI, r3
   10270:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   10274:	f7fe fb02 	bl	e87c <next_timeout>
	__asm__ volatile(
   10278:	f384 8811 	msr	BASEPRI, r4
   1027c:	f3bf 8f6f 	isb	sy
}
   10280:	bd10      	pop	{r4, pc}

00010282 <z_set_timeout_expiry>:
{
   10282:	b570      	push	{r4, r5, r6, lr}
   10284:	4604      	mov	r4, r0
   10286:	460e      	mov	r6, r1
	__asm__ volatile(
   10288:	f04f 0320 	mov.w	r3, #32
   1028c:	f3ef 8511 	mrs	r5, BASEPRI
   10290:	f383 8811 	msr	BASEPRI, r3
   10294:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   10298:	f7fe faf0 	bl	e87c <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   1029c:	2801      	cmp	r0, #1
   1029e:	dd05      	ble.n	102ac <z_set_timeout_expiry+0x2a>
   102a0:	42a0      	cmp	r0, r4
   102a2:	dd03      	ble.n	102ac <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   102a4:	4631      	mov	r1, r6
   102a6:	4620      	mov	r0, r4
   102a8:	f7fc fc54 	bl	cb54 <z_clock_set_timeout>
	__asm__ volatile(
   102ac:	f385 8811 	msr	BASEPRI, r5
   102b0:	f3bf 8f6f 	isb	sy
}
   102b4:	bd70      	pop	{r4, r5, r6, pc}

000102b6 <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   102b6:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

00010da0 <spm_request_read-0x7240>:
	...

00017fe0 <spm_request_read>:
   17fe0:	e97f e97f 	sg
   17fe4:	f7f4 bfca 	b.w	cf7c <__acle_se_spm_request_read>

00017fe8 <spm_firmware_info>:
   17fe8:	e97f e97f 	sg
   17fec:	f7f5 b824 	b.w	d038 <__acle_se_spm_firmware_info>

00017ff0 <spm_request_random_number>:
   17ff0:	e97f e97f 	sg
   17ff4:	f7f7 bead 	b.w	fd52 <__acle_se_spm_request_random_number>
	...
